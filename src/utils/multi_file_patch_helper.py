# src/utils/multi_file_patch_helper.py

import re
import os
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple

logger = logging.getLogger(__name__)


class MultiFilePatchHelper:
    """
    Helper utility for handling multi-file patches, which are often problematic
    when generated by LLMs. Provides functions to split, validate, and recombine patches.
    """

    def __init__(self, config):
        """Initialize the multi-file patch helper."""
        self.config = config
        self.repo_base_path = Path(config["data"]["repositories"])

    def split_patch(self, patch: str) -> List[str]:
        """
        Split a multi-file patch into individual file patches.

        Args:
            patch: Combined patch string

        Returns:
            List of individual file patch strings
        """
        if not patch or "diff --git" not in patch:
            return [patch] if patch else []

        # Look for diff --git headers to split the patch
        parts = re.split(r'(?=diff --git )', patch)

        # First part might be empty if patch starts with diff --git
        return [p for p in parts if p.strip()]

    def recombine_patches(self, patches: List[str]) -> str:
        """
        Recombine individual file patches into a multi-file patch.

        Args:
            patches: List of individual file patch strings

        Returns:
            Combined patch string
        """
        return '\n'.join(p.strip() for p in patches if p.strip())

    def check_file_exists(self, file_path: str, repo_name: str) -> bool:
        """
        Check if a file exists in the repository.

        Args:
            file_path: File path to check
            repo_name: Repository name

        Returns:
            True if file exists, False otherwise
        """
        repo_path = self.repo_base_path / repo_name
        if not repo_path.exists():
            return False

        full_path = repo_path / file_path
        return full_path.exists()

    def fix_file_paths(self, patch: str, repo_name: str) -> str:
        """
        Fix file paths in patch to ensure they exist.

        Args:
            patch: Patch string
            repo_name: Repository name

        Returns:
            Patch with corrected file paths
        """
        file_matches = re.findall(r'diff --git a/(.*?) b/(.*)', patch)
        if not file_matches:
            return patch

        repo_path = self.repo_base_path / repo_name
        if not repo_path.exists():
            return patch

        fixed_patch = patch

        for a_path, b_path in file_matches:
            # If a_path and b_path differ, but should be the same for modifications
            if a_path != b_path and "new file mode" not in patch and "deleted file mode" not in patch:
                logger.info(f"Fixing mismatched paths: {a_path} and {b_path}")
                fixed_patch = fixed_patch.replace(f"diff --git a/{a_path} b/{b_path}",
                                                  f"diff --git a/{a_path} b/{a_path}")
                fixed_patch = fixed_patch.replace(f"+++ b/{b_path}", f"+++ b/{a_path}")

            # Check if file exists
            if not self.check_file_exists(a_path, repo_name) and "new file mode" not in patch:
                # Try to find a similar file
                similar_file = self._find_similar_file(a_path, repo_path)
                if similar_file:
                    rel_path = str(similar_file.relative_to(repo_path))
                    logger.info(f"Replacing non-existent file {a_path} with {rel_path}")

                    # Replace all occurrences
                    fixed_patch = fixed_patch.replace(f"a/{a_path}", f"a/{rel_path}")
                    fixed_patch = fixed_patch.replace(f"b/{a_path}", f"b/{rel_path}")
                    fixed_patch = fixed_patch.replace(f"b/{b_path}", f"b/{rel_path}")

        return fixed_patch

    def _find_similar_file(self, file_path: str, repo_path: Path) -> Optional[Path]:
        """Find a similar file in the repository."""
        # Try exact filename first
        filename = os.path.basename(file_path)
        matches = list(repo_path.glob(f"**/{filename}"))
        if matches:
            return matches[0]

        # Try partial path matching
        path_parts = Path(file_path).parts
        if len(path_parts) > 1:
            # Try matching with the last two parts
            partial_path = os.path.join(*path_parts[-2:]) if len(path_parts) >= 2 else path_parts[-1]
            for p in repo_path.glob("**/*.py"):
                if partial_path in str(p):
                    return p

        # Try by extension
        ext = os.path.splitext(file_path)[1]
        if ext:
            # Find all files with this extension and check for name similarity
            name_base = os.path.splitext(filename)[0]
            for p in repo_path.glob(f"**/*{ext}"):
                file_base = os.path.splitext(p.name)[0]
                # If name is somewhat similar
                if name_base in file_base or file_base in name_base:
                    return p

        return None

    def validate_multi_file_patch(self, patch: str, repo_name: str) -> Tuple[bool, str, List[Dict[str, Any]]]:
        """
        Validate a multi-file patch and provide detailed feedback.

        Args:
            patch: Patch string
            repo_name: Repository name

        Returns:
            Tuple of (is_valid, fixed_patch, validation_results)
        """
        # Split the patch into individual file patches
        file_patches = self.split_patch(patch)
        if not file_patches:
            return False, patch, [{"file": None, "valid": False, "error": "No valid patches found"}]

        # Fix file paths
        fixed_patches = []
        validation_results = []

        for i, file_patch in enumerate(file_patches):
            # Extract file path
            file_match = re.search(r'diff --git a/(.*?) b/', file_patch)
            file_path = file_match.group(1) if file_match else f"unknown_file_{i}.py"

            # Fix file paths
            fixed_file_patch = self.fix_file_paths(file_patch, repo_name)

            # Basic validation
            has_header = "diff --git" in fixed_file_patch
            has_minus_plus = "---" in fixed_file_patch and "+++" in fixed_file_patch
            has_hunk = "@@ " in fixed_file_patch

            is_valid = has_header and has_minus_plus and has_hunk

            # Add to results
            validation_results.append({
                "file": file_path,
                "valid": is_valid,
                "error": None if is_valid else self._determine_error(fixed_file_patch)
            })

            fixed_patches.append(fixed_file_patch)

        # Recombine fixed patches
        fixed_combined_patch = self.recombine_patches(fixed_patches)

        # Overall validation - valid if at least one patch is valid
        is_valid = any(result["valid"] for result in validation_results)

        return is_valid, fixed_combined_patch, validation_results

    def _determine_error(self, patch: str) -> str:
        """Determine the error in an invalid patch."""
        if "diff --git" not in patch:
            return "Missing diff --git header"
        if "---" not in patch:
            return "Missing --- line"
        if "+++" not in patch:
            return "Missing +++ line"
        if "@@ " not in patch:
            return "Missing hunk header (@@ line)"

        # Check for common problems in hunk headers
        hunk_match = re.search(r'@@ .*? @@', patch)
        if hunk_match:
            hunk_header = hunk_match.group(0)
            if not re.match(r'@@ -\d+(?:,\d+)? \+\d+(?:,\d+)? @@', hunk_header):
                return "Malformed hunk header, should be: @@ -start,count +start,count @@"

        return "Unknown error in patch format"

    def find_files_in_repo(self, repo_name: str, search_text: str, file_extensions: List[str] = None) -> List[str]:
        """
        Find files in the repository that contain the search text.

        Args:
            repo_name: Repository name
            search_text: Text to search for
            file_extensions: List of file extensions to search in (default: [".py"])

        Returns:
            List of file paths containing the search text
        """
        repo_path = self.repo_base_path / repo_name
        if not repo_path.exists():
            return []

        if file_extensions is None:
            file_extensions = [".py"]

        matching_files = []

        for ext in file_extensions:
            # Find all files with this extension
            files = repo_path.glob(f"**/*{ext}")

            # Check each file for the search text
            for file_path in files:
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        if search_text in content:
                            matching_files.append(str(file_path.relative_to(repo_path)))
                except Exception as e:
                    logger.error(f"Error reading file {file_path}: {e}")

        return matching_files

    def create_patch_from_context(self, repo_name: str, file_path: str,
                                  old_lines: List[str], new_lines: List[str]) -> str:
        """
        Create a patch from context lines.

        Args:
            repo_name: Repository name
            file_path: File path
            old_lines: Lines to remove
            new_lines: Lines to add

        Returns:
            Patch string
        """
        if not old_lines and not new_lines:
            return ""

        # Create patch header
        patch = f"diff --git a/{file_path} b/{file_path}\n"
        patch += f"--- a/{file_path}\n"
        patch += f"+++ b/{file_path}\n"

        # Create hunk header - simplified
        patch += f"@@ -1,{len(old_lines)} +1,{len(new_lines)} @@\n"

        # Add removed lines
        for line in old_lines:
            patch += f"-{line}\n"

        # Add added lines
        for line in new_lines:
            patch += f"+{line}\n"

        return patch
