{
  "problem_id": "maximum-value-sum-by-placing-three-rooks-i",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heappush(heap, current_sum)\n                                    else:\n                                        heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import heapq\n        from typing import List\n\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heapq.heappush(heap, current_sum)\n                                    else:\n                                        heapq.heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    if heap:\n                        max_sum = max(max_sum, heap[-1])\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heapq.heappush(heap, current_sum)\n                                    else:\n                                        heapq.heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    if heap:\n                        max_sum = max(max_sum, heap[-1])\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import heapq\n        from typing import List\n\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heapq.heappush(heap, current_sum)\n                                    else:\n                                        heapq.heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    if heap:\n                        max_sum = max(max_sum, heap[-1])\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import heapq\n        from typing import List\n\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heapq.heappush(heap, current_sum)\n                                    else:\n                                        heapq.heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    if heap:\n                        max_sum = max(max_sum, heap[-1])\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute sorted lists for each row\n        sorted_rows = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            sorted_rows.append(sorted_row)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for comb in combinations(range(m), 3):\n            # Get the sorted lists for these rows\n            row1, row2, row3 = (sorted_rows[i] for i in comb)\n            \n            # Use a heap to keep track of the top sums\n            heap = []\n            # Iterate through all possible column combinations\n            for col1, val1 in row1:\n                for col2, val2 in row2:\n                    if col2 == col1:\n                        continue\n                    for col3, val3 in row3:\n                        if col3 == col1 or col3 == col2:\n                            continue\n                        current_sum = val1 + val2 + val3\n                        if len(heap) < 3:\n                            heappush(heap, current_sum)\n                        else:\n                            heappushpop(heap, current_sum)\n            # The heap contains the top 3 sums for this combination of rows\n            max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute sorted lists for each row\n        sorted_rows = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            sorted_rows.append(sorted_row)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for comb in combinations(range(m), 3):\n            # Get the sorted lists for these rows\n            row1, row2, row3 = (sorted_rows[i] for i in comb)\n            \n            # Use a heap to keep track of the top sums\n            heap = []\n            # Iterate through all possible column combinations\n            for col1, val1 in row1:\n                for col2, val2 in row2:\n                    if col2 == col1:\n                        continue\n                    for col3, val3 in row3:\n                        if col3 == col1 or col3 == col2:\n                            continue\n                        current_sum = val1 + val2 + val3\n                        if len(heap) < 3:\n                            heappush(heap, current_sum)\n                        else:\n                            heappushpop(heap, current_sum)\n            # The heap contains the top 3 sums for this combination of rows\n            max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute sorted lists for each row\n        sorted_rows = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            sorted_rows.append(sorted_row)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for comb in combinations(range(m), 3):\n            # Get the sorted lists for these rows\n            row1, row2, row3 = (sorted_rows[i] for i in comb)\n            \n            # Use a heap to keep track of the top sums\n            heap = []\n            # Iterate through all possible column combinations\n            for col1, val1 in row1:\n                for col2, val2 in row2:\n                    if col2 == col1:\n                        continue\n                    for col3, val3 in row3:\n                        if col3 == col1 or col3 == col2:\n                            continue\n                        current_sum = val1 + val2 + val3\n                        if len(heap) < 3:\n                            heappush(heap, current_sum)\n                        else:\n                            heappushpop(heap, current_sum)\n            # The heap contains the top 3 sums for this combination of rows\n            max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n\ndef maximumValueSum(self, board: List[List[int]]) -> int:\n\nm = len(board)\n\nn = len(board[0])\n\n# Flatten the board\n\ncells = []\n\nfor i in range(m):\n\nfor j in range(n):\n\ncells.append((i, j, board[i][j]))\n\n# Sort cells in decreasing order of value\n\ncells.sort(key=lambda x: x[2], reverse=True)\n\n# Select rooks\n\nselected_rows = set()\n\nselected_cols = set()\n\nsum_val = 0\n\ncount = 0\n\nfor cell in cells:\n\nrow, col, val = cell\n\nif row not in selected_rows and col not in selected_cols:\n\nselected_rows.add(row)\n\nselected_cols.add(col)\n\nsum_val += val\n\ncount += 1\n\nif count == 3:\n\nbreak\n\nreturn sum_val\n\nThis seems simple and efficient.\n\nLet me test this with the first example:\n\nboard = [\n\n[-3,1,1,1],\n\n[-3,1,-3,1],\n\n[-3,2,1,1]\n\n]\n\nFlattened cells:\n\n(0,0,-3), (0,1,1), (0,2,1), (0,3,1),\n\n(1,0,-3), (1,1,1), (1,2,-3), (1,3,1),\n\n(2,0,-3), (2,1,2), (2,2,1), (2,3,1)\n\nSorted by value: (2,1,2), (0,1,1), (0,2,1), (0,3,1), (1,1,1), (1,3,1), (2,2,1), (2,3,1), (0,0,-3), (1,0,-3), (1,2,-3), (2,0,-3)\n\nSelect (2,1,2), add to sum (sum=2), selected_rows={2}, selected_cols={1}\n\nNext, (0,1,1), but row 0 not in selected_rows and col 1 in selected_cols, skip\n\nNext, (0,2,1), row 0 not in selected_rows, col 2 not in selected_cols, select. sum=3, selected_rows={2,0}, selected_cols={1,2}",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute sorted lists for each row\n        sorted_rows = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            sorted_rows.append(sorted_row)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for comb in combinations(range(m), 3):\n            # Get the sorted lists for these rows\n            row1, row2, row3 = (sorted_rows[i] for i in comb)\n            \n            # Use a heap to keep track of the top sums\n            heap = []\n            # Iterate through columns in row1\n            for idx1, val1 in row1:\n                # Iterate through columns in row2 that are not in row1\n                for idx2, val2 in row2:\n                    if idx2 == idx1:\n                        continue\n                    # Iterate through columns in row3 that are not in row1 or row2\n                    for idx3, val3 in row3:\n                        if idx3 == idx1 or idx3 == idx2:\n                            continue\n                        current_sum = val1 + val2 + val3\n                        if len(heap) < 3:\n                            heappush(heap, current_sum)\n                        else:\n                            heappushpop(heap, current_sum)\n            # The heap contains the top 3 sums for this combination of rows\n            max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "from typing import List\nfrom itertools import combinations\nimport heapq\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute sorted lists for each row\n        sorted_rows = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            sorted_rows.append(sorted_row)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for comb in combinations(range(m), 3):\n            # Get the sorted lists for these rows\n            row1, row2, row3 = (sorted_rows[i] for i in comb)\n            \n            # Use a heap to keep track of the top sums\n            heap = []\n            # Iterate through columns in row1\n            for idx1, val1 in row1:\n                # Iterate through columns in row2 that are not in row1\n                for idx2, val2 in row2:\n                    if idx2 == idx1:\n                        continue\n                    # Iterate through columns in row3 that are not in row1 or row2\n                    for idx3, val3 in row3:\n                        if idx3 == idx1 or idx3 == idx2:\n                            continue\n                        current_sum = val1 + val2 + val3\n                        if len(heap) < 3:\n                            heapq.heappush(heap, current_sum)\n                        else:\n                            heapq.heappushpop(heap, current_sum)\n            # The heap contains the top 3 sums for this combination of rows\n            max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "from typing import List\nfrom itertools import combinations\nimport heapq\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute sorted lists for each row\n        sorted_rows = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            sorted_rows.append(sorted_row)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for comb in combinations(range(m), 3):\n            # Get the sorted lists for these rows\n            row1, row2, row3 = (sorted_rows[i] for i in comb)\n            \n            # Use a heap to keep track of the top sums\n            heap = []\n            # Iterate through columns in row1\n            for idx1, val1 in row1:\n                # Iterate through columns in row2 that are not in row1\n                for idx2, val2 in row2:\n                    if idx2 == idx1:\n                        continue\n                    # Iterate through columns in row3 that are not in row1 or row2\n                    for idx3, val3 in row3:\n                        if idx3 == idx1 or idx3 == idx2:\n                            continue\n                        current_sum = val1 + val2 + val3\n                        if len(heap) < 3:\n                            heapq.heappush(heap, current_sum)\n                        else:\n                            heapq.heappushpop(heap, current_sum)\n            # The heap contains the top 3 sums for this combination of rows\n            max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "from typing import List\nfrom itertools import combinations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute sorted lists for each row\n        sorted_rows = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            sorted_rows.append(sorted_row)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for comb in combinations(range(m), 3):\n            # Get the sorted lists for these rows\n            row1, row2, row3 = (sorted_rows[i] for i in comb)\n            \n            # Use a heap to keep track of the top sums\n            heap = []\n            # Iterate through columns in row1\n            for idx1, val1 in row1:\n                # Iterate through columns in row2 that are not in row1\n                for idx2, val2 in row2:\n                    if idx2 == idx1:\n                        continue\n                    # Iterate through columns in row3 that are not in row1 or row2\n                    for idx3, val3 in row3:\n                        if idx3 == idx1 or idx3 == idx2:\n                            continue\n                        current_sum = val1 + val2 + val3\n                        if len(heap) < 3:\n                            heapq.heappush(heap, current_sum)\n                        else:\n                            heapq.heappushpop(heap, current_sum)\n            # The heap contains the top 3 sums for this combination of rows\n            max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        # Flatten the board and sort cells by value in descending order\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((i, j, board[i][j]))\n        cells.sort(key=lambda x: x[2], reverse=True)\n        \n        selected = []\n        rows = set()\n        cols = set()\n        \n        for cell in cells:\n            row, col, val = cell\n            if row not in rows and col not in cols:\n                selected.append(val)\n                rows.add(row)\n                cols.add(col)\n                if len(selected) == 3:\n                    break\n        \n        return sum(selected)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                # Flatten the board and sort cells by value in descending order\n                cells = []\n                for i in range(m):\n                    for j in range(n):\n                        cells.append((i, j, board[i][j]))\n                cells.sort(key=lambda x: x[2], reverse=True)\n                \n                selected = []\n                rows = set()\n                cols = set()\n                \n                for cell in cells:\n                    row, col, val = cell\n                    if row not in rows and col not in cols:\n                        selected.append(val)\n                        rows.add(row)\n                        cols.add(col)\n                        if len(selected) == 3:\n                            break\n                \n                return sum(selected)",
    "[1,1]\n\n[1,1]",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute row and column maximums\n        row_maxes = []\n        for i in range(m):\n            row = board[i]\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            row_maxes.append(sorted_row)\n        \n        col_maxes = []\n        for j in range(n):\n            col = [board[i][j] for i in range(m)]\n            sorted_col = sorted(enumerate(col), key=lambda x: x[1], reverse=True)\n            col_maxes.append(sorted_col)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all possible combinations of row and column selections\n        for i1 in range(m):\n            for j1 in range(n):\n                # Select the first rook\n                val1 = board[i1][j1]\n                # Find the next best rook in different row and column\n                remaining_rows = [i for i in range(m) if i != i1]\n                remaining_cols = [j for j in range(n) if j != j1]\n                \n                max_val2 = float('-inf')\n                for i2 in remaining_rows:\n                    for j2 in remaining_cols:\n                        if j2 != j1:\n                            val2 = board[i2][j2]\n                            # Find the third rook in remaining rows and columns\n                            remaining_rows2 = [i for i in remaining_rows if i != i2]\n                            remaining_cols2 = [j for j in remaining_cols if j != j2]\n                            \n                            max_val3 = float('-inf')\n                            for i3 in remaining_rows2:\n                                for j3 in remaining_cols2:\n                                    if j3 != j1 and j3 != j2:\n                                        val3 = board[i3][j3]\n                                        if val1 + val2 + val3 > max_sum:\n                                            max_sum = val1 + val2 + val3\n                if val1 + max_val2 + max_val3 > max_sum:\n                    max_sum = val1 + max_val2 + max_val3\n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        # Flatten the board and sort cells by value in descending order\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((i, j, board[i][j]))\n        cells.sort(key=lambda x: x[2], reverse=True)\n        \n        selected = []\n        rows = set()\n        cols = set()\n        \n        for cell in cells:\n            row, col, val = cell\n            if row not in rows and col not in cols:\n                selected.append(val)\n                rows.add(row)\n                cols.add(col)\n                if len(selected) == 3:\n                    break\n        \n        return sum(selected)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                def backtrack(row, columns_used, current_sum):\n                    if row == 3:\n                        return current_sum\n                    max_sum = -inf\n                    for i in range(m):\n                        for j in range(n):\n                            if i not in rows_used and j not in columns_used:\n                                rows_used.add(i)\n                                columns_used.add(j)\n                                max_sum = max(max_sum, backtrack(row + 1, columns_used, current_sum + board[i][j]))\n                                rows_used.remove(i)\n                                columns_used.remove(j)\n                    return max_sum\n                \n                rows_used = set()\n                columns_used = set()\n                return backtrack(0, columns_used, 0)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                # Create a list of all cells with their row, column, and value\n                cells = []\n                for i in range(m):\n                    for j in range(n):\n                        cells.append((i, j, board[i][j]))\n                # Sort the cells in descending order of their values\n                cells.sort(key=lambda x: x[2], reverse=True)\n                \n                selected = []\n                rows_used = set()\n                cols_used = set()\n                \n                for cell in cells:\n                    row, col, val = cell\n                    # Check if placing a rook at this cell is possible without attacking others\n                    if row not in rows_used and col not in cols_used:\n                        selected.append(val)\n                        rows_used.add(row)\n                        cols_used.add(col)\n                        # If we have selected 3 rooks, break early\n                        if len(selected) == 3:\n                            break\n                \n                # Return the sum of the values of the selected cells\n                return sum(selected)",
    "from typing import List\n\nclass Solution:\n\ndef maximumValueSum(self, board: List[List[int]]) -> int:\n\nm, n = len(board), len(board[0])\n\n# Flatten the board and sort cells by value in descending order\n\ncells = []\n\nfor i in range(m):\n\nfor j in range(n):\n\ncells.append((i, j, board[i][j]))\n\ncells.sort(key=lambda x: x[2], reverse=True)\n\nselected = []\n\nrows = set()\n\ncols = set()\n\nfor cell in cells:\n\nrow, col, val = cell\n\nif row not in rows and col not in cols:\n\nselected.append(val)\n\nrows.add(row)\n\ncols.add(col)\n\nif len(selected) == 3:\n\nbreak\n\nreturn sum(selected)",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        # Flatten the board and sort cells by value in descending order\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((i, j, board[i][j]))\n        cells.sort(key=lambda x: x[2], reverse=True)\n        \n        selected = []\n        rows = set()\n        cols = set()\n        \n        for cell in cells:\n            row, col, val = cell\n            if row not in rows and col not in cols:\n                selected.append(val)\n                rows.add(row)\n                cols.add(col)\n                if len(selected) == 3:\n                    break\n        \n        return sum(selected)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                max_sum = float('-inf')\n                \n                # Helper function for backtracking\n                def backtrack(row, cols_used, current_sum):\n                    nonlocal max_sum\n                    if row == 3:\n                        max_sum = max(max_sum, current_sum)\n                        return\n                    for col in range(n):\n                        if col not in cols_used:\n                            # Place rook in (row, col)\n                            cols_used.add(col)\n                            backtrack(row + 1, cols_used, current_sum + board[row][col])\n                            cols_used.remove(col)\n                \n                # Start backtracking from row 0 with an empty set of used columns\n                backtrack(0, set(), 0)\n                return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Flatten the board and sort cells by value in descending order\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((i, j, board[i][j]))\n        cells.sort(key=lambda x: x[2], reverse=True)\n        \n        selected = []\n        rows = set()\n        cols = set()\n        \n        for cell in cells:\n            row, col, val = cell\n            if row not in rows and col not in cols:\n                selected.append(val)\n                rows.add(row)\n                cols.add(col)\n                if len(selected) == 3:\n                    break\n        \n        return sum(selected)",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heappush(heap, current_sum)\n                                    else:\n                                        heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heappush(heap, current_sum)\n                                    else:\n                                        heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import heapq\n        from typing import List\n\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heapq.heappush(heap, current_sum)\n                                    else:\n                                        heapq.heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heappush(heap, current_sum)\n                                    else:\n                                        heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
    "class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute the top 3 values and their indices for each row\n                row_top3 = []\n                for row in board:\n                    indexed_row = list(enumerate(row))\n                    sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n                    row_top3.append(sorted_row[:3])\n                \n                max_sum = float('-inf')\n                # Iterate through all combinations of three rows\n                for i in range(m):\n                    for j in range(i+1, m):\n                        for k in range(j+1, m):\n                            # Get the top 3 values from each row\n                            top3_i = row_top3[i]\n                            top3_j = row_top3[j]\n                            top3_k = row_top3[k]\n                            \n                            # Use a list to collect possible sums\n                            possible_sums = []\n                            for val_i, col_i in top3_i:\n                                for val_j, col_j in top3_j:\n                                    for val_k, col_k in top3_k:\n                                        if col_i != col_j and col_j != col_k and col_i != col_k:\n                                            current_sum = val_i + val_j + val_k\n                                            possible_sums.append(current_sum)\n                            if possible_sums:\n                                max_sum = max(max_sum, max(possible_sums))\n                \n                return max_sum",
    "class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute row and column sums\n                row_sums = [sum(row) for row in board]\n                col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n                \n                # Find the indices of the top 3 rows and columns\n                top3_rows = sorted(range(m), key=lambda x: row_sums[x], reverse=True)[:3]\n                top3_cols = sorted(range(n), key=lambda x: col_sums[x], reverse=True)[:3]\n                \n                # Initialize a heap to keep track of the top sums\n                heap = []\n                \n                # Iterate through all combinations of top 3 rows and top 3 columns\n                for rows in combinations(top3_rows, 3):\n                    for cols in permutations(top3_cols, 3):\n                        # Ensure that no two rooks are in the same row or column\n                        sum_val = sum(board[rows[i]][cols[i]] for i in range(3))\n                        if len(heap) < 3:\n                            heappush(heap, sum_val)\n                        else:\n                            heappushpop(heap, sum_val)\n                \n                # The heap contains the top 3 sums for the combinations\n                return max(heap) if heap else float('-inf')",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three distinct rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # For each combination of rows, iterate through all permutations of three distinct columns\n                    for x in range(n):\n                        for y in range(n):\n                            if y == x:\n                                continue\n                            for z in range(n):\n                                if z == x or z == y:\n                                    continue\n                                # Calculate the sum of the values in the selected cells\n                                current_sum = board[i][x] + board[j][y] + board[k][z]\n                                # Update max_sum if current_sum is greater\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute row and column sums\n        row_sums = [sum(row) for row in board]\n        col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n        \n        # Find the indices of the top 3 rows and columns\n        top3_rows = sorted(range(m), key=lambda x: row_sums[x], reverse=True)[:3]\n        top3_cols = sorted(range(n), key=lambda x: col_sums[x], reverse=True)[:3]\n        \n        # Initialize a variable to keep track of the maximum sum\n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of top 3 rows and top 3 columns\n        for rows in combinations(top3_rows, 3):\n            for cols in permutations(top3_cols, 3):\n                # Calculate the sum of the cells where rooks are placed\n                sum_val = sum(board[rows[i]][cols[i]] for i in range(3))\n                # Update the maximum sum if the current sum is greater\n                if sum_val > max_sum:\n                    max_sum = sum_val\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import itertools\n        m, n = len(board), len(board[0])\n        \n        # For each row, get the top 3 columns in descending order of value\n        row_top3 = []\n        for row in board:\n            # Create a list of (value, column_index) tuples for the row\n            indexed_row = [(val, col) for col, val in enumerate(row)]\n            # Sort this list in descending order of value\n            sorted_row = sorted(indexed_row, key=lambda x: x[0], reverse=True)\n            # Take the top 3\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for rows in itertools.combinations(range(m), 3):\n            # Get the top 3 columns for each of the three rows\n            top3_row0 = row_top3[rows[0]]\n            top3_row1 = row_top3[rows[1]]\n            top3_row2 = row_top3[rows[2]]\n            \n            # Try all permutations of column assignments\n            for val",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import itertools\n        m, n = len(board), len(board[0])\n        \n        # For each row, get the top 3 columns in descending order of value\n        row_top3 = []\n        for row in board:\n            # Create a list of (value, column_index) tuples for the row\n            indexed_row = [(val, col) for col, val in enumerate(row)]\n            # Sort this list in descending order of value\n            sorted_row = sorted(indexed_row, key=lambda x: x[0], reverse=True)\n            # Take the top 3\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for rows in itertools.combinations(range(m), 3):\n            # Get the top 3 columns for each of the three rows\n            top3_row0 = row_top3[rows[0]]\n            top3_row1 = row_top3[rows[1]]\n            top3_row2 = row_top3[rows[2]]\n            \n            # Try all permutations of column assignments\n            for col0, col1, col2 in itertools.product(\n                top3_row0, top3_row1, top3_row2\n            ):\n                # Check if all columns are unique\n                if len({col0[1], col1[1], col2[1]}) == 3:\n                    # Calculate the sum of the values\n                    current_sum = col0[0] + col1[0] + col2[0]\n                    # Update max_sum if this is the highest sum so far\n                    if current_sum > max_sum:\n                        max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import itertools\n        m, n = len(board), len(board[0])\n        \n        # For each row, get the top 3 columns in descending order of value\n        row_top3 = []\n        for row in board:\n            # Create a list of (value, column_index) tuples for the row\n            indexed_row = [(val, col) for col, val in enumerate(row)]\n            # Sort this list in descending order of value\n            sorted_row = sorted(indexed_row, key=lambda x: x[0], reverse=True)\n            # Take the top 3\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for rows in itertools.combinations(range(m), 3):\n            # Get the top 3 columns for each of the three rows\n            top3_row0 = row_top3[rows[0]]\n            top3_row1 = row_top3[rows[1]]\n            top3_row2 = row_top3[rows[2]]\n            \n            # Try all permutations of column assignments\n            for cols in itertools.permutations(range(n), 3):\n                # Check if the columns are distinct and within the top 3 for each row\n                if (cols[0] in [col for val, col in top3_row0] and\n                    cols[1] in [col for val, col in top3_row1] and\n                    cols[2] in [col for val, col in top3_row2]):\n                    # Calculate the sum of the selected cells\n                    sum_val = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]\n                    # Update max_sum if this sum is greater\n                    if sum_val > max_sum:\n                        max_sum = sum_val\n        \n        return max_sum",
    "from typing import List\nfrom itertools import combinations, permutations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        import itertools\n        m, n = len(board), len(board[0])\n        \n        # For each row, get the top 3 columns in descending order of value\n        row_top3 = []\n        for row in board:\n            # Create a list of (value, column_index) tuples for the row\n            indexed_row = [(val, col) for col, val in enumerate(row)]\n            # Sort this list in descending order of value\n            sorted_row = sorted(indexed_row, key=lambda x: x[0], reverse=True)\n            # Take the top 3\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three rows\n        for rows in itertools.combinations(range(m), 3):\n            # Get the top 3 columns for each of the three rows\n            top3_row0 = row_top3[rows[0]]\n            top3_row1 = row_top3[rows[1]]\n            top3_row2 = row_top3[rows[2]]\n            \n            # Try all permutations of column assignments ensuring columns are unique\n            for col0, col1, col2 in itertools.product(\n                top3_row0, top3_row1, top3_row2\n            ):\n                # Check if all columns are unique\n                if len({col0[1], col1[1], col2[1]}) == 3:\n                    current_sum = col0[0] + col1[0] + col2[0]\n                    if current_sum > max_sum:\n                        max_sum = current_sum\n        \n        return max_sum"
  ],
  "total_candidates": 36,
  "nodes_explored": 36,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heappush(heap, current_sum)\n                                    else:\n                                        heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
      "solution_hash": "071c3c49f2f55d5a0d29380550da5e259fa310a9b69158211bb0f094d08d4095",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmp83aof79n.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmp83aof79n.py` failed. (See above for error)\n",
        "execution_time": 13.459385395050049,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        # Flatten the board and sort cells by value in descending order\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((i, j, board[i][j]))\n        cells.sort(key=lambda x: x[2], reverse=True)\n        \n        selected = []\n        rows = set()\n        cols = set()\n        \n        for cell in cells:\n            row, col, val = cell\n            if row not in rows and col not in cols:\n                selected.append(val)\n                rows.add(row)\n                cols.add(col)\n                if len(selected) == 3:\n                    break\n        \n        return sum(selected)",
      "solution_hash": "2cef29ea849ae6cb25de04be3fcbb55f0c807ce9d7f50132c682971bf051ebf8",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmpk0qt1m6h.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmpk0qt1m6h.py` failed. (See above for error)\n",
        "execution_time": 13.21260118484497,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14",
        "1_17",
        "1_21"
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            indexed_row = list(enumerate(row))\n            sorted_row = sorted(indexed_row, key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        # Iterate through all combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values from each row\n                    top3_i = row_top3[i]\n                    top3_j = row_top3[j]\n                    top3_k = row_top3[k]\n                    \n                    # Use a heap to keep track of the top sums\n                    heap = []\n                    for val_i, col_i in top3_i:\n                        for val_j, col_j in top3_j:\n                            for val_k, col_k in top3_k:\n                                if col_i != col_j and col_j != col_k and col_i != col_k:\n                                    current_sum = val_i + val_j + val_k\n                                    if len(heap) < 3:\n                                        heappush(heap, current_sum)\n                                    else:\n                                        heappushpop(heap, current_sum)\n                    # The heap contains the top 3 sums for this combination of rows\n                    max_sum = max(max_sum, heap[-1] if heap else float('-inf'))\n        \n        return max_sum",
      "solution_hash": "071c3c49f2f55d5a0d29380550da5e259fa310a9b69158211bb0f094d08d4095",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmp83aof79n.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmp83aof79n.py` failed. (See above for error)\n",
        "execution_time": 13.459385395050049,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_25",
        "1_29",
        "1_32"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 36,
    "candidates_generated": 36,
    "tests_passed": 0,
    "tests_failed": 5,
    "test_timeouts": 0,
    "test_errors": 0,
    "import_errors": 31,
    "import_terminated_branches": 0,
    "unique_import_failures": [
      "sortedcontainers"
    ],
    "execution_times": [
      13.459385395050049,
      13.223905801773071,
      13.232232809066772,
      13.223905801773071,
      13.223905801773071,
      13.241236686706543,
      13.241236686706543,
      13.241236686706543,
      13.288648128509521,
      13.257437705993652,
      13.208615064620972,
      13.208615064620972,
      13.247900247573853,
      13.21260118484497,
      13.21260118484497,
      13.168585300445557,
      13.165138959884644,
      13.21260118484497,
      13.176417112350464,
      13.155041694641113,
      13.21260118484497,
      13.21260118484497,
      13.117217779159546,
      13.21260118484497,
      13.459385395050049,
      13.459385395050049,
      13.148530006408691,
      13.459385395050049,
      13.157068729400635,
      13.156739234924316,
      13.15288758277893,
      13.160598039627075,
      13.151020288467407,
      13.127323150634766,
      13.163260459899902,
      13.119898080825806
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 23,
      "unique_ratio": 0.6388888888888888,
      "similarity_score": 0.7973072678858459,
      "solution_lengths": {
        "min": 12,
        "max": 2183,
        "avg": 1367.1666666666667
      },
      "algorithm_approaches": {
        "backtracking": 27,
        "hash_table": 8,
        "other": 1
      },
      "feature_diversity": 0.7222222222222222,
      "features_analysis": {
        "boolean_features": {
          "has_recursion": {
            "true_ratio": 0.9722222222222222,
            "count": 35
          },
          "uses_list": {
            "true_ratio": 0.8611111111111112,
            "count": 31
          },
          "uses_dict": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_set": {
            "true_ratio": 0.2777777777777778,
            "count": 10
          },
          "uses_heap": {
            "true_ratio": 0.4722222222222222,
            "count": 17
          },
          "uses_queue": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_stack": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dp": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_bfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_binary_search": {
            "true_ratio": 0.0,
            "count": 0
          },
          "nested_loops": {
            "true_ratio": 0.9444444444444444,
            "count": 34
          }
        },
        "numeric_features": {
          "loop_count": {
            "min": 0,
            "max": 13,
            "avg": 5.25,
            "variance": 5.576388888888889
          },
          "if_count": {
            "min": 0,
            "max": 8,
            "avg": 2.6944444444444446,
            "variance": 1.8233024691358035
          },
          "else_count": {
            "min": 0,
            "max": 2,
            "avg": 0.8333333333333334,
            "variance": 0.8611111111111105
          },
          "return_count": {
            "min": 0,
            "max": 3,
            "avg": 1.0277777777777777,
            "variance": 0.19367283950617273
          },
          "assignment_count": {
            "min": 0,
            "max": 30,
            "avg": 12.555555555555555,
            "variance": 24.524691358024697
          },
          "class_method_count": {
            "min": 0,
            "max": 2,
            "avg": 1.0277777777777777,
            "variance": 0.08256172839506179
          },
          "line_count": {
            "min": 3,
            "max": 81,
            "avg": 34.52777777777778,
            "variance": 130.13811728395055
          },
          "char_count": {
            "min": 12,
            "max": 2183,
            "avg": 1367.1666666666667,
            "variance": 188438.8611111111
          },
          "max_indent": {
            "min": 0,
            "max": 44,
            "avg": 28.0,
            "variance": 135.11111111111111
          }
        }
      },
      "complexity_diversity": {
        "complexity_distribution": {
          "exponential": 35,
          "constant": 1
        },
        "avg_complexity_metrics": {
          "avg_line_count": 34.52777777777778,
          "avg_loop_count": 5.25,
          "avg_condition_count": 3.5277777777777777,
          "avg_method_count": 1.0277777777777777,
          "avg_assignment_count": 12.555555555555555,
          "avg_max_loop_nesting": 1.0277777777777777
        },
        "complexity_diversity_ratio": 0.3333333333333333
      }
    },
    "test_case_analysis": {
      "hardest_cases": {},
      "first_failing_tests": {}
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 9,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 24,
          "improvements": 0,
          "solved": 0
        }
      },
      "error_types": {
        "other_error": {
          "attempts": 11,
          "improvements": 0
        },
        "syntax_error": {
          "attempts": 1,
          "improvements": 0
        }
      },
      "test_case_improvements": {},
      "error_transitions": {
        "other_error->other_error": 29,
        "other_error->syntax_error": 1,
        "syntax_error->other_error": 3
      }
    },
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.5833333333333333,
        "solutions_per_depth": {
          "0": 3,
          "1": 9,
          "2": 24
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.0,
        "pass@3": 0.0,
        "pass@5": 0.0,
        "pass@10": 0.0
      },
      "solutions_evaluated": 37
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0,
        "test_success_rate": 0.0
      },
      "test_results": {
        "total": 36,
        "passed": 0,
        "failed": 5,
        "timeouts": 0,
        "import_errors": 31,
        "other_errors": 0,
        "unique_import_failures": [
          "sortedcontainers"
        ]
      },
      "error_recovery": {
        "total_attempts": 12,
        "total_improvements": 0,
        "recovery_rate": 0.0
      },
      "top_errors": [
        [
          "other_error",
          11
        ],
        [
          "syntax_error",
          1
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      },
      "import_analysis": {
        "total_import_errors": 31,
        "branches_terminated_by_imports": 0,
        "unique_missing_modules": 1,
        "missing_modules": [
          "sortedcontainers"
        ]
      }
    }
  },
  "processing_time": 3329.962513446808,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.0,
      "pass@3": 0.0,
      "pass@5": 0.0,
      "pass@10": 0.0
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: expected an indented block (<string>, line 102)",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: expected an indented block (<string>, line 102)",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: invalid syntax (<string>, line 125)",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 36
          }
        ]
      ]
    },
    "solutions_evaluated": 37,
    "test_cases": 1
  }
}