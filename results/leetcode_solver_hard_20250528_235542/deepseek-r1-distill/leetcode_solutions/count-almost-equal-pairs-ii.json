{
  "problem_id": "count-almost-equal-pairs-ii",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            n = len(num_str)\n            # Generate all possible variants with 0, 1, or 2 swaps\n            # 0 swaps: original\n            variants.add(num_str)\n            # 1 swap: swap any two digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # 2 swaps: swap two pairs of digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if i == k or i == l or j == k or j == l:\n                                continue\n                            swapped = list(num_str)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            # Add the current count of each variant to the total\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Increment the count for each variant\n            for var in variants:\n                count_map[var] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            key = tuple(sorted(str(num)))\n            total += count_map.get(key, 0)\n            count_map[key] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            n = len(num_str)\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped = list(num_str)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            variants.add(''.join(swapped))\n            # Also include the original number\n            variants.add(num_str)\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            # For each variant, check how many times it has been seen before\n            for v in variants:\n                total += count_map.get(v, 0)\n            # Update the count_map with the current number's variants\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_equal(a, b):\n            if len(a) != len(b):\n                return False\n            diff = [i for i in range(len(a)) if a[i] != b[i]]\n            if len(diff) == 0:\n                return True\n            if len(diff) % 2 != 0:\n                return False\n            if len(diff) == 2:\n                i, j = diff\n                return a[i] == b[j] and a[j] == b[i]\n            elif len(diff) == 4:\n                i, j, k, l = diff\n                # Check all possible pairings of swaps\n                # Pair 1: swap i<->j and k<->l\n                if (a[i] == b[j] and a[j] == b[i] and a[k] == b[l] and a[l] == b[k]):\n                    return True\n                # Pair 2: swap i<->k and j<->l\n                if (a[i] == b[k] and a[k] == b[i] and a[j] == b[l] and a[l] == b[j]):\n                    return True\n                # Pair 3: swap i<->l and j<->k\n                if (a[i] == b[l] and a[l] == b[i] and a[j] == b[k] and a[k] == b[j]):\n                    return True\n                return False\n            else:\n                return False\n\n        groups = defaultdict(list)\n        for num in nums:\n            s = str(num)\n            key = tuple(sorted(s))\n            groups[key].append(s)\n        total = 0\n        for group in groups.values():\n            n = len(group)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    a = group[i]\n                    b = group[j]\n                    if can_be_equal(a, b):\n                        total += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            n = len(num_str)\n            # Add the original number\n            variants.add(num_str)\n            # Generate all single swap variants\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all two swap variants\n            for i in range(n):\n                for j in range(i + 1, n):\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if i == k or i == l or j == k or j == l:\n                                continue\n                            swapped = list(num_str)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            # Count how many of these variants are already in the map\n            for v in variants:\n                total += count_map.get(v, 0)\n            # Update the count_map with the current number's string\n            count_map[num_str] += 1\n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            sorted_digits = tuple(sorted(str(num)))\n            total += count_map.get(sorted_digits, 0)\n            count_map[sorted_digits] += 1\n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_transformations(num_str):\n            transformations = set()\n            n = len(num_str)\n            # Add the original number\n            transformations.add(num_str)\n            # Generate all single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    transformations.add(''.join(swapped))\n            # Generate all double swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if i == k or i == l or j == k or j == l:\n                                continue\n                            swapped = list(num_str)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            transformations.add(''.join(swapped))\n            return transformations\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            transformations = generate_transformations(num_str)\n            # Add the count of existing transformations\n            for t in transformations:\n                total += count_map.get(t, 0)\n            # Update the count_map with current transformations\n            for t in transformations:\n                count_map[t] += 1\n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            variants.add(num_str)\n            n = len(num_str)\n            # Generate all possible 1-swap variants\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible 2-swap variants\n            for i in range(n):\n                for j in range(i+1, n):\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if i == k or i == l or j == k or j == l:\n                                continue\n                            swapped = list(num_str)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            # Check how many of these variants are already in the count_map\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Update the count_map with the current num_str (original)\n            count_map[num_str] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            # Convert the number to a sorted tuple of its digits\n            key = tuple(sorted(str(num)))\n            # Add the current count of this key to the total\n            total += count_map[key]\n            # Increment the count for this key\n            count_map[key] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\ndef generate_variants(num_str: str) -> set:\n    n = len(num_str)\n    variants = set()\n    # Generate all possible single swaps\n    for i in range(n):\n        for j in range(i+1, n):\n            swapped = list(num_str)\n            swapped[i], swapped[j] = swapped[j], swapped[i]\n            variants.add(''.join(swapped))\n    # Generate all possible two swaps\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(n):\n                for l in range(k+1, n):\n                # Ensure that the two swaps are independent\n                # If i and j are the same as k and l, it's a single swap, which is already considered\n                # So we need to avoid adding duplicates\n                # To avoid duplicates, we can enforce that the first swap is before the second in some order\n                # For simplicity, we can generate all possible two swaps and then add them to the set, which will handle duplicates automatically\n                # However, this may be computationally expensive for longer numbers\n                # Alternatively, we can generate all possible two swaps without considering order, but it's more complex\n                # For the sake of correctness, we'll proceed with generating all possible two swaps, even if it's a bit slow\n                # Note: This approach may not be efficient for very long numbers, but given the constraints (nums[i] < 1e7), the maximum length is 7 digits, which is manageable\n                # So, for each possible pair of swaps, generate the swapped string\n                # But wait, swapping i and j, then k and l may result in the same as swapping k and l then i and j\n                # So to avoid generating duplicates, perhaps we can enforce that the first swap is before the second in some way\n                # Alternatively, since we're using a set, duplicates will be automatically handled\n                # So, let's proceed\n                # Create a copy of the original string\n                swapped = list(num_str)\n                # Perform the first swap\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                # Perform the second swap\n                swapped[k], swapped[l] = swapped[l], swapped[k]\n                variants.add(''.join(swapped))\n    # Also include the original number as a variant (no swaps)\n    variants.add(num_str)\n    return variants\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Convert each number to its string representation\n        str_nums = [str(num) for num in nums]\n        # For each number, generate all possible variants after 0, 1, or 2 swaps\n        # We'll use a dictionary to count how many times each variant appears\n        variant_counts = defaultdict(int)\n        total_pairs = 0\n        for num_str in str_nums:\n            # Generate all possible variants for this number\n            variants = generate_variants(num_str)\n            # For each variant, add the current count to the total\n            for variant in variants:\n                total_pairs += variant_counts[variant]\n            # Increment the counts for all variants of this number\n            for variant in variants:\n                variant_counts[variant] += 1\n        return total_pairs",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            s = str(num)\n            key = (len(s), tuple(sorted(s)))\n            total += count_map[key]\n            count_map[key] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            s = str(num)\n            n = len(s)\n            # Generate all possible numbers by swapping any two digits (including zero swaps)\n            # We can represent each possible transformation as a sorted tuple of digits\n            # However, since two swaps can lead to any permutation, we need a different approach\n            # Instead, we can consider all possible pairs of digits and swap them, then sort the digits\n            # But this is computationally expensive. Instead, we can find the minimal representation\n            # by considering all possible two-swap transformations and their sorted forms\n            # However, this is still complex. A better approach is to note that two swaps can generate\n            # any permutation, so the initial approach was incorrect. Instead, we need to find a way to\n            # represent numbers that can be transformed into each other with at most two swaps.\n            # This is equivalent to the numbers having the same multiset of digits, except for two digits\n            # being swapped. Therefore, for each number, we can generate all possible numbers by swapping\n            # any two digits, and check if any of these exist in the array.\n            # However, this is O(n^2) for each number, which is not feasible for n=5000.\n            # Instead, we can precompute a key that represents the number's digits, allowing for two swaps.\n            # One way is to sort the digits and then consider all possible two-digit swaps in the sorted list.\n            # For example, for digits [a, b, c, d], sorted as [a, b, c, d], swapping any two gives a new sorted list.\n            # But this approach is not straightforward.\n            # An alternative approach is to realize that two swaps can generate any permutation, so the initial approach was incorrect.\n            # Therefore, the correct way is to count pairs where the two numbers have the same multiset of digits, but this is not the case.\n            # Wait, no. The problem allows two swaps, which is not the same as any permutation. For example, a number with four digits can be transformed into any permutation with two swaps? No, because each swap can fix two elements.\n            # For example, to sort four elements, you might need more than two swaps.\n            # Therefore, the initial approach was incorrect because it assumed that any permutation is allowed, but in reality, only two swaps are allowed.\n            # Thus, the correct approach is to find for each number, all numbers in the array that can be transformed into it with at most two swaps.\n            # This requires checking for each pair whether they can be transformed into each other with at most two swaps.\n            # However, this is O(n^2), which is 25 million operations for n=5000, which is manageable.\n            # Therefore, we can precompute for each number its sorted digits, and then for each pair, check if they can be transformed into each other with at most two swaps.\n            # To do this, we can compare the two numbers' digits and count the number of positions where they differ. If the count is 0, they are the same. If the count is 2, they can be swapped once. If the count is 4, they can be swapped twice. Otherwise, it's not possible.\n            # Wait, no. For example, if two numbers have four differing digits, but swapping two pairs can make them equal. For example, 1234 and 2143: swapping 1 and 2, and 3 and 4 gives equality. So the number of differing positions is 4, and two swaps are needed.\n            # Similarly, if two numbers have two differing positions, one swap is needed.\n            # If they have zero differing positions, zero swaps are needed.\n            # If they have one differing position, it's impossible with two swaps.\n            # If they have three differing positions, it's impossible with two swaps.\n            # If they have four differing positions, two swaps are needed.\n            # So, for two numbers to be almost equal, the number of differing digits must be 0, 2, or 4.\n            # Therefore, the approach is:\n            # 1. For each number, convert it to a string and sort the digits to get a key.\n            # 2. For each pair of numbers with the same key, check if they can be transformed into each other with at most two swaps.\n            # 3. Count such pairs.\n            # However, this is still O(n^2), which is manageable for n=5000.\n            # Alternatively, we can precompute for each number a list of all possible numbers that can be formed by swapping any two digits, and then check if any of these exist in the array.\n            # But this is also O(n^2) in the worst case.\n            # Therefore, the correct approach is to:\n            # - For each number, generate all possible numbers that can be formed by swapping any two digits (including zero swaps), and check if any of these exist in the array.\n            # But this is computationally expensive for large n.\n            # Instead, we can precompute a frequency map of the numbers, and for each number, generate all possible two-swap variants and check their presence in the map.\n            # However, generating all two-swap variants for a number with d digits is O(d^2) per number, which is manageable since d is up to 7 digits.\n            # Therefore, the plan is:\n            # 1. Convert each number to a string and store them in a list.\n            # 2. Create a frequency map (dictionary) that counts occurrences of each string.\n            # 3. For each number, generate all possible strings that can be formed by swapping any two digits (including zero swaps), and for each generated string, if it exists in the frequency map, add the count to the total.\n            # 4. However, this will count each pair twice (i,j and j,i), so we need to divide the total by 2 at the end.\n            # 5. Also, we need to handle the case where a number can be transformed into itself (zero swaps), which would add the count of that number minus one (to avoid counting the same number as a pair with itself).\n            # But wait, the problem requires i < j, so we need to count each pair only once.\n            # Therefore, the steps are:\n            # a. Precompute the frequency map.\n            # b. For each number in the list, generate all possible two-swap variants (including the number itself).\n            # c. For each variant, if it exists in the frequency map, add the frequency count to a temporary total.\n            # d. After processing all variants for a number, subtract 1 if the number itself is in the variants (to avoid counting the same number as a pair with itself).\n            # e. Add this temporary total to the overall total.\n            # f. Finally, divide the total by 2 to avoid double-counting pairs.\n            # However, this approach may still have issues, such as counting the same pair multiple times if multiple variants match.\n            # Therefore, a better approach is to iterate through all pairs and check if they can be transformed into each other with at most two swaps.\n            # This is O(n^2), which for n=5000 is 25 million operations, which is manageable.\n            # So, the plan is:\n            # 1. Convert all numbers to strings.\n            # 2. For each pair (i,j) where i < j, check if the two strings can be transformed into each other with at most two swaps.\n            # 3. Count the number of such pairs.\n            # To implement the check efficiently:\n            # a. Compare the two strings. If they are identical, they are almost equal (zero swaps needed).\n            # b. Otherwise, find all positions where the digits differ.\n            # c. If the number of differing positions is 2, then one swap is needed.\n            # d. If the number of differing positions is 4, check if swapping the two pairs makes them equal.\n            # e. If the number of differing positions is 0, 2, or 4, then they are almost equal.\n            # f. Otherwise, they are not.\n            # Therefore, the code will:\n            # - For each pair, compare the two strings.\n            # - Count the number of differing positions.\n            # - If the count is 0, 2, or 4, and the differing digits can be paired to form the other number, then it's a valid pair.\n            # Implementing this requires writing a helper function to check if two strings are almost equal.\n            # Let's write this helper function.\n            # Helper function:\n            def is_almost_equal(s1, s2):\n                if len(s1) != len(s2):\n                    return False\n                diff = []\n                for a, b in zip(s1, s2):\n                    if a != b:\n                        diff.append((a, b))\n                if len(diff) == 0:\n                    return True\n                if len(diff) == 2:\n                    # Check if swapping the two differing positions makes them equal\n                    return diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]\n                if len(diff) == 4:\n                    # Check if the four differing positions can be paired into two swaps\n                    # For example, positions 0 and 1 differ, and positions 2 and 3 differ, and swapping 0<->2 and 1<->3 makes them equal.\n                    # Or, positions 0 and 1 differ, and positions 0 and 2 differ, etc.\n                    # This is more complex. We need to check all possible pairings of the four differing positions into two swaps.\n                    # Alternatively, we can check if the multiset of characters in s1 is the same as in s2, and the number of differing positions is 4.\n                    # Because if the multiset is the same, then two swaps can make them equal.\n                    # Wait, no. For example, s1 = '1234', s2 = '2143'. The multiset is the same, and the number of differing positions is 4. Swapping 1 and 2, and 3 and 4 makes them equal.\n                    # Another example: s1 = '1234', s2 = '1324'. The number of differing positions is 2, which is handled by the earlier condition.\n                    # So, for len(diff) ==4, we need to check if the multiset of s1 is the same as s2, and that the differing positions can be paired into two swaps.\n                    # But checking the multiset is the same is necessary, but not sufficient. For example, s1 = '1234', s2 = '1243'. The multiset is the same, but the number of differing positions is 2, which is handled earlier.\n                    # Wait, no. In this case, the number of differing positions is 2, so it's handled by the len(diff) ==2 condition.\n                    # So, for len(diff) ==4, we need to check if the multiset is the same, and that the four differing positions can be paired into two swaps.\n                    # But how to implement this efficiently?\n                    # One approach is to check if the multiset of s1 is the same as s2, and that the number of differing positions is 4.\n                    # Because if the multiset is the same and the number of differing positions is 4, then two swaps can make them equal.\n                    # For example, s1 = '1234', s2 = '2143' \u2192 multiset same, differing positions 4 \u2192 two swaps.\n                    # Another example: s1 = '1234', s2 = '2314' \u2192 multiset same, differing positions 2 \u2192 one swap.\n                    # So, the condition for len(diff) ==4 is that the multiset is the same.\n                    # Therefore, in the helper function:\n                    # If len(diff) ==4, check if sorted(s1) == sorted(s2). If yes, return True.\n                    # Else, return False.\n                    return sorted(s1) == sorted(s2)\n                return False\n            # Now, using this helper function, we can iterate through all pairs and count.\n            # However, for n=5000, this is O(n^2) = 25 million operations, which is manageable.\n            # But wait, the helper function for len(diff) ==4 requires sorting the strings, which is O(d log d) where d is the number of digits (up to 7). For 25 million pairs, this is acceptable.\n            # Therefore, the code will:\n            # - Convert all numbers to strings.\n            # - For each pair (i,j) where i < j, check if is_almost_equal(s_i, s_j).\n            # - Count the number of such pairs.\n            # Implementing this:\n            # Convert nums to strings\n            str_nums = list(map(str, nums))\n            total = 0\n            n = len(str_nums)\n            for i in range(n):\n                for j in range(i+1, n):\n                    if is_almost_equal(str_nums[i], str_nums[j]):\n                        total +=1\n            return total\n        # However, this approach may be too slow for n=5000, as 25 million iterations can be time-consuming in Python.\n        # Therefore, we need a more efficient approach.\n        # Let's think about precomputing a key for each number that allows us to group numbers that can be transformed into each other with at most two swaps.\n        # One possible key is the sorted tuple of digits, but as we saw earlier, this is not sufficient because two swaps may not allow all permutations.\n        # Wait, no. The sorted tuple would group all numbers that have the same multiset of digits, which is necessary but not sufficient for being almost equal with two swaps.\n        # Because, for example, two numbers with the same multiset but requiring more than two swaps to transform into each other would be in the same group but not almost equal.\n        # Therefore, the sorted tuple is a necessary condition but not sufficient.\n        # So, we can first group numbers by their sorted tuple, and then within each group, count the number of pairs that can be transformed into each other with at most two swaps.\n        # This reduces the problem to, for each group, count the number of pairs (i,j) where i < j and is_almost_equal(s_i, s_j).\n        # This is better because groups with different sorted tuples can be ignored, and we only process pairs within the same group.\n        # For example, in the first test case, all numbers have the same sorted tuple, so we process all pairs within this group.\n        # In the second test case, the numbers 1, 10, 100 have sorted tuples '1', '01', '001' respectively, which are different, so they are in different groups. However, the helper function would still count them as almost equal because they can be transformed with two swaps.\n        # Wait, no. For example, 1 (str '1') and 10 (str '10') have different lengths, so their sorted tuples are different. Therefore, they would not be in the same group, and the helper function would not count them as almost equal, which is incorrect because according to the problem statement, leading zeros are allowed after swaps.\n        # Wait, the problem statement says that leading zeros are allowed after performing the operations. So, when comparing two numbers, their string representations may have different lengths if leading zeros are added or removed.\n        # For example, 1 can be transformed into 01 (which is 10) by adding a leading zero and swapping digits.\n        # Wait, but the initial number is 1, which is '1'. To transform it into '10', which is 10, you need to add a zero and swap, but the problem allows swapping any two digits within the number. So, for '1', you can't add a zero; you can only swap existing digits. Therefore, '1' can't be transformed into '10' because '1' has only one digit, and '10' has two digits. So, the helper function correctly returns False for these two.\n        # But according to the problem statement, leading zeros are allowed after performing the operations. So, when comparing two numbers, their string representations may have leading zeros, but the actual numbers are considered equal if their digit multisets are the same, including leading zeros.\n        # Wait, no. The problem statement says that after performing the operations, the numbers can have leading zeros, but the numbers themselves are compared as integers. So, for example, 1023 can be transformed into 0213, which is 213 as an integer. So, when comparing two numbers, their string representations (with leading zeros) must be considered.\n        # Therefore, the helper function should compare the string representations, including leading zeros, but the numbers are treated as strings, not integers.\n        # Therefore, the initial approach of comparing the string representations is correct.\n        # However, the problem is that numbers with different lengths cannot be almost equal, because you can't change the number of digits by swapping. For example, 1 (length 1) and 10 (length 2) cannot be almost equal because you can't add or remove digits by swapping.\n        # Therefore, in the helper function, if the lengths of the two strings are different, return False.\n        # So, the helper function is correct in checking len(s1) == len(s2).\n        # Therefore, the approach of grouping by sorted tuples is not sufficient because two numbers with the same sorted tuple may require more than two swaps to transform into each other",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_signatures(num):\n            s = str(num)\n            n = len(s)\n            signatures = set()\n            # 0 swaps: the number itself\n            signatures.add(tuple(s))\n            # 1 swap: swap any two digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    signatures.add(tuple(swapped))\n            # 2 swaps: swap two pairs of digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if i == k or i == l or j == k or j == l:\n                                continue\n                            swapped = list(s)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            signatures.add(tuple(swapped))\n            return signatures\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            signatures = generate_signatures(num)\n            for sig in signatures:\n                total += count_map.get(sig, 0)\n            for sig in signatures:\n                count_map[sig] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_signatures(num):\n            s = list(str(num))\n            n = len(s)\n            signatures = set()\n            # Add the original number\n            signatures.add(tuple(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    signatures.add(tuple(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if k == i or k == j or l == i or l == j:\n                                continue\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            signatures.add(tuple(swapped2))\n            return signatures\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            signatures = generate_signatures(num)\n            for sig in signatures:\n                total += count_map.get(sig, 0)\n            for sig in signatures:\n                count_map[sig] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_signatures(num):\n            s = list(str(num))\n            n = len(s)\n            signatures = set()\n            # Add the original number\n            signatures.add(tuple(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    signatures.add(tuple(swapped))\n            # Generate all possible two swaps, including overlapping\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(n):\n                            if k == l:\n                                continue\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            signatures.add(tuple(swapped2))\n            return signatures\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            signatures = generate_signatures(num)\n            for sig in signatures:\n                total += count_map.get(sig, 0)\n            for sig in signatures:\n                count_map[sig] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_signature(num):\n            s = list(str(num))\n            s_sorted = sorted(s)\n            return tuple(s_sorted)\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            sig = get_signature(num)\n            total += count_map.get(sig, 0)\n            count_map[sig] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_signature(num):\n            s = list(str(num))\n            s.sort()\n            return tuple(s)\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            sig = get_signature(num)\n            total += count_map[sig]\n            count_map[sig] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            # Convert the number to a sorted tuple of its digits\n            sig = tuple(sorted(str(num)))\n            # Add the count of this signature to the total\n            total += count_map.get(sig, 0)\n            # Increment the count for this signature\n            count_map[sig] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            variants.add(num_str)\n            n = len(num_str)\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped = list(num_str)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            # Check how many of these variants are already in the map\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Update the count_map with the current number's variants\n            for var in variants:\n                count_map[var] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        max_len = max(len(str(num)) for num in nums)\n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num).zfill(max_len)\n            sig = tuple(sorted(s))\n            total += count_map.get(sig, 0)\n            count_map[sig] += 1\n        \n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swaps(num_str):\n            swaps = set()\n            swaps.add(num_str)\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i+1, n):\n                    # Swap i and j\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    swapped_str = ''.join(swapped)\n                    swaps.add(swapped_str)\n                    # Apply another swap\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            swapped2_str = ''.join(swapped2)\n                            swaps.add(swapped2_str)\n            return swaps\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            # Generate all possible numbers after 0, 1, or 2 swaps\n            possible = generate_swaps(num_str)\n            # For each possible, check how many times it has been seen before\n            for p in possible:\n                total += count_map.get(p, 0)\n            # Update the count_map with the current num_str\n            count_map[num_str] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            s = str(num)\n            signature = tuple(sorted(s))\n            total += count_map[signature]\n            count_map[signature] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(s):\n            variants = set()\n            n = len(s)\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    # Generate all possible double swaps\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if k == i or k == j or l == i or l == j:\n                                continue\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            s = str(num)\n            variants = generate_variants(s)\n            # Check how many of these variants are already in the map\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Increment the count for the original string\n            count_map[s] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            s = str(num)\n            signatures = set()\n            # Signature 1: sorted digits (covers any number of swaps)\n            signatures.add(tuple(sorted(s)))\n            # Signature 2: all possible single swaps\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    signatures.add(tuple(swapped))\n            # Signature 3: all possible two swaps (non-overlapping)\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    for k in range(j + 1, len(s)):\n                        for l in range(k + 1, len(s)):\n                            swapped = list(s)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            signatures.add(tuple(swapped))\n            # Add all signatures to the count_map\n            for sig in signatures:\n                total += count_map.get(sig, 0)\n            # Update count_map with the current number's signatures\n            for sig in signatures:\n                count_map[sig] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_key(num):\n            s = str(num)\n            return tuple(sorted(s))\n        \n        def generate_swaps(s):\n            s_list = list(s)\n            n = len(s_list)\n            swaps = set()\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    swaps.add(''.join(s_list))\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            return swaps\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            key = get_key(num)\n            res += count.get(key, 0)\n            \n            for swap1 in generate_swaps(s):\n                key1 = get_key(int(swap1))\n                res += count.get(key1, 0)\n                \n                swaps2 = generate_swaps(swap1)\n                for swap2 in swaps2:\n                    key2 = get_key(int(swap2))\n                    res += count.get(key2, 0)\n            \n            count[key] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_all_swaps(s):\n            s_list = list(s)\n            n = len(s_list)\n            swaps = set()\n            swaps.add(''.join(s_list))  # include the original string\n            \n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    swaps.add(''.join(s_list))\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            # Generate all possible double swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if k != i and k != j and l != i and l != j:\n                                s_list[k], s_list[l] = s_list[l], s_list[k]\n                                swaps.add(''.join(s_list))\n                                s_list[k], s_list[l] = s_list[l], s_list[k]\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            return swaps\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            variations = generate_all_swaps(s)\n            \n            # Count how many existing variations match\n            for var in variations:\n                res += count.get(var, 0)\n            \n            # Update the count for the current number's variations\n            for var in variations:\n                count[var] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(s):\n            variations = set()\n            s_list = list(s)\n            n = len(s_list)\n            \n            # Add the original string\n            variations.add(''.join(s_list))\n            \n            # Generate all single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    variations.add(''.join(s_list))\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            # Generate all double swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    # Swap i and j\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    # Now perform another swap\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                            variations.add(''.join(s_list))\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                    # Swap back i and j\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            return variations\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            variations = generate_variations(s)\n            \n            # Add the count of existing variations to the result\n            for var in variations:\n                res += count.get(var, 0)\n            \n            # Update the count for each variation\n            for var in variations:\n                count[var] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(s):\n            s_list = list(s)\n            n = len(s_list)\n            variations = set()\n            variations.add(''.join(s_list))\n            \n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    variations.add(''.join(s_list))\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            # Generate all possible double swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                            variations.add(''.join(s_list))\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            return variations\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            variations = generate_variations(s)\n            \n            # Count how many existing variations match\n            for var in variations:\n                res += count.get(var, 0)\n            \n            # Update the count for the current number's variations\n            for var in variations:\n                count[var] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_key(num):\n            s = str(num)\n            return ''.join(sorted(s))\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            key = get_key(num)\n            res += count[key]\n            count[key] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_all_transformations(s):\n            n = len(s)\n            transformations = set()\n            transformations.add(s)\n            # Generate all possible one-swap transformations\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list = list(s)\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    transformed = ''.join(s_list)\n                    transformations.add(transformed)\n            # Generate all possible two-swap transformations\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list = list(s)\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if k == i and l == j:\n                                continue\n                            s_list2 = s_list.copy()\n                            s_list2[k], s_list2[l] = s_list2[l], s_list2[k]\n                            transformed = ''.join(s_list2)\n                            transformations.add(transformed)\n            return transformations\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            # Collect all possible transformations including the original\n            transformations = generate_all_transformations(s)\n            # For each transformation, check how many times it has been seen before\n            for t in transformations:\n                res += count.get(t, 0)\n            # Increment the count for the original number's key\n            count[s] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            # Create a key by sorting the digits\n            key = tuple(sorted(s))\n            # Add the count of this key to the result\n            res += count.get(key, 0)\n            # Increment the count for this key\n            count[key] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_key(s):\n            digits = list(s)\n            keys = set()\n            keys.add(tuple(digits))\n            # Generate all single swaps\n            for i in range(len(digits)):\n                for j in range(i + 1, len(digits)):\n                    swapped = digits.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    keys.add(tuple(swapped))\n            # Generate all double swaps\n            for i in range(len(digits)):\n                for j in range(i + 1, len(digits)):\n                    swapped1 = digits.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(len(swapped1)):\n                        for l in range(k + 1, len(swapped1)):\n                            if k == i and l == j:\n                                continue\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            keys.add(tuple(swapped2))\n            return keys\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            keys = get_key(s)\n            for key in keys:\n                res += count.get(tuple(key), 0)\n            count[tuple(s)] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_transformations(s):\n            n = len(s)\n            transformations = set()\n            # Generate all possible one-swap transformations\n            for i in range(n):\n                for j in range(i + 1, n):\n                    s_list = list(s)\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    transformed = ''.join(s_list)\n                    transformations.add(transformed)\n            # Generate all possible two-swap transformations\n            for i in range(n):\n                for j in range(i + 1, n):\n                    s_list = list(s)\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if k == i and l == j:\n                                continue\n                            s_list2 = s_list.copy()\n                            s_list2[k], s_list2[l] = s_list2[l], s_list2[k]\n                            transformed = ''.join(s_list2)\n                            transformations.add(transformed)\n            # Include the original string\n            transformations.add(s)\n            return transformations\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            transformations = generate_transformations(s)\n            # Add the count of each transformation seen so far\n            for t in transformations:\n                res += count.get(t, 0)\n            # Update the count for each transformation\n            for t in transformations:\n                count[t] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_all_swaps(s):\n            s_list = list(s)\n            n = len(s_list)\n            seen = set()\n            seen.add(''.join(s_list))\n            \n            # First swap\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    seen.add(''.join(s_list))\n                    # Second swap\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                            seen.add(''.join(s_list))\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            return seen\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            swaps = generate_all_swaps(s)\n            # Convert each swap to a sorted tuple key\n            keys = set()\n            for swap in swaps:\n                keys.add(tuple(sorted(swap)))\n            # Add the count of all existing keys\n            for key in keys:\n                res += count.get(key, 0)\n            # Update the count with the current number's sorted tuple\n            current_key = tuple(sorted(s))\n            count[current_key] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(s):\n            variants = set()\n            n = len(s)\n            # Add the original string\n            variants.add(s)\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list = list(s)\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    variants.add(''.join(s_list))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list = list(s)\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    # Now perform a second swap on the modified s_list\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            s_list2 = s_list.copy()\n                            s_list2[k], s_list2[l] = s_list2[l], s_list2[k]\n                            variants.add(''.join(s_list2))\n            return variants\n        \n        count_map = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(s)\n            # For each variant, check how many times it has been seen before\n            for var in variants:\n                result += count_map.get(var, 0)\n            # Update the count_map with the current number's variants\n            for var in variants:\n                count_map[var] += 1\n        \n        return result",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_permutations(s):\n            seen = set()\n            n = len(s)\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    s_list = list(s)\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    perm1 = ''.join(s_list)\n                    seen.add(perm1)\n                    for k in range(n):\n                        for l in range(n):\n                            if k == l:\n                                continue\n                            s_list2 = list(s_list)\n                            s_list2[k], s_list2[l] = s_list2[l], s_list2[k]\n                            perm2 = ''.join(s_list2)\n                            seen.add(perm2)\n            return seen\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            perms = generate_permutations(s)\n            # Convert each permutation to a key\n            keys = set()\n            for perm in perms:\n                keys.add(perm)\n            # Add the count of all existing keys\n            for key in keys:\n                res += count.get(key, 0)\n            # Update the count with the current number's permutations\n            for perm in perms:\n                count[perm] += 1\n        \n        return res",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swaps(s):\n            s_list = list(s)\n            n = len(s_list)\n            seen = set()\n            seen.add(''.join(s_list))\n            \n            # Generate all possible numbers after one swap\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    seen.add(''.join(s_list))\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            # Generate all possible numbers after two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                            seen.add(''.join(s_list))\n                            s_list[k], s_list[l] = s_list[l], s_list[k]\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            \n            return seen\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            swaps = generate_swaps(s)\n            # Convert each swap to a string key\n            keys = set()\n            for swap in swaps:\n                keys.add(swap)\n            # Add the count of all existing keys\n            for key in keys:\n                res += count.get(key, 0)\n            # Update the count with the current number's variations\n            for key in keys:\n                count[key] += 1\n        \n        return res"
  ],
  "total_candidates": 37,
  "nodes_explored": 37,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            n = len(num_str)\n            # Generate all possible variants with 0, 1, or 2 swaps\n            # 0 swaps: original\n            variants.add(num_str)\n            # 1 swap: swap any two digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # 2 swaps: swap two pairs of digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if i == k or i == l or j == k or j == l:\n                                continue\n                            swapped = list(num_str)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            # Add the current count of each variant to the total\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Increment the count for each variant\n            for var in variants:\n                count_map[var] += 1\n        return total",
      "solution_hash": "296cfb8fade4da5a2643c34714722c3086d1a2983281f52a5bbdf39ff3b6e2d3",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmplnb0r4k3.py\", line 261, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242033/tmplnb0r4k3.py\", line 125, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmplnb0r4k3.py` failed. (See above for error)\n",
        "execution_time": 13.210874319076538,
        "failed_tests": [
          {
            "input": "nums = [123, 321, 213, 132]",
            "expected": "6",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmplnb0r4k3.py\", line 261, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242033/tmplnb0r4k3.py\", line 125, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmplnb0r4k3.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_8"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_signatures(num):\n            s = str(num)\n            n = len(s)\n            signatures = set()\n            # 0 swaps: the number itself\n            signatures.add(tuple(s))\n            # 1 swap: swap any two digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    signatures.add(tuple(swapped))\n            # 2 swaps: swap two pairs of digits\n            for i in range(n):\n                for j in range(i+1, n):\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if i == k or i == l or j == k or j == l:\n                                continue\n                            swapped = list(s)\n                            swapped[i], swapped[j] = swapped[j], swapped[i]\n                            swapped[k], swapped[l] = swapped[l], swapped[k]\n                            signatures.add(tuple(swapped))\n            return signatures\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            signatures = generate_signatures(num)\n            for sig in signatures:\n                total += count_map.get(sig, 0)\n            for sig in signatures:\n                count_map[sig] += 1\n        return total",
      "solution_hash": "29fda0dbdaf8b8dcd570f315c8e0babe4334f8fe8f037541d6431123e131160b",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmpz9p2rkv7.py\", line 259, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242033/tmpz9p2rkv7.py\", line 123, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmpz9p2rkv7.py` failed. (See above for error)\n",
        "execution_time": 13.133737087249756,
        "failed_tests": [
          {
            "input": "nums = [123, 321, 213, 132]",
            "expected": "6",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmpz9p2rkv7.py\", line 259, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242033/tmpz9p2rkv7.py\", line 123, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmpz9p2rkv7.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_13",
        "1_17",
        "1_21"
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_key(num):\n            s = str(num)\n            return tuple(sorted(s))\n        \n        def generate_swaps(s):\n            s_list = list(s)\n            n = len(s_list)\n            swaps = set()\n            for i in range(n):\n                for j in range(i+1, n):\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n                    swaps.add(''.join(s_list))\n                    s_list[i], s_list[j] = s_list[j], s_list[i]\n            return swaps\n        \n        count = defaultdict(int)\n        res = 0\n        \n        for num in nums:\n            s = str(num)\n            key = get_key(num)\n            res += count.get(key, 0)\n            \n            for swap1 in generate_swaps(s):\n                key1 = get_key(int(swap1))\n                res += count.get(key1, 0)\n                \n                swaps2 = generate_swaps(swap1)\n                for swap2 in swaps2:\n                    key2 = get_key(int(swap2))\n                    res += count.get(key2, 0)\n            \n            count[key] += 1\n        \n        return res",
      "solution_hash": "d2ecdd17c205cace5f27bf4aa275c7cb11ab6ed292ccb143e84f3dbd9e099683",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmp861fmm5h.py\", line 260, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242033/tmp861fmm5h.py\", line 124, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmp861fmm5h.py` failed. (See above for error)\n",
        "execution_time": 13.160022974014282,
        "failed_tests": [
          {
            "input": "nums = [123, 321, 213, 132]",
            "expected": "6",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmp861fmm5h.py\", line 260, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242033/tmp861fmm5h.py\", line 124, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmp861fmm5h.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_25",
        "1_29",
        "1_33"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 37,
    "candidates_generated": 37,
    "tests_passed": 0,
    "tests_failed": 37,
    "test_timeouts": 0,
    "test_errors": 0,
    "import_errors": 0,
    "import_terminated_branches": 0,
    "unique_import_failures": [],
    "execution_times": [
      13.210874319076538,
      13.188606262207031,
      13.167619705200195,
      13.156034708023071,
      13.169626474380493,
      13.189808130264282,
      13.183083534240723,
      13.167621612548828,
      13.164098978042603,
      13.178953647613525,
      13.196838617324829,
      13.14950966835022,
      13.133737087249756,
      13.160912036895752,
      13.166285991668701,
      13.159287214279175,
      13.17407488822937,
      13.182796716690063,
      13.470856428146362,
      13.145008563995361,
      13.190102815628052,
      13.155828475952148,
      13.300267457962036,
      13.150838851928711,
      13.160022974014282,
      13.16935110092163,
      13.132724046707153,
      13.1428964138031,
      13.159494400024414,
      13.166048288345337,
      13.162590026855469,
      13.149967908859253,
      13.122882604598999,
      13.1581449508667,
      13.132615327835083,
      13.09346079826355,
      13.108350276947021
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 37,
      "unique_ratio": 1.0,
      "similarity_score": 0.7854349293229251,
      "solution_lengths": {
        "min": 344,
        "max": 17330,
        "avg": 1724.3513513513512
      },
      "algorithm_approaches": {
        "greedy": 1,
        "backtracking": 1,
        "hash_table": 35
      },
      "feature_diversity": 1.0,
      "features_analysis": {
        "boolean_features": {
          "has_recursion": {
            "true_ratio": 1.0,
            "count": 37
          },
          "uses_list": {
            "true_ratio": 0.7567567567567568,
            "count": 28
          },
          "uses_dict": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_set": {
            "true_ratio": 0.6486486486486487,
            "count": 24
          },
          "uses_heap": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_queue": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_stack": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dp": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_bfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_binary_search": {
            "true_ratio": 0.0,
            "count": 0
          },
          "nested_loops": {
            "true_ratio": 0.7297297297297297,
            "count": 27
          }
        },
        "numeric_features": {
          "loop_count": {
            "min": 1,
            "max": 10,
            "avg": 6.0,
            "variance": 11.945945945945946
          },
          "if_count": {
            "min": 0,
            "max": 9,
            "avg": 0.8108108108108109,
            "variance": 3.01826150474799
          },
          "else_count": {
            "min": 0,
            "max": 1,
            "avg": 0.02702702702702703,
            "variance": 0.02629656683710736
          },
          "return_count": {
            "min": 1,
            "max": 10,
            "avg": 2.108108108108108,
            "variance": 2.4207450693937194
          },
          "assignment_count": {
            "min": 5,
            "max": 31,
            "avg": 13.27027027027027,
            "variance": 32.0891161431702
          },
          "class_method_count": {
            "min": 1,
            "max": 3,
            "avg": 1.7837837837837838,
            "variance": 0.2235208181154128
          },
          "line_count": {
            "min": 11,
            "max": 168,
            "avg": 37.83783783783784,
            "variance": 651.7034331628926
          },
          "char_count": {
            "min": 344,
            "max": 17330,
            "avg": 1724.3513513513512,
            "variance": 7171473.5252008755
          },
          "max_indent": {
            "min": 12,
            "max": 32,
            "avg": 23.89189189189189,
            "variance": 71.33966398831267
          }
        }
      },
      "complexity_diversity": {
        "complexity_distribution": {
          "exponential": 37
        },
        "avg_complexity_metrics": {
          "avg_line_count": 37.83783783783784,
          "avg_loop_count": 6.0,
          "avg_condition_count": 0.8648648648648649,
          "avg_method_count": 1.7837837837837838,
          "avg_assignment_count": 13.27027027027027,
          "avg_max_loop_nesting": 1.027027027027027
        },
        "complexity_diversity_ratio": 0.16666666666666666
      }
    },
    "test_case_analysis": {
      "hardest_cases": {
        "nums = [123, 321, 213, 132]": 21,
        "nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]": 12,
        "nums = [11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 202, 303, 404, 505, 606, 707, 808, 909]": 3
      },
      "first_failing_tests": {
        "nums = [123, 321, 213, 132]": 21,
        "nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]": 12,
        "nums = [11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 202, 303, 404, 505, 606, 707, 808, 909]": 3
      }
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 9,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 25,
          "improvements": 1,
          "solved": 0
        }
      },
      "error_types": {
        "assertion_failure": {
          "attempts": 12,
          "improvements": 1
        }
      },
      "test_case_improvements": {
        "nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]": 1
      },
      "error_transitions": {
        "assertion_failure->assertion_failure": 33,
        "assertion_failure->other_error": 1
      }
    },
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.5945945945945945,
        "solutions_per_depth": {
          "0": 3,
          "1": 9,
          "2": 25
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.02631578947368418,
        "pass@3": 0.07894736842105265,
        "pass@5": 0.13157894736842102,
        "pass@10": 0.26315789473684204
      },
      "solutions_evaluated": 38
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0,
        "test_success_rate": 0.0
      },
      "test_results": {
        "total": 37,
        "passed": 0,
        "failed": 37,
        "timeouts": 0,
        "import_errors": 0,
        "other_errors": 0,
        "unique_import_failures": []
      },
      "error_recovery": {
        "total_attempts": 12,
        "total_improvements": 1,
        "recovery_rate": 0.08333333333333333
      },
      "top_errors": [
        [
          "assertion_failure",
          12
        ]
      ],
      "hardest_test_cases": [
        [
          "nums = [123, 321, 213, 132]",
          21
        ],
        [
          "nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]",
          12
        ],
        [
          "nums = [11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 202, 303, 404, 505, 606, 707, 808, 909]",
          3
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      }
    }
  },
  "processing_time": 3347.426997900009,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.02631578947368418,
      "pass@3": 0.07894736842105265,
      "pass@5": 0.13157894736842102,
      "pass@10": 0.26315789473684204
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: expected an indented block (<string>, line 127)",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 37
          }
        ]
      ]
    },
    "solutions_evaluated": 38,
    "test_cases": 1
  }
}