{
  "problem_id": "maximum-value-sum-by-placing-three-rooks-i",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Manually generate combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Manually generate permutations of 3 columns\n                    for c1 in range(n):\n                        for c2 in range(n):\n                            if c2 == c1:\n                                continue\n                            for c3 in range(n):\n                                if c3 == c1 or c3 == c2:\n                                    continue\n                                current_sum = board[i][c1] + board[j][c2] + board[k][c3]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values in each row and column\n        top_row_values = [heapq.nlargest(3, row) for row in board]\n        top_col_values = [heapq.nlargest(3, (board[i][j] for i in range(m))) for j in range(n)]\n        \n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for r1, r2, r3 in itertools.combinations(range(m), 3):\n            # Get the top 3 values from these rows\n            row_values = [top_row_values[r1], top_row_values[r2], top_row_values[r3]]\n            \n            # Iterate over all combinations of 3 columns\n            for c1, c2, c3 in itertools.combinations(range(n), 3):\n                # Get the top 3 values from these columns\n                col_values = [top_col_values[c1], top_col_values[c2], top_col_values[c3]]\n                \n                # Check all combinations of one value from each row and column\n                for v1 in row_values[0]:\n                    for v2 in row_values[1]:\n                        for v3 in row_values[2]:\n                            if v1 == board[r1][c1] and v2 == board[r2][c2] and v3 == board[r3][c3]:\n                                current_sum = v1 + v2 + v3\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Manually generate combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Manually generate permutations of 3 columns\n                    for c1 in range(n):\n                        for c2 in range(n):\n                            if c2 == c1:\n                                continue\n                            for c3 in range(n):\n                                if c3 == c1 or c3 == c2:\n                                    continue\n                                current_sum = board[i][c1] + board[j][c2] + board[k][c3]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values in each row and column\n        top_row_values = [heapq.nlargest(3, board[i]) for i in range(m)]\n        top_col_values = [heapq.nlargest(3, [board[j][i] for j in range(m)]) for i in range(n)]\n        \n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for r1 in range(m):\n            for r2 in range(r1 + 1, m):\n                for r3 in range(r2 + 1, m):\n                    # Get the top 3 values from these rows\n                    row_vals = [top_row_values[r1], top_row_values[r2], top_row_values[r3]]\n                    \n                    # Use sets to track columns already used\n                    used_cols = set()\n                    current_sum = 0\n                    \n                    # Try to pick the best column for each row\n                    for vals in row_vals:\n                        for val in vals:\n                            for c in range(n):\n                                if board[r1][c] == val or board[r2][c] == val or board[r3][c] == val:\n                                    if c not in used_cols:\n                                        current_sum += val\n                                        used_cols.add(c)\n                                        break\n                            \n                            if len(used_cols) == 3:\n                                break\n                        \n                        if len(used_cols) == 3:\n                            break\n                    \n                    if len(used_cols) == 3:\n                        max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Precompute the top 3 values in each row\n        top_values_in_rows = []\n        for row in board:\n            top_values = sorted(row, reverse=True)[:3]\n            top_indices = sorted(range(n), key=lambda x: -row[x])[:3]\n            top_values_in_rows.append(list(zip(top_indices, top_values)))\n        \n        # Iterate over all combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Get the top 3 values in each of the selected rows\n                    row1 = top_values_in_rows[i]\n                    row2 = top_values_in_rows[j]\n                    row3 = top_values_in_rows[k]\n                    \n                    # Try placing rooks in different columns from each row\n                    for col1, val1 in row1:\n                        for col2, val2 in row2:\n                            for col3, val3 in row3:\n                                if col1 != col2 and col2 != col3 and col1 != col3:\n                                    current_sum = val1 + val2 + val3\n                                    max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Iterate over all permutations of 3 columns\n                    for a in range(n):\n                        for b in range(a + 1, n):\n                            for c in range(b + 1, n):\n                                current_sum = board[i][a] + board[j][b] + board[k][c]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # For each row, find the top 3 values along with their column indices\n        top_values_per_row = []\n        for row in board:\n            # Get the top 3 values and their indices in the row\n            top_three = heapq.nlargest(3, enumerate(row), key=lambda x: x[1])\n            top_values_per_row.append(top_three)\n        \n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Use sets to track columns already used\n                    used_cols = set()\n                    current_sum = 0\n                    \n                    # Try to pick one value from each row ensuring no column is reused\n                    for col_i, val_i in top_values_per_row[i]:\n                        if col_i not in used_cols:\n                            used_cols.add(col_i)\n                            current_sum += val_i\n                            break\n                    else:\n                        continue  # If we couldn't add a value from row i, skip\n                    \n                    for col_j, val_j in top_values_per_row[j]:\n                        if col_j not in used_cols:\n                            used_cols.add(col_j)\n                            current_sum += val_j\n                            break\n                    else:\n                        continue  # If we couldn't add a value from row j, skip\n                    \n                    for col_k, val_k in top_values_per_row[k]:\n                        if col_k not in used_cols:\n                            used_cols.add(col_k)\n                            current_sum += val_k\n                            break\n                    else:\n                        continue  # If we couldn't add a value from row k, skip\n                    \n                    max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Calculate top 3 values in each row\n        top_row_values = []\n        for row in board:\n            top_row_values.append(sorted(row, reverse=True)[:3])\n        \n        # Calculate top 3 values in each column\n        top_col_values = [[] for _ in range(n)]\n        for col in range(n):\n            for row in range(m):\n                top_col_values[col].append(board[row][col])\n            top_col_values[col] = sorted(top_col_values[col], reverse=True)[:3]\n        \n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of top 3 values in rows and columns\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    for a in range(3):\n                        for b in range(3):\n                            for c in range(3):\n                                row_indices = [0, 1, 2]\n                                col_indices = [a, b, c]\n                                \n                                if len(set(col_indices)) == 3:\n                                    current_sum = top_row_values[0][i] + top_row_values[1][j] + top_row_values[2][k]\n                                    current_sum += top_col_values[a][0] + top_col_values[b][1] + top_col_values[c][2]\n                                    \n                                    # Adjust for double counting\n                                    current_sum -= (top_row_values[0][i] + top_row_values[1][j] + top_row_values[2][k]) // 3\n                                    \n                                    max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Find the top 3 values in each row\n        row_maxes = []\n        for row in board:\n            row_maxes.append(heapq.nlargest(3, row))\n        \n        # Find the top 3 values in each column\n        col_maxes = [[] for _ in range(n)]\n        for col in range(n):\n            for row in range(m):\n                col_maxes[col].append(board[row][col])\n            col_maxes[col] = heapq.nlargest(3, col_maxes[col])\n        \n        # Try placing rooks at the top 3 positions in each row and check column constraints\n        max_sum = float('-inf')\n        for i in range(m):\n            for j in range(m):\n                if i == j:\n                    continue\n                for k in range(m):\n                    if i == k or j == k:\n                        continue\n                    for a in range(3):\n                        for b in range(3):\n                            if a == b:\n                                continue\n                            for c in range(3):\n                                if a == c or b == c:\n                                    continue\n                                if row_maxes[i][a] in col_maxes[0] and row_maxes[j][b] in col_maxes[1] and row_maxes[k][c] in col_maxes[2]:\n                                    col_a = board[i].index(row_maxes[i][a])\n                                    col_b = board[j].index(row_maxes[j][b])\n                                    col_c = board[k].index(row_maxes[k][c])\n                                    if len(set([col_a, col_b, col_c])) == 3:\n                                        current_sum = row_maxes[i][a] + row_maxes[j][b] + row_maxes[k][c]\n                                        max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = [(i, j, board[i][j]) for i in range(m) for j in range(n)]\n        cells.sort(key=lambda x: -x[2])  # Sort cells by value in descending order\n        \n        max_sum = 0\n        used_rows = set()\n        used_cols = set()\n        selected_cells = []\n        \n        for i, j, value in cells:\n            if len(selected_cells) == 3:\n                break\n            if i not in used_rows and j not in used_cols:\n                selected_cells.append((i, j, value))\n                used_rows.add(i)\n                used_cols.add(j)\n        \n        # Calculate the sum of the selected cells\n        max_sum = sum(value for _, _, value in selected_cells)\n        \n        # Try different combinations of selecting 3 cells\n        for comb in combinations(cells, 3):\n            i1, j1, v1 = comb[0]\n            i2, j2, v2 = comb[1]\n            i3, j3, v3 = comb[2]\n            if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3:\n                max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = [(i, j, board[i][j]) for i in range(m) for j in range(n)]\n        cells.sort(key=lambda x: -x[2])  # Sort cells by value in descending order\n        \n        max_sum = 0\n        \n        # Try placing rooks in the top cells\n        for i in range(len(cells)):\n            for j in range(i + 1, len(cells)):\n                for k in range(j + 1, len(cells)):\n                    (r1, c1, v1) = cells[i]\n                    (r2, c2, v2) = cells[j]\n                    (r3, c3, v3) = cells[k]\n                    \n                    if len({r1, r2, r3}) == 3 and len({c1, c2, c3}) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values in each row and column\n        top_row_values = [heapq.nlargest(3, board[i]) for i in range(m)]\n        top_col_values = [heapq.nlargest(3, [board[j][i] for j in range(m)]) for i in range(n)]\n        \n        max_sum = 0\n        \n        # Iterate over all combinations of top 3 values in rows\n        for i in range(m):\n            for j in range(m):\n                if i == j:\n                    continue\n                for k in range(m):\n                    if i == k or j == k:\n                        continue\n                    \n                    # Get the top 3 values from the current rows\n                    row_i_top = set(top_row_values[i])\n                    row_j_top = set(top_row_values[j])\n                    row_k_top = set(top_row_values[k])\n                    \n                    # Find valid columns for each row\n                    for val_i in row_i_top:\n                        col_i = board[i].index(val_i)\n                        for val_j in row_j_top:\n                            col_j = board[j].index(val_j)\n                            if col_i == col_j:\n                                continue\n                            for val_k in row_k_top:\n                                col_k = board[k].index(val_k)\n                                if col_i == col_k or col_j == col_k:\n                                    continue\n                                \n                                # Calculate the sum of the selected cells\n                                current_sum = val_i + val_j + val_k\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Find top 3 values in each row and column\n        top_row_values = [heapq.nlargest(3, board[i]) for i in range(m)]\n        top_col_values = [heapq.nlargest(3, [board[j][i] for j in range(m)]) for i in range(n)]\n        \n        max_sum = 0\n        \n        # Iterate over all combinations of top 3 values in rows\n        for r1, r2, r3 in itertools.combinations(range(m), 3):\n            for c1, c2, c3 in itertools.permutations(range(n), 3):\n                if len({board[r1][c1], board[r2][c2], board[r3][c3]}) == 3:\n                    max_sum = max(max_sum, board[r1][c1] + board[r2][c2] + board[r3][c3])\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Find the top 3 values in each row\n        row_top_values = []\n        for i in range(m):\n            row = board[i]\n            top_three = heapq.nlargest(3, enumerate(row), key=lambda x: x[1])\n            row_top_values.append(top_three)\n        \n        # Find the top 3 values in each column\n        col_top_values = [[] for _ in range(n)]\n        for j in range(n):\n            col = [board[i][j] for i in range(m)]\n            top_three = heapq.nlargest(3, enumerate(col), key=lambda x: x[1])\n            for idx, val in top_three:\n                col_top_values[j].append((idx, val))\n        \n        max_sum = 0\n        \n        # Iterate over all combinations of top 3 values in each row\n        for r1, c1, v1 in row_top_values[0]:\n            for r2, c2, v2 in row_top_values[1]:\n                for r3, c3, v3 in row_top_values[2]:\n                    if len({r1, r2, r3}) == 3 and len({c1, c2, c3}) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = [(i, j, board[i][j]) for i in range(m) for j in range(n)]\n        cells.sort(key=lambda x: -x[2])  # Sort cells by value in descending order\n        \n        max_sum = 0\n        \n        # Try placing rooks in the top 27 cells (since 3^3 = 27)\n        for i in range(min(27, len(cells))):\n            for j in range(i + 1, min(27, len(cells))):\n                for k in range(j + 1, min(27, len(cells))):\n                    i1, j1, v1 = cells[i]\n                    i2, j2, v2 = cells[j]\n                    i3, j3, v3 = cells[k]\n                    if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Sort indices of each row by the value at those indices in descending order\n        row_indices = [sorted(range(n), key=lambda j: board[i][j], reverse=True) for i in range(m)]\n        # Sort indices of each column by the value at those indices in descending order\n        col_indices = [sorted(range(m), key=lambda i: board[i][j], reverse=True) for j in range(n)]\n        \n        max_sum = 0\n        \n        # Iterate over all possible ways to choose 3 rows\n        for r1, r2, r3 in combinations(range(m), 3):\n            # Get the top 3 indices from each of these rows\n            top_cols_r1 = row_indices[r1][:3]\n            top_cols_r2 = row_indices[r2][:3]\n            top_cols_r3 = row_indices[r3][:3]\n            \n            # Iterate over all combinations of these top columns\n            for c1, c2, c3 in product(top_cols_r1, top_cols_r2, top_cols_r3):\n                if len({c1, c2, c3}) == 3:  # Ensure columns are distinct\n                    current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                    max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Calculate the top 3 values in each row and column\n        row_top3 = [heapq.nlargest(3, board[i]) for i in range(m)]\n        col_top3 = [heapq.nlargest(3, [board[j][i] for j in range(m)]) for i in range(n)]\n        \n        # Create a mapping from value to (row, col) for quick lookup\n        value_to_pos = {}\n        for i in range(m):\n            for j in range(n):\n                value_to_pos[board[i][j]] = (i, j)\n        \n        max_sum = 0\n        \n        # Iterate over all combinations of top 3 values from each row\n        for r1 in range(3):\n            for r2 in range(3):\n                for r3 in range(3):\n                    val1, val2, val3 = row_top3[0][r1], row_top3[1][r2], row_top3[2][r3]\n                    pos1, pos2, pos3 = value_to_pos[val1], value_to_pos[val2], value_to_pos[val3]\n                    \n                    # Check if the columns are unique\n                    if len({pos1[1], pos2[1], pos3[1]}) == 3:\n                        max_sum = max(max_sum, val1 + val2 + val3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Calculate the top 3 values for each row and column\n        row_maxes = []\n        col_maxes = [heapq.nlargest(3, board[i][j] for i in range(m)) for j in range(n)]\n        \n        for i in range(m):\n            row_maxes.append(heapq.nlargest(3, board[i]))\n        \n        max_sum = 0\n        \n        # Iterate over all combinations of top 3 values in rows\n        for r1, c1, v1 in row_maxes[0]:\n            for r2, c2, v2 in row_maxes[1]:\n                if c1 != c2:\n                    for r3, c3, v3 in row_maxes[2]:\n                        if c1 != c3 and c2 != c3:\n                            max_sum = max(max_sum, v1 + v2 + v3)\n        \n        # Iterate over all combinations of top 3 values in columns\n        for c1, v1 in enumerate(col_maxes[0]):\n            for c2, v2 in enumerate(col_maxes[1]):\n                if c1 != c2:\n                    for c3, v3 in enumerate(col_maxes[2]):\n                        if c1 != c3 and c2 != c3:\n                            # Find the maximum row indices for these columns\n                            r1 = next((i for i in range(m) if board[i][c1] == v1), -1)\n                            r2 = next((i for i in range(m) if board[i][c2] == v2), -1)\n                            r3 = next((i for i in range(m) if board[i][c3] == v3), -1)\n                            if len({r1, r2, r3}) == 3:\n                                max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Calculate the sum of the top 3 values in each row and column\n        row_sums = []\n        col_sums = []\n        \n        for i in range(m):\n            row_sums.append(sorted([(board[i][j], j) for j in range(n)], reverse=True)[:3])\n        \n        for j in range(n):\n            col_sums.append(sorted([(board[i][j], i) for i in range(m)], reverse=True)[:3])\n        \n        max_sum = 0\n        \n        # Try placing rooks in the top configurations\n        for r1, c1, v1 in row_sums[0]:\n            for r2, c2, v2 in row_sums[1]:\n                if r2 == r1:\n                    continue\n                for r3, c3, v3 in row_sums[2]:\n                    if r3 == r1 or r3 == r2:\n                        continue\n                    cols_used = {c1, c2, c3}\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        for c1, r1, v1 in col_sums[0]:\n            for c2, r2, v2 in col_sums[1]:\n                if c2 == c1:\n                    continue\n                for c3, r3, v3 in col_sums[2]:\n                    if c3 == c1 or c3 == c2:\n                        continue\n                    rows_used = {r1, r2, r3}\n                    if len(rows_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Calculate the top 3 values in each row and column\n        row_top3 = []\n        col_top3 = [([], []) for _ in range(n)]\n        \n        for i in range(m):\n            row = board[i]\n            top3 = heapq.nlargest(3, ((val, j) for j, val in enumerate(row)))\n            row_top3.append(top3)\n            \n            for val, j in top3:\n                heapq.heappush(col_top3[j], (-val, i))\n                if len(col_top3[j]) > 3:\n                    heapq.heappop(col_top3[j])\n        \n        # Convert heaps to sorted lists for easier access\n        for j in range(n):\n            col_top3[j] = sorted((-val, i) for val, i in col_top3[j])\n        \n        max_sum = 0\n        \n        # Try placing rooks in the top configurations\n        for r1, c1, v1 in row_top3[0]:\n            for r2, c2, v2 in row_top3[1]:\n                if r2 == r1:\n                    continue\n                for r3, c3, v3 in row_top3[2]:\n                    if r3 == r1 or r3 == r2:\n                        continue\n                    cols_used = {c1, c2, c3}\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        for c1, r1, v1 in col_top3[0]:\n            for c2, r2, v2 in col_top3[1]:\n                if c2 == c1:\n                    continue\n                for c3, r3, v3 in col_top3[2]:\n                    if c3 == c1 or c3 == c2:\n                        continue\n                    rows_used = {r1, r2, r3}\n                    if len(rows_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Calculate the sum of the top 3 values in each row and column\n        row_sums = []\n        col_sums = []\n        \n        for i in range(m):\n            row_sums.append(sorted([(board[i][j], j) for j in range(n)], reverse=True)[:3])\n        \n        for j in range(n):\n            col_sums.append(sorted([(board[i][j], i) for i in range(m)], reverse=True)[:3])\n        \n        max_sum = 0\n        \n        # Try placing rooks in the top configurations\n        for r1, c1, v1 in row_sums[0]:\n            for r2, c2, v2 in row_sums[1]:\n                if r2 == r1:\n                    continue\n                for r3, c3, v3 in row_sums[2]:\n                    if r3 == r1 or r3 == r2:\n                        continue\n                    cols_used = {c1, c2, c3}\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        for c1, r1, v1 in col_sums[0]:\n            for c2, r2, v2 in col_sums[1]:\n                if c2 == c1:\n                    continue\n                for c3, r3, v3 in col_sums[2]:\n                    if c3 == c1 or c3 == c2:\n                        continue\n                    rows_used = {r1, r2, r3}\n                    if len(rows_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Calculate the top 3 values in each row and column\n        row_sums = []\n        col_sums = []\n        \n        for i in range(m):\n            row_values = [(board[i][j], j) for j in range(n)]\n            row_values.sort(reverse=True)\n            row_sums.append(row_values[:3])\n        \n        for j in range(n):\n            col_values = [(board[i][j], i) for i in range(m)]\n            col_values.sort(reverse=True)\n            col_sums.append(col_values[:3])\n        \n        max_sum = 0\n        \n        # Try placing rooks in the top configurations\n        for r1, c1, v1 in row_sums[0]:\n            for r2, c2, v2 in row_sums[1]:\n                if r2 == r1:\n                    continue\n                for r3, c3, v3 in row_sums[2]:\n                    if r3 == r1 or r3 == r2:\n                        continue\n                    cols_used = {c1, c2, c3}\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        for c1, r1, v1 in col_sums[0]:\n            for c2, r2, v2 in col_sums[1]:\n                if c2 == c1:\n                    continue\n                for c3, r3, v3 in col_sums[2]:\n                    if c3 == c1 or c3 == c2:\n                        continue\n                    rows_used = {r1, r2, r3}\n                    if len(rows_used) == 3:\n                        max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Manually generate combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Manually generate permutations of 3 columns\n                    for a in range(n):\n                        for b in range(n):\n                            if b == a:\n                                continue\n                            for c in range(n):\n                                if c == a or c == b:\n                                    continue\n                                current_sum = board[i][a] + board[j][b] + board[k][c]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Iterate over all permutations of 3 columns\n                    for a in range(n):\n                        for b in range(a + 1, n):\n                            for c in range(b + 1, n):\n                                current_sum = board[i][a] + board[j][b] + board[k][c]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Create SortedLists for each row and column\n        row_maxes = [SortedList() for _ in range(m)]\n        col_maxes = [SortedList() for _ in range(n)]\n        \n        # Populate the SortedLists with the negative values (to simulate max heap behavior)\n        for i in range(m):\n            for j in range(n):\n                row_maxes[i].add((-board[i][j], j))\n                col_maxes[j].add((-board[i][j], i))\n                if len(row_maxes[i]) > 3:\n                    row_maxes[i].pop()\n                if len(col_maxes[j]) > 3:\n                    col_maxes[j].pop()\n        \n        # Convert back to positive values and sort in descending order\n        for i in range(m):\n            row_maxes[i] = sorted([-val for val, _ in row_maxes[i]], reverse=True)\n        for j in range(n):\n            col_maxes[j] = sorted([-val for val, _ in col_maxes[j]], reverse=True)\n        \n        # Try placing rooks in the top 3 positions of each row and column combination\n        max_sum = float('-inf')\n        for r1 in range(3):\n            for c1 in range(3):\n                for r2 in range(3):\n                    for c2 in range(3):\n                        for r3 in range(3):\n                            for c3 in range(3):\n                                if len(set([r1, r2, r3])) == 3 and len(set([c1, c2, c3])) == 3:\n                                    current_sum = row_maxes[r1][c1] + row_maxes[r2][c2] + row_maxes[r3][c3]\n                                    max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Create lists to store the top 3 values for each row and column\n        row_maxes = [[] for _ in range(m)]\n        col_maxes = [[] for _ in range(n)]\n        \n        # Populate the lists with the values\n        for i in range(m):\n            for j in range(n):\n                row_maxes[i].append((board[i][j], j))\n                col_maxes[j].append((board[i][j], i))\n        \n        # Sort each list to get the top 3 values\n        for i in range(m):\n            row_maxes[i].sort(reverse=True, key=lambda x: x[0])\n            row_maxes[i] = row_maxes[i][:3]\n        for j in range(n):\n            col_maxes[j].sort(reverse=True, key=lambda x: x[0])\n            col_maxes[j] = col_maxes[j][:3]\n        \n        # Try placing rooks in the top 3 positions of each row and column combination\n        max_sum = float('-inf')\n        for r1, c1, val1 in row_maxes[0]:\n            for r2, c2, val2 in row_maxes[1]:\n                for r3, c3, val3 in row_maxes[2]:\n                    if len(set([r1, r2, r3])) == 3 and len(set([c1, c2, c3])) == 3:\n                        current_sum = val1 + val2 + val3\n                        max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Create heaps for each row and column to store the top 3 values\n        row_maxes = [[] for _ in range(m)]\n        col_maxes = [[] for _ in range(n)]\n        \n        # Populate the heaps with the negative values (to simulate max heap behavior)\n        for i in range(m):\n            for j in range(n):\n                heappush(row_maxes[i], -board[i][j])\n                heappush(col_maxes[j], -board[i][j])\n                if len(row_maxes[i]) > 3:\n                    heappop(row_maxes[i])\n                if len(col_maxes[j]) > 3:\n                    heappop(col_maxes[j])\n        \n        # Convert back to positive values and sort in descending order\n        for i in range(m):\n            row_maxes[i] = sorted([-heappop(row_maxes[i]) for _ in range(len(row_maxes[i]))], reverse=True)\n        for j in range(n):\n            col_maxes[j] = sorted([-heappop(col_maxes[j]) for _ in range(len(col_maxes[j]))], reverse=True)\n        \n        # Try placing rooks in the top 3 positions of each row and column combination\n        max_sum = float('-inf')\n        for r1 in range(min(3, len(row_maxes))):\n            for c1 in range(min(3, len(col_maxes))):\n                for r2 in range(min(3, len(row_maxes))):\n                    if r2 == r1:\n                        continue\n                    for c2 in range(min(3, len(col_maxes))):\n                        if c2 == c1:\n                            continue\n                        for r3 in range(min(3, len(row_maxes))):\n                            if r3 == r1 or r3 == r2:\n                                continue\n                            for c3 in range(min(3, len(col_maxes))):\n                                if c3 == c1 or c3 == c2:\n                                    continue\n                                current_sum = row_maxes[r1][c1] + row_maxes[r2][c2] + row_maxes[r3][c3]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Create heaps for each row and column to store the top 3 values\n        row_maxes = [[] for _ in range(m)]\n        col_maxes = [[] for _ in range(n)]\n        \n        # Populate the heaps with the negative values (to simulate max heap behavior)\n        for i in range(m):\n            for j in range(n):\n                heappush(row_maxes[i], -board[i][j])\n                heappush(col_maxes[j], -board[i][j])\n                if len(row_maxes[i]) > 3:\n                    heappop(row_maxes[i])\n                if len(col_maxes[j]) > 3:\n                    heappop(col_maxes[j])\n        \n        # Convert back to positive values and sort in descending order\n        for i in range(m):\n            row_maxes[i] = sorted([-heappop(row_maxes[i]) for _ in range(len(row_maxes[i]))], reverse=True)\n        for j in range(n):\n            col_maxes[j] = sorted([-heappop(col_maxes[j]) for _ in range(len(col_maxes[j]))], reverse=True)\n        \n        # Try placing rooks in the top 3 positions of each row and column combination\n        max_sum = float('-inf')\n        for r1 in range(min(3, len(row_maxes))):\n            for c1 in range(min(3, len(col_maxes))):\n                for r2 in range(min(3, len(row_maxes))):\n                    if r2 == r1:\n                        continue\n                    for c2 in range(min(3, len(col_maxes))):\n                        if c2 == c1:\n                            continue\n                        for r3 in range(min(3, len(row_maxes))):\n                            if r3 == r1 or r3 == r2:\n                                continue\n                            for c3 in range(min(3, len(col_maxes))):\n                                if c3 == c1 or c3 == c2:\n                                    continue\n                                current_sum = row_maxes[r1][c1] + row_maxes[r2][c2] + row_maxes[r3][c3]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for i in range(m):\n            for j in range(i + 1, m):\n                for k in range(j + 1, m):\n                    # Iterate over all permutations of 3 columns\n                    for a in range(n):\n                        for b in range(a + 1, n):\n                            for c in range(b + 1, n):\n                                current_sum = board[i][a] + board[j][b] + board[k][c]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values in each row and column\n        row_top3 = [heapq.nlargest(3, row) for row in board]\n        col_top3 = [heapq.nlargest(3, (board[i][j] for i in range(m))) for j in range(n)]\n        \n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for r1, r2, r3 in itertools.combinations(range(m), 3):\n            # Get the top 3 values from these rows\n            top3_r1 = row_top3[r1]\n            top3_r2 = row_top3[r2]\n            top3_r3 = row_top3[r3]\n            \n            # Iterate over all permutations of 3 columns\n            for c1, c2, c3 in itertools.permutations(range(n), 3):\n                # Calculate the sum for this configuration\n                current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Sort each row by value in descending order and keep track of original indices\n        sorted_rows = []\n        for i in range(m):\n            sorted_row = sorted((board[i][j], j) for j in range(n))\n            sorted_rows.append(sorted_row[::-1])  # Reverse to have highest values first\n        \n        max_sum = float('-inf')\n        \n        # Try placing rooks in the top 3 positions of each row combination\n        for r1 in range(m):\n            for r2 in range(r1 + 1, m):\n                for r3 in range(r2 + 1, m):\n                    cols_used = set()\n                    current_sum = 0\n                    for _, c1 in sorted_rows[r1]:\n                        if c1 not in cols_used:\n                            cols_used.add(c1)\n                            current_sum += board[r1][c1]\n                            break\n                    for _, c2 in sorted_rows[r2]:\n                        if c2 not in cols_used:\n                            cols_used.add(c2)\n                            current_sum += board[r2][c2]\n                            break\n                    for _, c3 in sorted_rows[r3]:\n                        if c3 not in cols_used:\n                            cols_used.add(c3)\n                            current_sum += board[r3][c3]\n                            break\n                    max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
  ],
  "total_candidates": 39,
  "nodes_explored": 39,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
      "solution_hash": "37fee81c1a4b2b28895684376bd1c20356f0cc51e6fb307d5ff8e7ac35ed5c91",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmpv3pj1u45.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmpv3pj1u45.py` failed. (See above for error)\n",
        "execution_time": 13.493191003799438,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = [(i, j, board[i][j]) for i in range(m) for j in range(n)]\n        cells.sort(key=lambda x: -x[2])  # Sort cells by value in descending order\n        \n        max_sum = 0\n        used_rows = set()\n        used_cols = set()\n        selected_cells = []\n        \n        for i, j, value in cells:\n            if len(selected_cells) == 3:\n                break\n            if i not in used_rows and j not in used_cols:\n                selected_cells.append((i, j, value))\n                used_rows.add(i)\n                used_cols.add(j)\n        \n        # Calculate the sum of the selected cells\n        max_sum = sum(value for _, _, value in selected_cells)\n        \n        # Try different combinations of selecting 3 cells\n        for comb in combinations(cells, 3):\n            i1, j1, v1 = comb[0]\n            i2, j2, v2 = comb[1]\n            i3, j3, v3 = comb[2]\n            if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3:\n                max_sum = max(max_sum, v1 + v2 + v3)\n        \n        return max_sum",
      "solution_hash": "ba1bfd20dee8066d57c1996dc1f6a30e472d7b14433c7e1df6c71323bc6424bd",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmptur8auir.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmptur8auir.py` failed. (See above for error)\n",
        "execution_time": 13.46710467338562,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14",
        "1_18",
        "1_22"
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all combinations of 3 rows\n        for rows in itertools.combinations(range(m), 3):\n            # Iterate over all permutations of 3 columns\n            for cols in itertools.permutations(range(n), 3):\n                current_sum = sum(board[row][col] for row, col in zip(rows, cols))\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
      "solution_hash": "37fee81c1a4b2b28895684376bd1c20356f0cc51e6fb307d5ff8e7ac35ed5c91",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242033/tmpv3pj1u45.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242033/tmpv3pj1u45.py` failed. (See above for error)\n",
        "execution_time": 13.493191003799438,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_27",
        "1_31",
        "1_35"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 39,
    "candidates_generated": 39,
    "tests_passed": 0,
    "tests_failed": 1,
    "test_timeouts": 0,
    "test_errors": 0,
    "import_errors": 38,
    "import_terminated_branches": 0,
    "unique_import_failures": [
      "sortedcontainers"
    ],
    "execution_times": [
      13.493191003799438,
      13.493191003799438,
      13.488263845443726,
      13.484933376312256,
      13.488263845443726,
      13.493191003799438,
      13.497060537338257,
      13.515666961669922,
      13.493191003799438,
      13.505053281784058,
      13.477856874465942,
      13.439269781112671,
      13.431699752807617,
      13.46710467338562,
      13.464973211288452,
      13.534546852111816,
      13.459403038024902,
      13.479401350021362,
      13.514954566955566,
      13.477361917495728,
      13.49054765701294,
      13.483211040496826,
      13.449885606765747,
      13.455225229263306,
      13.449885606765747,
      13.498348712921143,
      13.493191003799438,
      13.493191003799438,
      13.49466061592102,
      13.472522735595703,
      13.505053281784058,
      13.526147603988647,
      13.508440971374512,
      13.511824369430542,
      13.511824369430542,
      13.493191003799438,
      13.505053281784058,
      13.55292558670044,
      13.51253080368042
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 28,
      "unique_ratio": 0.717948717948718,
      "similarity_score": 0.81168182765504,
      "solution_lengths": {
        "min": 531,
        "max": 2111,
        "avg": 1178.4615384615386
      },
      "algorithm_approaches": {
        "backtracking": 32,
        "hash_table": 1,
        "other": 6
      },
      "feature_diversity": 0.717948717948718,
      "features_analysis": {
        "boolean_features": {
          "has_recursion": {
            "true_ratio": 1.0,
            "count": 39
          },
          "uses_list": {
            "true_ratio": 0.38461538461538464,
            "count": 15
          },
          "uses_dict": {
            "true_ratio": 0.02564102564102564,
            "count": 1
          },
          "uses_set": {
            "true_ratio": 0.23076923076923078,
            "count": 9
          },
          "uses_heap": {
            "true_ratio": 0.3333333333333333,
            "count": 13
          },
          "uses_queue": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_stack": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dp": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_bfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_binary_search": {
            "true_ratio": 0.0,
            "count": 0
          },
          "nested_loops": {
            "true_ratio": 1.0,
            "count": 39
          }
        },
        "numeric_features": {
          "loop_count": {
            "min": 3,
            "max": 14,
            "avg": 7.128205128205129,
            "variance": 10.7784352399737
          },
          "if_count": {
            "min": 0,
            "max": 8,
            "avg": 2.2564102564102564,
            "variance": 5.882971729125575
          },
          "else_count": {
            "min": 0,
            "max": 3,
            "avg": 0.07692307692307693,
            "variance": 0.2248520710059173
          },
          "return_count": {
            "min": 1,
            "max": 1,
            "avg": 1.0,
            "variance": 0.0
          },
          "assignment_count": {
            "min": 4,
            "max": 20,
            "avg": 10.64102564102564,
            "variance": 29.15318869165023
          },
          "class_method_count": {
            "min": 1,
            "max": 1,
            "avg": 1.0,
            "variance": 0.0
          },
          "line_count": {
            "min": 13,
            "max": 49,
            "avg": 27.692307692307693,
            "variance": 136.57199211045358
          },
          "char_count": {
            "min": 531,
            "max": 2111,
            "avg": 1178.4615384615386,
            "variance": 254253.68441814595
          },
          "max_indent": {
            "min": 16,
            "max": 40,
            "avg": 26.564102564102566,
            "variance": 66.04076265614728
          }
        }
      },
      "complexity_diversity": {
        "complexity_distribution": {
          "exponential": 39
        },
        "avg_complexity_metrics": {
          "avg_line_count": 27.692307692307693,
          "avg_loop_count": 7.128205128205129,
          "avg_condition_count": 2.3333333333333335,
          "avg_method_count": 1.0,
          "avg_assignment_count": 10.64102564102564,
          "avg_max_loop_nesting": 1.2564102564102564
        },
        "complexity_diversity_ratio": 0.16666666666666666
      }
    },
    "test_case_analysis": {
      "hardest_cases": {},
      "first_failing_tests": {}
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 9,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 27,
          "improvements": 0,
          "solved": 0
        }
      },
      "error_types": {
        "other_error": {
          "attempts": 12,
          "improvements": 0
        }
      },
      "test_case_improvements": {},
      "error_transitions": {
        "other_error->other_error": 35,
        "other_error->syntax_error": 1
      }
    },
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.6153846153846154,
        "solutions_per_depth": {
          "0": 3,
          "1": 9,
          "2": 27
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.0,
        "pass@3": 0.0,
        "pass@5": 0.0,
        "pass@10": 0.0
      },
      "solutions_evaluated": 40
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0,
        "test_success_rate": 0.0
      },
      "test_results": {
        "total": 39,
        "passed": 0,
        "failed": 1,
        "timeouts": 0,
        "import_errors": 38,
        "other_errors": 0,
        "unique_import_failures": [
          "sortedcontainers"
        ]
      },
      "error_recovery": {
        "total_attempts": 12,
        "total_improvements": 0,
        "recovery_rate": 0.0
      },
      "top_errors": [
        [
          "other_error",
          12
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      },
      "import_analysis": {
        "total_import_errors": 38,
        "branches_terminated_by_imports": 0,
        "unique_missing_modules": 1,
        "missing_modules": [
          "sortedcontainers"
        ]
      }
    }
  },
  "processing_time": 1330.2280905246735,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.0,
      "pass@3": 0.0,
      "pass@5": 0.0,
      "pass@10": 0.0
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: Generator expression must be parenthesized (<string>, line 107)",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 37
          }
        ],
        [
          38,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 38
          }
        ],
        [
          39,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 39
          }
        ]
      ]
    },
    "solutions_evaluated": 40,
    "test_cases": 1
  }
}