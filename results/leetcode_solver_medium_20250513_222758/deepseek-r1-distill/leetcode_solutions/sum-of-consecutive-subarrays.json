{
  "problem_id": "sum-of-consecutive-subarrays",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "unsolved",
  "best_solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        \n        for i in range(n):\n            # Each single element is a consecutive subarray\n            total += nums[i]\n            # Check for consecutive subarrays starting at i\n            if i == n - 1:\n                continue\n            # Determine the direction\n            direction = nums[i+1] - nums[i]\n            if direction not in (1, -1):\n                continue\n            # Now, check how far this consecutive sequence extends\n            current_sum = nums[i] + nums[i+1]\n            total += current_sum\n            j = i + 2\n            while j < n:\n                if nums[j] - nums[j-1] == direction:\n                    current_sum += nums[j]\n                    total += current_sum\n                    j += 1\n                else:\n                    break\n        return total % MOD",
  "passed_solutions": [
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        for i in range(n):\n            # Each single element is a consecutive subarray\n            total += nums[i]\n            # Check for subarrays starting at i\n            for j in range(i + 1, n):\n                # Determine the direction\n                if j == i + 1:\n                    diff = nums[j] - nums[j - 1]\n                    if diff not in (1, -1):\n                        break\n                    current_diff = diff\n                else:\n                    new_diff = nums[j] - nums[j - 1]\n                    if new_diff != current_diff:\n                        break\n                # Calculate the sum of nums[i..j]\n                sub_sum = sum(nums[i:j+1])\n                total += sub_sum\n                total %= MOD\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        \n        for i in range(n):\n            # Each single element is a consecutive subarray\n            total += nums[i]\n            # Check for consecutive subarrays starting at i\n            if i == n - 1:\n                continue\n            # Determine the direction\n            direction = nums[i+1] - nums[i]\n            if direction not in (1, -1):\n                continue\n            # Now, check how far this consecutive sequence extends\n            current_sum = nums[i] + nums[i+1]\n            total += current_sum\n            j = i + 2\n            while j < n:\n                if nums[j] - nums[j-1] == direction:\n                    current_sum += nums[j]\n                    total += current_sum\n                    j += 1\n                else:\n                    break\n        return total % MOD"
  ],
  "all_solutions": [
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        prev = nums[0]\n        current_length = 1\n        total += prev\n        for i in range(1, n):\n            if nums[i] == prev + 1 or nums[i] == prev - 1:\n                current_length += 1\n                current_sum = current_sum + nums[i] * current_length - (nums[i] - (nums[i] - prev)) * (current_length - 1) // 2\n                total += current_sum\n            else:\n                current_length = 1\n                current_sum = nums[i]\n                total += current_sum\n            prev = nums[i]\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        for i in range(n):\n            # Each single element is a consecutive subarray\n            total += nums[i]\n            # Check for subarrays starting at i\n            for j in range(i + 1, n):\n                # Determine the direction\n                if j == i + 1:\n                    diff = nums[j] - nums[j - 1]\n                    if diff not in (1, -1):\n                        break\n                    current_diff = diff\n                else:\n                    new_diff = nums[j] - nums[j - 1]\n                    if new_diff != current_diff:\n                        break\n                # Calculate the sum of nums[i..j]\n                sub_sum = sum(nums[i:j+1])\n                total += sub_sum\n                total %= MOD\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_length = 1\n        for i in range(1, n):\n            if (nums[i] == nums[i-1] + 1) or (nums[i] == nums[i-1] - 1):\n                current_length += 1\n            else:\n                # Calculate the sum of all subarrays in the current consecutive sequence\n                k = current_length\n                sum_subarrays = (k * (k + 1) // 2) * (nums[i - current_length] + nums[i - 1]) // 2\n                total += sum_subarrays\n                current_length = 1\n        # Add the sum for the last consecutive sequence\n        k = current_length\n        sum_subarrays = (k * (k + 1) // 2) * (nums[-k] + nums[-1]) // 2\n        total += sum_subarrays\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_length = 1\n        for i in range(1, n):\n            if (nums[i] == nums[i-1] + 1) or (nums[i] == nums[i-1] - 1):\n                current_length += 1\n            else:\n                # Calculate the sum of all consecutive subarrays ending at i-1\n                k = current_length\n                # The number of subarrays is k, each of length 1 to k\n                # Sum of elements for each subarray can be computed as sum of arithmetic series\n                # Sum of elements from start to end is (start + end) * length / 2\n                # For each possible subarray length l (1<=l<=k), the sum is (nums[i-l] + nums[i-1]) * l / 2\n                # The total sum for all subarrays is sum_{l=1 to k} (nums[i-l] + nums[i-1]) * l / 2\n                # This can be simplified as (nums[i-1] * (k*(k+1)/2) + nums[i-k] * (k*(k+1)/2)) / 2\n                # Wait, no, that's not correct. Because for each l, the starting element is nums[i-l], and the sum is (nums[i-l] + nums[i-1]) * l / 2\n                # So the total sum is sum_{l=1 to k} (nums[i-l] + nums[i-1]) * l / 2\n                # Which is equal to (sum_{l=1 to k} (nums[i-l] * l) + nums[i-1] * sum_{l=1 to k} l) ) / 2\n                # But this approach is O(n^2), which is not feasible for n=1e5\n                # So we need a more efficient way\n                # Let's think differently: for each position, find the maximum possible consecutive subarray ending there\n                # Then, for each such subarray of length l, the sum is sum of the subarray\n                # But calculating this for each l is O(n^2), which is too slow\n                # So we need a way to compute the sum of all consecutive subarrays in O(n) time\n                # Let's think about the properties of consecutive arrays\n                # For a consecutive array, the difference between consecutive elements is either +1 or -1\n                # So, for a consecutive subarray of length l, the sum can be expressed as l * a_1 + (l*(l-1))/2 * d, where d is the common difference\n                # But since d can be +1 or -1, we can model this\n                # However, this might complicate things\n                # Another approach: for each position i, find the maximum possible consecutive subarray ending at i, and keep track of the sum of all such subarrays\n                # Let's define two variables: increasing and decreasing\n                # increasing[i] is the length of the longest consecutive increasing subarray ending at i\n                # Similarly for decreasing\n                # Then, for each i, the number of consecutive subarrays ending at i is increasing[i] + decreasing[i] - 1 (since the single element is counted in both)\n                # But wait, no. Because a subarray can be either increasing or decreasing, but not both unless it's length 1\n                # So for each i, the number of consecutive subarrays ending at i is the number of increasing subarrays ending at i plus the number of decreasing subarrays ending at i\n                # But how to compute the sum of their values efficiently\n                # Let's think of it this way: for each i, we can track the current run's direction and length\n                # For example, if the current run is increasing, then the sum of all subarrays ending at i is the sum of the previous run's sum plus the current element multiplied by the current run's length\n                # Wait, perhaps we can model it with dynamic programming\n                # Let's define for each i:\n                # inc[i]: the length of the longest consecutive increasing subarray ending at i\n                # dec[i]: the length of the longest consecutive decreasing subarray ending at i\n                # Then, for each i, the number of consecutive subarrays ending at i is inc[i] + dec[i] - 1 (since the single element is counted in both)\n                # But we need the sum of their values, not just the count\n                # So, we need to track not just the lengths but also the sum of the subarrays\n                # Let's define:\n                # inc_sum[i]: the sum of all consecutive increasing subarrays ending at i\n                # dec_sum[i]: the sum of all consecutive decreasing subarrays ending at i\n                # Then, the total sum is the sum of inc_sum[i] + dec_sum[i] for all i\n                # Now, how to compute inc_sum and dec_sum\n                # For inc_sum[i]:\n                # If nums[i] == nums[i-1] + 1, then inc[i] = inc[i-1] + 1\n                # And inc_sum[i] = inc_sum[i-1] + nums[i] * inc[i]\n                # Similarly for dec_sum[i]\n                # Wait, let's think:\n                # When the current element continues an increasing sequence, the new subarrays are all the subarrays that end at i-1 extended by i, plus the subarray containing only i\n                # So, for example, if inc[i-1] is 2, meaning the subarrays [i-2, i-1] and [i-1], then adding i, we get [i-2, i-1, i], [i-1, i], and [i]\n                # The sum for these new subarrays is sum([i-2,i-1,i]) + sum([i-1,i]) + sum([i])\n                # Which is equal to sum([i-2,i-1]) + i * 3 (since each new subarray includes i)\n                # Wait, perhaps a better way is to model inc_sum[i] as the sum of all increasing consecutive subarrays ending at i\n                # So, if the current element continues the increasing sequence, then inc_sum[i] = inc_sum[i-1] + nums[i] * inc[i]\n                # Because each of the inc[i] subarrays ending at i includes nums[i], and there are inc[i] such subarrays\n                # Similarly for dec_sum[i]\n                # Let's test this with an example:\n                # Example 1: nums = [1,2,3]\n                # i=0: inc[0]=1, inc_sum[0]=1\n                # i=1: nums[1] = nums[0]+1, so inc[1]=2, inc_sum[1] = inc_sum[0] + 2*2 = 1 + 4 =5\n                # i=2: nums[2] = nums[1]+1, inc[2]=3, inc_sum[2] =5 +3*3=14\n                # dec_sum remains 0 for all\n                # Total sum is 14 + 0 =14, but the correct answer is 20\n                # Wait, this approach is missing the decreasing subarrays and also the single elements\n                # Because each single element is both increasing and decreasing\n                # So, perhaps we need to consider that each element contributes to both inc_sum and dec_sum, but we have to avoid double-counting\n                # Alternatively, perhaps the initial approach is not sufficient, and we need a different method\n                # Let's think differently: for each position, determine the maximum possible consecutive subarray ending there, and for each possible length l (from 1 to max_length), compute the sum of the subarray of length l ending at i, and add it to the total\n                # But for n=1e5, this would be O(n^2), which is too slow\n                # So we need a way to compute this in O(n) time\n                # Let's think about the properties of consecutive subarrays\n                # A consecutive subarray can be either increasing or decreasing\n                # For an increasing subarray of length l, the elements are a, a+1, a+2, ..., a+l-1\n                # The sum is l*a + l*(l-1)/2\n                # Similarly, for a decreasing subarray, the sum is l*a - l*(l-1)/2\n                # So, for each position i, if we know whether the current subarray is increasing or decreasing, and its length, we can compute the sum of all subarrays ending at i\n                # Let's try to model this\n                # We'll keep track of the current run's type (increasing, decreasing, or single) and its length\n                # For each i, we check if nums[i] - nums[i-1] is 1 or -1\n                # If it's 1, then the current run is increasing\n                # If it's -1, then the current run is decreasing\n                # Else, the run is broken, and we start a new run\n                # For each run, we can compute the sum of all possible subarrays within it\n                # For example, in an increasing run of length l, the number of subarrays is l*(l+1)/2\n                # But we need the sum of their values, not the count\n                # So, for each run, we can compute the sum of all possible subarrays within it\n                # Let's consider an increasing run starting at index s and ending at index e\n                # The elements are a, a+1, a+2, ..., a + (e-s)\n                # For each possible subarray length l (1 <= l <= e-s+1), the sum is sum_{k=0 to l-1} (a + k) = l*a + l*(l-1)/2\n                # The total sum for all subarrays in this run is sum_{l=1 to len} sum_{k=0 to l-1} (a +k)\n                # Which is sum_{l=1 to len} [l*a + l*(l-1)/2]\n                # This can be simplified as a * sum(l) + sum(l*(l-1)/2)\n                # Sum(l) from 1 to len is len*(len+1)/2\n                # Sum(l*(l-1)/2) from 1 to len is sum_{l=1 to len} (l^2 - l)/2 = [sum(l^2) - sum(l)] / 2\n                # Sum(l^2) from 1 to len is len*(len+1)*(2len+1)/6\n                # Sum(l) is len*(len+1)/2\n                # So, putting it all together:\n                # total_sum = a * (len*(len+1)/2) + [ (len*(len+1)*(2len+1)/6) - (len*(len+1)/2) ] / 2\n                # Simplify:\n                # total_sum = a * len*(len+1)/2 + [ len*(len+1)*(2len+1 - 3) ] / 12\n                # Because 6 is the denominator for sum(l^2), and 2 is the denominator for sum(l)\n                # Wait, let's recompute:\n                # sum(l*(l-1)/2) = 1/2 * sum(l^2 - l) = 1/2 [ sum(l^2) - sum(l) ]\n                # So, sum(l*(l-1)/2) = 1/2 [ len(len+1)(2len+1)/6 - len(len+1)/2 ]\n                # Factor out len(len+1)/2:\n                # = 1/2 [ len(len+1)/2 ( (2len+1)/3 - 1 ) ]\n                # = 1/2 [ len(len+1)/2 ( (2len+1 - 3)/3 ) ]\n                # = 1/2 [ len(len+1)/2 * (2len -2)/3 ]\n                # = 1/2 * len(len+1)(2len-2) / 6\n                # = len(len+1)(len-1) / 6\n                # So, total_sum = a * len*(len+1)/2 + len(len+1)(len-1)/6\n                # Similarly for decreasing runs, but the sum would be a * len*(len+1)/2 - len(len+1)(len-1)/6\n                # So, for each run, we can compute the sum of all its subarrays in O(1) time\n                # Now, the plan is:\n                # 1. Iterate through the array, identifying runs of consecutive increasing or decreasing elements\n                # 2. For each run, compute the sum of all its subarrays using the formulas above\n                # 3. Add this sum to the total\n                # 4. Also, account for single elements (which are both increasing and decreasing, but we should count them only once)\n                # Wait, but single elements are part of both increasing and decreasing runs, but we should count them only once\n                # So, perhaps we need to treat single elements separately\n                # Alternatively, when a run has length 1, it's counted once\n                # Let's test this approach with the first example:\n                # Example 1: nums = [1,2,3]\n                # The entire array is an increasing run of length 3\n                # a =1, len=3\n                # total_sum = 1*(3*4/2) + 3*4*2/6 = 6 + 24/6=6+4=10\n                # But the correct sum for this run is 1+2+3 + (1+2)+(2+3) + (1+2+3) = 6 +3+5+6=20\n                # Wait, but according to the formula, it's 10, which is incorrect\n                # So, the formula is not capturing the correct sum\n                # Hmm, perhaps I made a mistake in deriving the formula\n                # Let's recompute the sum for the increasing run [1,2,3]\n                # Subarrays:\n                # [1] sum=1\n                # [2] sum=2\n                # [3] sum=3\n                # [1,2] sum=3\n                # [2,3] sum=5\n                # [1,2,3] sum=6\n                # Total sum: 1+2+3+3+5+6=20\n                # According to the formula:\n                # a=1, len=3\n                # total_sum = 1*(3*4/2) + (3*4*2)/6 = 6 + 24/6=6+4=10\n                # Which is half of the correct value\n                # So, the formula is incorrect\n                # What's wrong here?\n                # Let's re-examine the derivation\n                # The sum of all subarrays in an increasing run is sum_{l=1 to len} sum_{k=0 to l-1} (a +k)\n                # Which is sum_{l=1 to len} [ l*a + l*(l-1)/2 ]\n                # So, total_sum = a * sum(l) + sum(l*(l-1)/2)\n                # Sum(l) from 1 to len is len*(len+1)/2\n                # Sum(l*(l-1)/2) from 1 to len is sum_{l=1 to len} (l^2 - l)/2 = [sum(l^2) - sum(l)] / 2\n                # Sum(l^2) is len(len+1)(2len+1)/6\n                # Sum(l) is len(len+1)/2\n                # So, sum(l*(l-1)/2) = [ len(len+1)(2len+1)/6 - len(len+1)/2 ] / 2\n                # Let's compute this for len=3:\n                # sum(l*(l-1)/2) = [3*4*7/6 - 3*4/2 ] /2 = [84/6 - 12/2]/2 = [14 -6]/2=8/2=4\n                # a*sum(l) =1*(3*4/2)=6\n                # total_sum=6+4=10, but correct is 20\n                # So, the formula is missing a factor of 2\n                # Wait, perhaps because each subarray is counted once, but in reality, each subarray is part of either an increasing or decreasing run, but not both\n                # Or perhaps the formula is correct, but the approach is not considering that each subarray can be part of multiple runs\n                # Alternatively, perhaps the formula is correct, but the way we are applying it is wrong\n                # Let's think differently: perhaps the formula should be multiplied by 2, because each subarray can be part of both increasing and decreasing runs, but in reality, they are only part of one\n                # No, that doesn't make sense\n                # Alternatively, perhaps the formula is correct, but the way we are identifying runs is incorrect\n                # For example, in the first example, the entire array is an increasing run, so the formula gives 10, but the correct sum is 20\n                # So, the formula is incorrect\n                # Let's try to rederive the formula\n                # For an increasing run starting at a, length l\n                # The subarrays are all possible consecutive subarrays within this run\n                # Each subarray of length k (1<=k<=l) contributes",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_start = 0\n        for i in range(1, n):\n            if (nums[i] == nums[i-1] + 1) or (nums[i] == nums[i-1] - 1):\n                continue\n            else:\n                # Calculate all subarrays from current_start to i-1\n                length = i - current_start\n                # Sum of all subarrays in this consecutive sequence\n                sum_subarrays = 0\n                for l in range(1, length + 1):\n                    for s in range(current_start, current_start + length - l + 1):\n                        sum_subarrays += sum(nums[s:s+l])\n                total += sum_subarrays\n                current_start = i\n        # Handle the last segment\n        length = n - current_start\n        sum_subarrays = 0\n        for l in range(1, length + 1):\n            for s in range(current_start, current_start + length - l + 1):\n                sum_subarrays += sum(nums[s:s+l])\n        total += sum_subarrays\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        i = 0\n        while i < n:\n            # Start a new consecutive sequence\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i+1] - nums[i] == 1:\n                    direction = 1\n                elif nums[i+1] - nums[i] == -1:\n                    direction = -1\n                else:\n                    # Single element\n                    total += nums[i]\n                    i += 1\n                    continue\n            else:\n                # Single element\n                total += nums[i]\n                i += 1\n                continue\n            \n            # Now, find the maximum length of the consecutive sequence starting at i\n            j = i + 1\n            while j < n and nums[j] - nums[j-1] == direction:\n                j += 1\n            # The length is j - i\n            length = j - i\n            # Now, calculate the sum of all subarrays within this consecutive sequence\n            # The number of subarrays is length * (length + 1) // 2\n            # Each subarray's sum can be calculated based on the starting and ending elements\n            # For a consecutive sequence, the sum of a subarray from a to b is (b - a + 1) * (nums[a] + nums[b]) // 2\n            # So, for each possible subarray within this sequence, we need to compute this\n            # However, this approach is O(n^2), which is not feasible for n=1e5\n            # Instead, we need a mathematical formula to compute the total sum efficiently\n            # Let's think about all possible subarrays in this consecutive sequence\n            # For each possible starting index s (from i to j-1), and ending index e (from s to j-1)\n            # The sum is (e - s + 1) * (nums[s] + nums[e]) // 2\n            # But calculating this for each s and e is O(n^2), which is too slow\n            # So, we need a way to compute this sum in O(1) per consecutive sequence\n            # Let's model the consecutive sequence as an arithmetic sequence\n            # The consecutive sequence is either increasing or decreasing by 1 each step\n            # Let's denote the starting element as a, and the direction as d (1 or -1)\n            a = nums[i]\n            d = direction\n            # The elements are a, a + d, a + 2d, ..., a + (length-1)d\n            # For a subarray starting at position s (0-based within the consecutive sequence) and ending at e (s <= e < length)\n            # The sum is (e - s + 1) * (a + s*d + a + e*d) // 2\n            # Simplify: (e - s + 1) * (2a + (s + e)d) // 2\n            # The total sum for all subarrays is the sum over s from 0 to length-1, and e from s to length-1 of the above expression\n            # Let's compute this sum\n            # Let's denote m = length\n            m = length\n            # The total sum can be broken down into two parts: the sum of (e - s + 1) and the sum of (s + e)\n            # Because d is either 1 or -1, but since it's a consecutive sequence, d is fixed for the entire sequence\n            # So, the total sum is (sum over s, e) [ (e - s + 1) * (2a + d(s + e)) / 2 ]\n            # Let's factor out 1/2: total = (1/2) * sum [ (e - s + 1)(2a + d(s + e)) ]\n            # Let's expand the terms inside:\n            # (e - s + 1)(2a) + (e - s + 1)(d)(s + e)\n            # So, total = (1/2) [ 2a * sum(e - s + 1) + d * sum( (e - s + 1)(s + e) ) ]\n            # Let's compute each part separately\n            # Compute sum(e - s + 1) for all s <= e\n            # sum_{s=0 to m-1} sum_{e=s to m-1} (e - s + 1)\n            # Let k = e - s + 1, which ranges from 1 to m - s\n            # So, for each s, the inner sum is sum_{k=1 to m - s} k = (m - s)(m - s + 1)/2\n            # So, sum(e - s + 1) = sum_{s=0 to m-1} (m - s)(m - s + 1)/2\n            # Let t = m - s, which ranges from m down to 1 as s increases from 0 to m-1\n            # So, sum becomes sum_{t=1 to m} t(t + 1)/2 = sum_{t=1 to m} (t^2 + t)/2\n            # Which is [sum t^2 + sum t ] / 2\n            # Sum t^2 from 1 to m is m(m+1)(2m+1)/6\n            # Sum t from 1 to m is m(m+1)/2\n            # So, sum(e - s + 1) = [ m(m+1)(2m+1)/6 + m(m+1)/2 ] / 2\n            # Simplify:\n            # = [ m(m+1)(2m+1 + 3) ] / (6 * 2 )\n            # Wait, let's compute it step by step\n            sum_e_s_plus_1 = (m * (m + 1) * (2 * m + 1) // 6 + m * (m + 1) // 2) // 2\n            # Now compute sum( (e - s + 1)(s + e) )\n            # Let's expand (e - s + 1)(s + e) = (e - s + 1)(e + s) = (e + s)(e - s + 1)\n            # Let's denote e = s + k - 1, where k ranges from 1 to m - s\n            # Then, e + s = 2s + k - 1\n            # e - s + 1 = k\n            # So, the term becomes k*(2s + k - 1)\n            # So, sum over s and k:\n            # sum_{s=0 to m-1} sum_{k=1 to m - s} k*(2s + k - 1)\n            # Let's split this into two parts:\n            # sum_{s,k} [ 2s*k + k(k - 1) ]\n            # So, total sum is 2s*k + k(k-1)\n            # Let's compute each part separately\n            # First part: sum_{s,k} 2s*k\n            # = 2 * sum_{s=0 to m-1} s * sum_{k=1 to m - s} k\n            # sum_{k=1 to t} k = t(t+1)/2, where t = m - s\n            # So, first part becomes 2 * sum_{s=0 to m-1} s * ( (m - s)(m - s + 1) ) / 2\n            # Simplify: sum_{s=0 to m-1} s * (m - s)(m - s + 1)\n            # Let t = m - s, s = m - t\n            # When s=0, t=m; s=m-1, t=1\n            # So, sum becomes sum_{t=1 to m} (m - t) * t * (t + 1)\n            # = sum_{t=1 to m} (m t (t + 1) - t^2 (t + 1))\n            # = m sum t(t+1) - sum t^2(t+1)\n            # Compute sum t(t+1) from 1 to m:\n            # t(t+1) = t^2 + t\n            # sum = sum t^2 + sum t = m(m+1)(2m+1)/6 + m(m+1)/2 = m(m+1)(m+2)/3\n            # Compute sum t^2(t+1) = sum t^3 + t^2\n            # sum t^3 = [m(m+1)/2]^2\n            # sum t^2 = m(m+1)(2m+1)/6\n            # So, sum t^2(t+1) = [m^2(m+1)^2 / 4] + [m(m+1)(2m+1)/6]\n            # Putting it all together:\n            # first_part = m * [m(m+1)(m+2)/3] - [m^2(m+1)^2 /4 + m(m+1)(2m+1)/6]\n            # This seems complicated, but perhaps there's a simpler way\n            # Alternatively, perhaps we can find a formula for the sum\n            # Let's compute sum_{s=0 to m-1} s*(m - s)(m - s + 1)\n            # Let's expand (m - s)(m - s + 1) = (m - s)(m - s + 1) = (m - s)(m - s) + (m - s) = (m - s)^2 + (m - s)\n            # So, s*(m - s)^2 + s*(m - s)\n            # So, sum becomes sum s(m - s)^2 + sum s(m - s)\n            # Let's compute each term\n            # sum s(m - s)^2 from s=0 to m-1\n            # Let t = m - s, s = m - t\n            # When s=0, t=m; s=m-1, t=1\n            # So, sum becomes sum_{t=1 to m} (m - t) * t^2\n            # = sum_{t=1 to m} m t^2 - t^3\n            # = m * sum t^2 - sum t^3\n            # = m * [m(m+1)(2m+1)/6] - [ (m(m+1)/2 )^2 ]\n            # Similarly, sum s(m - s) from s=0 to m-1\n            # Again, t = m - s\n            # sum (m - t) * t = sum m t - t^2\n            # = m * sum t - sum t^2\n            # = m * [m(m+1)/2] - [m(m+1)(2m+1)/6]\n            # So, putting it all together:\n            sum_s_k = 0\n            # Compute first part: sum_{s,k} 2s*k\n            # Which is 2 * sum_{s=0 to m-1} s * sum_{k=1 to m - s} k\n            # sum_{k=1 to t} k = t(t+1)/2, t = m - s\n            # So, sum_{s} s * t(t+1)/2, t = m - s\n            # So, sum_s_k_part1 = sum_{s=0 to m-1} s * (m - s)(m - s + 1)/2\n            # Which is sum_{s=0 to m-1} [s (m - s)(m - s + 1)] / 2\n            # As computed earlier, this is a complex expression, but perhaps we can find a formula\n            # Alternatively, perhaps we can compute it using known summation formulas\n            # Let's compute sum_{s=0 to m-1} s (m - s)(m - s + 1)\n            # Let's expand (m - s)(m - s + 1) = (m - s)(m - s) + (m - s) = (m - s)^2 + (m - s)\n            # So, s*(m - s)^2 + s*(m - s)\n            # So, sum becomes sum s(m - s)^2 + sum s(m - s)\n            # As before, let's compute each part\n            # Compute sum s(m - s)^2:\n            # Let t = m - s, s = m - t\n            # sum_{s=0 to m-1} s t^2 = sum_{t=1 to m} (m - t) t^2\n            # = m sum t^2 - sum t^3\n            # = m [m(m+1)(2m+1)/6] - [ (m(m+1)/2 )^2 ]\n            sum_t_sq = m * (m + 1) * (2 * m + 1) // 6\n            sum_t_cu = (m * (m + 1) // 2) ** 2\n            part1 = m * sum_t_sq - sum_t_cu\n            # Compute sum s(m - s):\n            # sum_{s=0 to m-1} s (m - s) = sum_{s=0 to m-1} (m s - s^2)\n            # = m sum s - sum s^2\n            sum_s = m * (m - 1) // 2\n            sum_s_sq = (m - 1) * m * (2 * m - 1) // 6\n            part2 = m * sum_s - sum_s_sq\n            # So, sum s(m - s)(m - s + 1) = part1 + part2\n            sum_s_k_part1 = (part1 + part2) // 2  # Because the first part is multiplied by 1/2\n            # Now compute the second part: sum_{s,k} k(k - 1)\n            # Which is sum_{s=0 to m-1} sum_{k=1 to m - s} k(k - 1)\n            # k(k - 1) = k^2 - k\n            # So, sum_{k=1 to t} k(k - 1) = sum k^2 - sum k = [t(t+1)(2t+1)/6] - [t(t+1)/2]\n            # = t(t+1)(2t+1 - 3)/6 = t(t+1)(2t - 2)/6 = t(t+1)(t - 1)/3\n            # So, for each s, t = m - s\n            # sum_{k=1 to t} k(k-1) = t(t+1)(t - 1)/3\n            # So, sum_{s=0 to m-1} t(t+1)(t - 1)/3, where t = m - s\n            # t ranges from m down to 1 as s increases from 0 to m-1\n            # So, sum becomes sum_{t=1 to m} t(t+1)(t - 1)/3\n            # = (1/3) sum_{t=1 to m} t(t^2 - 1)\n            # = (1/3) sum (t^3 - t)\n            # = (1/3) [ sum t^3 - sum t ]\n            sum_t_cu = (m * (m + 1) // 2) ** 2\n            sum_t = m * (m + 1) // 2\n            sum_s_k_part2 = (sum_t_cu - sum_t) // 3\n            # So, the total sum (e - s + 1)(s + e) is sum_s_k_part1 + sum_s_k_part2\n            sum_e_s_plus_1_s_e = sum_s_k_part1 + sum_s_k_part2\n            # Now, putting it all together\n            total_contribution = (2 * a * sum_e_s_plus_1 + d * sum_e_s_plus_1_s_e) // 2\n            total += total_contribution\n            # Move to the next position after the consecutive sequence\n            i = j\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_length = 1\n        dec_length = 1\n        inc_sum = nums[0]\n        dec_sum = nums[0]\n        total += inc_sum  # Single element is counted once\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1] + 1:\n                inc_length += 1\n                inc_sum = inc_sum + nums[i] * inc_length - (nums[i] - (nums[i] - 1)) * (inc_length - 1) // 2\n                dec_length = 1\n                dec_sum = nums[i]\n            elif nums[i] == nums[i-1] - 1:\n                dec_length += 1\n                dec_sum = dec_sum + nums[i] * dec_length - (nums[i] + (nums[i] + 1)) * (dec_length - 1) // 2\n                inc_length = 1\n                inc_sum = nums[i]\n            else:\n                inc_length = 1\n                dec_length = 1\n                inc_sum = nums[i]\n                dec_sum = nums[i]\n            total += inc_sum + dec_sum\n            total %= MOD\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_length = 1\n        dec_length = 1\n        inc_sum = nums[0]\n        dec_sum = nums[0]\n        total += inc_sum  # Single element is counted once\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1] + 1:\n                inc_length += 1\n                inc_sum = inc_sum + nums[i] * inc_length - (nums[i] - (nums[i] - 1)) * (inc_length - 1) // 2\n                dec_length = 1\n                dec_sum = nums[i]\n            elif nums[i] == nums[i-1] - 1:\n                dec_length += 1\n                dec_sum = dec_sum + nums[i] * dec_length - (nums[i] + (nums[i] + 1)) * (dec_length - 1) // 2\n                inc_length = 1\n                inc_sum = nums[i]\n            else:\n                inc_length = 1\n                dec_length = 1\n                inc_sum = nums[i]\n                dec_sum = nums[i]\n            total += inc_sum + dec_sum\n            total %= MOD\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_length = 1\n        inc_sum = nums[0]\n        dec_length = 1\n        dec_sum = nums[0]\n        total = inc_sum\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1] + 1:\n                inc_length += 1\n                inc_sum = inc_sum + nums[i] * inc_length - (nums[i] - (nums[i-1] + 1)) * (inc_length - 1)\n                dec_length = 1\n                dec_sum = nums[i]\n            elif nums[i] == nums[i-1] - 1:\n                dec_length += 1\n                dec_sum = dec_sum + nums[i] * dec_length - (nums[i] + (nums[i-1] - 1)) * (dec_length - 1)\n                inc_length = 1\n                inc_sum = nums[i]\n            else:\n                inc_length = 1\n                inc_sum = nums[i]\n                dec_length = 1\n                dec_sum = nums[i]\n            total += inc_sum + dec_sum - nums[i]\n            total %= MOD\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        current_length = 1\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                if direction == 1:\n                    current_length += 1\n                else:\n                    current_length = 2\n                    direction = 1\n                current_sum = current_sum + nums[i] * current_length - (nums[i] - (nums[i] - 1)) * (current_length - 1) // 2\n            elif diff == -1:\n                if direction == -1:\n                    current_length += 1\n                else:\n                    current_length = 2\n                    direction = -1\n                current_sum = current_sum + nums[i] * current_length - (nums[i] + (nums[i] + 1)) * (current_length - 1) // 2\n            else:\n                # Add the sum of all subarrays in the current sequence\n                if direction != 0:\n                    total += current_sum\n                current_sum = nums[i]\n                current_length = 1\n                direction = 0\n            # Add the single element if it's the start of a new sequence\n            if direction == 0:\n                total += nums[i]\n                total %= MOD\n        # Add the last sequence\n        if direction != 0:\n            total += current_sum\n        # Add all single elements\n        total += sum(nums)\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = nums[0]\n        total += current_sum\n        prev = nums[0]\n        # We need to track the direction of the consecutive sequence\n        # 1 for increasing, -1 for decreasing, 0 for single element\n        direction = 0\n        for i in range(1, n):\n            diff = nums[i] - prev\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    current_sum += nums[i]\n                else:\n                    if diff == direction:\n                        current_sum += nums[i]\n                    else:\n                        # Direction changed, so the previous window ends here\n                        # Start a new window with the last two elements\n                        current_sum = prev + nums[i]\n                        direction = diff\n                total = (total + current_sum) % MOD\n            else:\n                # Not consecutive, reset\n                current_sum = nums[i]\n                direction = 0\n                total = (total + current_sum) % MOD\n            prev = nums[i]\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = inc_sum + dec_sum - nums[0]  # Subtract nums[0] to avoid double-counting\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            inc_len, inc_sum = new_inc_len, new_inc_sum\n            dec_len, dec_sum = new_dec_len, new_dec_sum\n            \n            contribution = inc_sum + dec_sum - current\n            total = (total + contribution) % MOD\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = inc_sum\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            \n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            inc_len, inc_sum = new_inc_len, new_inc_sum\n            dec_len, dec_sum = new_dec_len, new_dec_sum\n            \n            contribution = inc_sum + dec_sum - current\n            total = (total + contribution) % MOD\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = nums[0]  # Start with the first element\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            # Calculate contribution without double-counting the current element\n            contribution = new_inc_sum + new_dec_sum - current\n            total = (total + contribution) % MOD\n            \n            # Update for next iteration\n            inc_len, inc_sum = new_inc_len, new_inc_sum\n            dec_len, dec_sum = new_dec_len, new_dec_sum\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = inc_sum  # Only add once since it's the same as dec_sum\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            # Calculate the contribution for all possible subarrays ending at i\n            # For increasing subarrays\n            if diff == 1:\n                contribution_inc = (new_inc_sum - (nums[i] * (new_inc_len - 1))) \n                # The sum of all subarrays ending here with increasing\n                # This is sum_{k=1 to new_inc_len} (sum of last k elements)\n                # Which is equal to new_inc_sum + (new_inc_sum - nums[i]) + ... \n                # But a smarter way is to realize that each new element adds (current * k) where k is the length\n                # Alternatively, the sum can be calculated as (current * (new_inc_len)) + (sum of previous subarrays)\n                # However, to avoid complexity, we can compute the sum of all possible subarrays ending here\n                # For an increasing subarray of length L, the number of subarrays is L, each of length 1 to L\n                # The sum for each is the sum of the last k elements for k=1 to L\n                # This can be computed as current * L + (current -1) * (L-1) + ... + (current - L +1) * 1\n                # But this is complex, so instead, we can track the sum incrementally\n                # The sum for all subarrays ending at i for increasing is the sum of the current subarray plus the sum of all subarrays ending at i-1 for increasing\n                # Wait, no. Because each new element extends the subarrays.\n                # For example, if the current subarray is of length 3, then the new subarrays are [current], [prev, current], [prev_prev, prev, current]\n                # Their sums are current, prev+current, prev_prev+prev+current\n                # So the total contribution is sum of these, which is (current) + (prev + current) + (prev_prev + prev + current) = 3*current + 2*prev + prev_prev\n                # Alternatively, the sum can be calculated as (current * new_inc_len) + (sum of previous elements multiplied by their respective counts)\n                # To avoid recalculating, we can track the sum of all possible subarrays ending at i for increasing and decreasing separately\n                # Let's define inc_subarrays_sum as the sum of all subarrays ending at i for increasing\n                # Similarly for dec_subarrays_sum\n                # Then, for each i, if the current subarray is increasing, inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                # Wait, perhaps a better approach is to track for each position, the sum of all subarrays ending there for increasing and decreasing\n                # Let me think differently: for each i, the number of consecutive subarrays ending at i is equal to the length of the current consecutive sequence\n                # For example, if the current increasing subarray is of length 3, then there are 3 subarrays ending at i: [i], [i-1,i], [i-2,i-1,i]\n                # The sum of these is sum_{k=1 to 3} sum(nums[i-k+1..i])\n                # To compute this efficiently, we can track the sum incrementally\n                # Let's define inc_subarrays_sum as the sum of all subarrays ending at i for increasing\n                # When the current element continues the increasing sequence, inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                # Similarly for decreasing\n                # So, in the code, we need to track inc_subarrays_sum and dec_subarrays_sum\n                # Initialize them as 0, and for each i, compute based on the previous values\n                # Let's adjust the code accordingly\n                # So, in the initial code, we have inc_len and inc_sum, but we need to track the sum of all subarrays ending at i for increasing\n                # Let's redefine inc_subarrays_sum as the sum of all subarrays ending at i for increasing\n                # Similarly for dec_subarrays_sum\n                # So, for each i:\n                # if diff == 1:\n                #     inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                # elif diff == -1:\n                #     dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                # else:\n                #     inc_subarrays_sum = current\n                #     dec_subarrays_sum = current\n                # Then, the contribution is inc_subarrays_sum + dec_subarrays_sum\n                # But wait, for the case where the current element is part of both increasing and decreasing? No, because the difference can't be both 1 and -1\n                # So, in the code, we need to track inc_subarrays_sum and dec_subarrays_sum\n                # Let's adjust the variables:\n                # inc_subarrays_sum: sum of all increasing consecutive subarrays ending at i\n                # dec_subarrays_sum: sum of all decreasing consecutive subarrays ending at i\n                # For each i:\n                # if diff == 1:\n                #     inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                #     dec_subarrays_sum = current  # because the current element can start a new decreasing subarray\n                # elif diff == -1:\n                #     dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                #     inc_subarrays_sum = current  # because the current element can start a new increasing subarray\n                # else:\n                #     inc_subarrays_sum = current\n                #     dec_subarrays_sum = current\n                # Then, the contribution is inc_subarrays_sum + dec_subarrays_sum\n                # But wait, in the case where the current element is part of neither, we still have to count the single element subarray\n                # So, in all cases, the contribution is inc_subarrays_sum + dec_subarrays_sum - current (since the single element is counted in both)\n                # Because when diff is neither 1 nor -1, both inc_subarrays_sum and dec_subarrays_sum are current, so their sum is 2*current, but we should only count it once\n                # So, the contribution is (inc_subarrays_sum + dec_subarrays_sum - current)\n                # Let's test this logic with example 1:\n                # Example 1: [1,2,3]\n                # i=0: inc_subarrays_sum=1, dec_subarrays_sum=1, contribution=1+1-1=1\n                # total=1\n                # i=1: diff=1\n                # new_inc_len=2, new_inc_sum=1+2=3\n                # inc_subarrays_sum = 1 (prev inc_subarrays_sum) + 2*2 = 1+4=5\n                # dec_subarrays_sum = 2\n                # contribution=5+2-2=5\n                # total=1+5=6\n                # i=2: diff=1\n                # new_inc_len=3, new_inc_sum=3+3=6\n                # inc_subarrays_sum =5 (prev inc_subarrays_sum) +3*3=5+9=14\n                # dec_subarrays_sum=3\n                # contribution=14+3-3=14\n                # total=6+14=20\n                # Which matches the expected output\n                # Another test case: example 3: [7,6,1,2]\n                # i=0: contribution=7\n                # i=1: diff=-1\n                # dec_subarrays_sum =0 +6*2=12 (assuming initial dec_subarrays_sum is 0)\n                # Wait, perhaps the initial values need to be set correctly\n                # Let's adjust the initial setup:\n                # At i=0, inc_subarrays_sum = nums[0], dec_subarrays_sum = nums[0]\n                # contribution = nums[0] + nums[0] - nums[0] = nums[0]\n                # So, initial total is nums[0]\n                # For i=1:\n                # diff =6-7=-1\n                # So, dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                # dec_subarrays_sum_prev is 7, new_dec_len is 2\n                # So dec_subarrays_sum =7 +6*2=19\n                # inc_subarrays_sum is set to current=6\n                # contribution=19 +6 -6=19\n                # total=7+19=26\n                # i=2: current=1, prev=6, diff=-5\n                # So, neither increasing nor decreasing\n                # inc_subarrays_sum=1, dec_subarrays_sum=1\n                # contribution=1+1-1=1\n                # total=26+1=27\n                # i=3: current=2, prev=1, diff=1\n                # So, inc_subarrays_sum = inc_subarrays_sum_prev (1) +2*2=1+4=5\n                # dec_subarrays_sum=2\n                # contribution=5+2-2=5\n                # total=27+5=32\n                # Which matches example 3's expected output\n                # So, the logic seems correct\n                # Now, let's adjust the code accordingly\n                # We'll track inc_subarrays_sum and dec_subarrays_sum\n                # Initialize them as nums[0]\n                # For each i from 1 to n-1:\n                # compute diff\n                # if diff ==1:\n                #     new_inc_len = inc_len +1\n                #     new_inc_sum = inc_sum + current\n                #     inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                #     dec_subarrays_sum = current\n                # elif diff ==-1:\n                #     new_dec_len = dec_len +1\n                #     new_dec_sum = dec_sum + current\n                #     dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                #     inc_subarrays_sum = current\n                # else:\n                #     inc_subarrays_sum = current\n                #     dec_subarrays_sum = current\n                # contribution = inc_subarrays_sum + dec_subarrays_sum - current\n                # total += contribution\n                # Also, update inc_len, inc_sum, dec_len, dec_sum accordingly\n                # So, in code:\n                # Initialize:\n                inc_subarrays_sum = nums[0]\n                dec_subarrays_sum = nums[0]\n                total = inc_subarrays_sum  # since contribution is nums[0]\n                \n                for i in range(1, n):\n                    current = nums[i]\n                    prev = nums[i-1]\n                    diff = current - prev\n                    new_inc_len = 1\n                    new_inc_sum = current\n                    new_dec_len = 1\n                    new_dec_sum = current\n                    \n                    if diff == 1:\n                        new_inc_len = inc_len + 1\n                        new_inc_sum = inc_sum + current\n                        inc_subarrays_sum = inc_subarrays_sum + current * new_inc_len\n                        dec_subarrays_sum = current\n                    elif diff == -1:\n                        new_dec_len = dec_len + 1\n                        new_dec_sum = dec_sum + current\n                        dec_subarrays_sum = dec_subarrays_sum + current * new_dec_len\n                        inc_subarrays_sum = current\n                    else:\n                        inc_subarrays_sum = current\n                        dec_subarrays_sum = current\n                    \n                    contribution = inc_subarrays_sum + dec_subarrays_sum - current\n                    total = (total + contribution) % MOD\n                    \n                    # Update the lengths and sums for next iteration\n                    if diff == 1:\n                        inc_len = new_inc_len\n                        inc_sum = new_inc_sum\n                    elif diff == -1:\n                        dec_len = new_dec_len\n                        dec_sum = new_dec_sum\n                    else:\n                        inc_len = 1\n                        inc_sum = current\n                        dec_len = 1\n                        dec_sum = current\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    start = i-1\n                else:\n                    if diff != direction:\n                        # Direction changed, calculate all subarrays up to i-1\n                        length = i - start\n                        sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence with i-1 and i\n                        start = i-1\n                        direction = diff\n                # Add the current element as a single element\n                total += nums[i]\n            else:\n                # Not consecutive, calculate all subarrays up to i-1\n                if direction != 0:\n                    length = i - start\n                    sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n                # Add the current element\n                total += nums[i]\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            diff = nums[1] - nums[0] if n > 1 else 0\n            sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            current_diff = nums[i] - nums[i-1]\n            if current_diff == 1 or current_diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = current_diff\n                    start = i-1\n                else:\n                    if current_diff != direction:\n                        # Direction changed, calculate all subarrays up to i-1\n                        length = i - start\n                        # Calculate sum of all subarrays in this sequence\n                        sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence with i-1 and i\n                        start = i-1\n                        direction = current_diff\n            else:\n                # Not consecutive, calculate all subarrays up to i-1\n                if direction != 0:\n                    length = i - start\n                    sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n            # Add the current element as a single element\n            total += nums[i]\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    direction = diff\n                    start = i-1\n                else:\n                    if diff != direction:\n                        # End of current sequence, calculate all subarrays\n                        length = i - start\n                        sum_subarrays = (nums[start] * length * (length + 1) // 2) + (diff_prev // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence\n                        start = i-1\n                        direction = diff\n                        # Add the current element as a single element\n                        total += nums[i]\n                        continue\n                # Continue the current sequence\n                # Add all possible subarrays ending at i\n                current_length = i - start + 1\n                sum_subarrays = (nums[start] * current_length) + (diff // 2) * (current_length * (current_length - 1))\n                total += sum_subarrays\n            else:\n                # End of current sequence, calculate all subarrays\n                if direction != 0:\n                    length = i - start\n                    sum_subarrays = (nums[start] * length * (length + 1) // 2) + (diff_prev // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n                # Add the current element\n                total += nums[i]\n            # Update previous difference\n            diff_prev = diff\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            sum_subarrays = (nums[start] * length * (length + 1) // 2) + (diff_prev // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: list[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    direction = diff\n                    start = i-1\n                else:\n                    if diff != direction:\n                        # End of current consecutive sequence\n                        length = i - start\n                        sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence\n                        start = i-1\n                        direction = diff\n            else:\n                if direction != 0:\n                    # End of current consecutive sequence\n                    length = i - start\n                    sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n            # Add the current element as a single element\n            total += nums[i]\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        start = 0\n        direction = 0  # 1 for increasing, -1 for decreasing, 0 for single element\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                total += current_sum\n                direction = 0\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    start = i-1\n                    current_sum = nums[start] + nums[i]\n                    total += current_sum\n                else:\n                    if diff == direction:\n                        # Continue the current sequence\n                        current_sum += nums[i]\n                        total += current_sum\n                    else:\n                        # Direction changed, start new sequence with last two elements\n                        direction = diff\n                        start = i-1\n                        current_sum = nums[start] + nums[i]\n                        total += current_sum\n            else:\n                # Not consecutive, reset\n                direction = 0\n                start = i\n                current_sum = nums[i]\n                total += current_sum\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        \n        for i in range(n):\n            # Each single element is a consecutive subarray\n            total += nums[i]\n            # Check for consecutive subarrays starting at i\n            if i == n - 1:\n                continue\n            # Determine the direction\n            direction = nums[i+1] - nums[i]\n            if direction not in (1, -1):\n                continue\n            # Now, check how far this consecutive sequence extends\n            current_sum = nums[i] + nums[i+1]\n            total += current_sum\n            j = i + 2\n            while j < n:\n                if nums[j] - nums[j-1] == direction:\n                    current_sum += nums[j]\n                    total += current_sum\n                    j += 1\n                else:\n                    break\n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        prev_diff = 0\n        current_length = 1\n        current_sum = nums[0]\n        total += current_sum\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if diff == prev_diff or prev_diff == 0:\n                    current_length += 1\n                    current_sum += nums[i]\n                else:\n                    current_length = 2\n                    current_sum = nums[i-1] + nums[i]\n                prev_diff = diff\n            else:\n                prev_diff = 0\n                current_length = 1\n                current_sum = nums[i]\n            \n            total += current_sum\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        start = 0\n        direction = 0  # 1 for increasing, -1 for decreasing, 0 for single element\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                total += current_sum\n                direction = 0\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    current_sum = nums[i-1] + nums[i]\n                    total += current_sum\n                else:\n                    if diff == direction:\n                        # Continue the current sequence\n                        current_sum += nums[i]\n                        total += current_sum\n                    else:\n                        # Direction changed, start new sequence with last two elements\n                        direction = diff\n                        current_sum = nums[i-1] + nums[i]\n                        total += current_sum\n            else:\n                # Not consecutive, reset\n                direction = 0\n                current_sum = nums[i]\n                total += current_sum\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total += current_sum\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == 0 or direction == new_direction:\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start new subarrays\n                for j in range(current_start, i):\n                    total += sum(nums[j:i])\n                current_start = i\n                direction = 0\n            else:\n                if direction == 0:\n                    direction = new_direction\n                elif direction != new_direction:\n                    # End previous subarrays and start new\n                    for j in range(current_start, i-1):\n                        total += sum(nums[j:i])\n                    current_start = i-1\n                    direction = new_direction\n                # Add the current subarray\n                total += sum(nums[current_start:i])\n        \n        # Add all subarrays ending at the last element\n        for j in range(current_start, n):\n            total += sum(nums[j:n])\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        prev_diff = None\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total += current_sum\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if prev_diff is None:\n                    prev_diff = diff\n                    current_sum += nums[i]\n                    current_length += 1\n                else:\n                    if diff == prev_diff:\n                        current_sum += nums[i]\n                        current_length += 1\n                    else:\n                        # Direction changed, reset\n                        current_sum = nums[i-1] + nums[i]\n                        current_length = 2\n                        prev_diff = diff\n            else:\n                # Not consecutive, reset\n                current_sum = nums[i]\n                current_length = 1\n                prev_diff = None\n            \n            # Add the sum of all subarrays ending at i\n            # The number of subarrays is current_length\n            # The sum is current_sum\n            total += current_sum\n            total %= MOD\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Calculate sum for all subarrays ending at i-1\n                length = i - current_start\n                if length > 1:\n                    total += nums[current_start] * length + (length - 1) * length // 2 * (nums[i-1] - nums[current_start]) // (length - 1)\n                else:\n                    total += nums[current_start]\n                current_start = i\n                direction = 0\n            else:\n                if direction == 0:\n                    direction = new_direction\n                elif direction != new_direction:\n                    # End previous run and start new\n                    length = i - current_start\n                    if length > 1:\n                        total += nums[current_start] * length + (length - 1) * length // 2 * (nums[i-1] - nums[current_start]) // (length - 1)\n                    else:\n                        total += nums[current_start]\n                    current_start = i - 1\n                    direction = new_direction\n                # Add the current subarray\n                length = i - current_start + 1\n                if length > 1:\n                    total += nums[current_start] * length + (length - 1) * length // 2 * (nums[i] - nums[current_start]) // (length - 1)\n                else:\n                    total += nums[current_start]\n        \n        # Add all subarrays from current_start to end\n        length = n - current_start\n        if length > 1:\n            total += nums[current_start] * length + (length - 1) * length // 2 * (nums[-1] - nums[current_start]) // (length - 1)\n        else:\n            total += nums[current_start]\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = nums[0]\n        current_sum = nums[0]\n        prev_diff = 0  # 0: single element, 1: increasing, -1: decreasing\n        length = 1\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if diff == prev_diff or prev_diff == 0:\n                    # Continue the current consecutive sequence\n                    current_sum += nums[i] + (nums[i] - nums[i-1]) * (length)\n                    length += 1\n                else:\n                    # Change in direction, reset\n                    current_sum = nums[i-1] + nums[i]\n                    length = 2\n                prev_diff = diff\n            else:\n                # Not consecutive, reset\n                current_sum = nums[i]\n                length = 1\n                prev_diff = 0\n            \n            total += current_sum\n            total %= MOD\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current trend or starting a new trend\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change in direction, reset the current subarray\n                    # The new subarray starts from the previous element\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        prev_diff = None  # None indicates start\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                prev_diff = 0  # 0 represents no previous difference\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_diff = 1\n            elif diff == -1:\n                new_diff = -1\n            else:\n                new_diff = 0  # Not consecutive\n            \n            if new_diff == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                prev_diff = 0\n            else:\n                if prev_diff == new_diff or prev_diff == 0:\n                    # Continue the current trend or starting a new trend\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    prev_diff = new_diff\n                else:\n                    # Change in direction, reset the current subarray\n                    # The new subarray starts from the previous element\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    prev_diff = new_diff\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current trend or starting a new trend\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change in direction, reset the current subarray\n                    # The new subarray starts from the previous element\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        start = 0\n        direction = 0  # 0: not set, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if i == 1:\n                direction = new_direction\n                current_sum += nums[i]\n                total = (total + current_sum) % MOD\n            else:\n                if new_direction == 0:\n                    # Start new subarray\n                    start = i\n                    current_sum = nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = 0\n                else:\n                    if new_direction == direction:\n                        # Continue the trend\n                        current_sum += nums[i]\n                        total = (total + current_sum) % MOD\n                    else:\n                        # Change in direction, reset start to i-1\n                        start = i - 1\n                        current_sum = nums[start] + nums[i]\n                        total = (total + current_sum) % MOD\n                        direction = new_direction\n            direction = new_direction\n        \n        return total % MOD"
  ],
  "total_candidates": 36,
  "nodes_explored": 36,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        prev = nums[0]\n        current_length = 1\n        total += prev\n        for i in range(1, n):\n            if nums[i] == prev + 1 or nums[i] == prev - 1:\n                current_length += 1\n                current_sum = current_sum + nums[i] * current_length - (nums[i] - (nums[i] - prev)) * (current_length - 1) // 2\n                total += current_sum\n            else:\n                current_length = 1\n                current_sum = nums[i]\n                total += current_sum\n            prev = nums[i]\n        return total % MOD",
      "solution_hash": "25080477d97856b0d70230f37d24f8a67328392b11e5cc78df45895951616b7c",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpf932thn5.py\", line 239, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpf932thn5.py\", line 106, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
        "execution_time": 0.06686830520629883
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_1",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        for i in range(n):\n            # Each single element is a consecutive subarray\n            total += nums[i]\n            # Check for subarrays starting at i\n            for j in range(i + 1, n):\n                # Determine the direction\n                if j == i + 1:\n                    diff = nums[j] - nums[j - 1]\n                    if diff not in (1, -1):\n                        break\n                    current_diff = diff\n                else:\n                    new_diff = nums[j] - nums[j - 1]\n                    if new_diff != current_diff:\n                        break\n                # Calculate the sum of nums[i..j]\n                sub_sum = sum(nums[i:j+1])\n                total += sub_sum\n                total %= MOD\n        return total % MOD",
          "solution_hash": "363e06a4b9d1a7d9567889cc45f4cf70bc3d2299cfaddf319b49eb51e5880d61",
          "test_result": {
            "status": "pass",
            "execution_time": 0.07085180282592773
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_2",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_length = 1\n        for i in range(1, n):\n            if (nums[i] == nums[i-1] + 1) or (nums[i] == nums[i-1] - 1):\n                current_length += 1\n            else:\n                # Calculate the sum of all subarrays in the current consecutive sequence\n                k = current_length\n                sum_subarrays = (k * (k + 1) // 2) * (nums[i - current_length] + nums[i - 1]) // 2\n                total += sum_subarrays\n                current_length = 1\n        # Add the sum for the last consecutive sequence\n        k = current_length\n        sum_subarrays = (k * (k + 1) // 2) * (nums[-k] + nums[-1]) // 2\n        total += sum_subarrays\n        return total % MOD",
          "solution_hash": "c6af6db5a6ccd82d5e56a90388b6ce826e45f3a9b39063fc8079639a3694feb7",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp1t4uxwd7.py\", line 239, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp1t4uxwd7.py\", line 106, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06822013854980469
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_3",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_length = 1\n        for i in range(1, n):\n            if (nums[i] == nums[i-1] + 1) or (nums[i] == nums[i-1] - 1):\n                current_length += 1\n            else:\n                # Calculate the sum of all consecutive subarrays ending at i-1\n                k = current_length\n                # The number of subarrays is k, each of length 1 to k\n                # Sum of elements for each subarray can be computed as sum of arithmetic series\n                # Sum of elements from start to end is (start + end) * length / 2\n                # For each possible subarray length l (1<=l<=k), the sum is (nums[i-l] + nums[i-1]) * l / 2\n                # The total sum for all subarrays is sum_{l=1 to k} (nums[i-l] + nums[i-1]) * l / 2\n                # This can be simplified as (nums[i-1] * (k*(k+1)/2) + nums[i-k] * (k*(k+1)/2)) / 2\n                # Wait, no, that's not correct. Because for each l, the starting element is nums[i-l], and the sum is (nums[i-l] + nums[i-1]) * l / 2\n                # So the total sum is sum_{l=1 to k} (nums[i-l] + nums[i-1]) * l / 2\n                # Which is equal to (sum_{l=1 to k} (nums[i-l] * l) + nums[i-1] * sum_{l=1 to k} l) ) / 2\n                # But this approach is O(n^2), which is not feasible for n=1e5\n                # So we need a more efficient way\n                # Let's think differently: for each position, find the maximum possible consecutive subarray ending there\n                # Then, for each such subarray of length l, the sum is sum of the subarray\n                # But calculating this for each l is O(n^2), which is too slow\n                # So we need a way to compute the sum of all consecutive subarrays in O(n) time\n                # Let's think about the properties of consecutive arrays\n                # For a consecutive array, the difference between consecutive elements is either +1 or -1\n                # So, for a consecutive subarray of length l, the sum can be expressed as l * a_1 + (l*(l-1))/2 * d, where d is the common difference\n                # But since d can be +1 or -1, we can model this\n                # However, this might complicate things\n                # Another approach: for each position i, find the maximum possible consecutive subarray ending at i, and keep track of the sum of all such subarrays\n                # Let's define two variables: increasing and decreasing\n                # increasing[i] is the length of the longest consecutive increasing subarray ending at i\n                # Similarly for decreasing\n                # Then, for each i, the number of consecutive subarrays ending at i is increasing[i] + decreasing[i] - 1 (since the single element is counted in both)\n                # But wait, no. Because a subarray can be either increasing or decreasing, but not both unless it's length 1\n                # So for each i, the number of consecutive subarrays ending at i is the number of increasing subarrays ending at i plus the number of decreasing subarrays ending at i\n                # But how to compute the sum of their values efficiently\n                # Let's think of it this way: for each i, we can track the current run's direction and length\n                # For example, if the current run is increasing, then the sum of all subarrays ending at i is the sum of the previous run's sum plus the current element multiplied by the current run's length\n                # Wait, perhaps we can model it with dynamic programming\n                # Let's define for each i:\n                # inc[i]: the length of the longest consecutive increasing subarray ending at i\n                # dec[i]: the length of the longest consecutive decreasing subarray ending at i\n                # Then, for each i, the number of consecutive subarrays ending at i is inc[i] + dec[i] - 1 (since the single element is counted in both)\n                # But we need the sum of their values, not just the count\n                # So, we need to track not just the lengths but also the sum of the subarrays\n                # Let's define:\n                # inc_sum[i]: the sum of all consecutive increasing subarrays ending at i\n                # dec_sum[i]: the sum of all consecutive decreasing subarrays ending at i\n                # Then, the total sum is the sum of inc_sum[i] + dec_sum[i] for all i\n                # Now, how to compute inc_sum and dec_sum\n                # For inc_sum[i]:\n                # If nums[i] == nums[i-1] + 1, then inc[i] = inc[i-1] + 1\n                # And inc_sum[i] = inc_sum[i-1] + nums[i] * inc[i]\n                # Similarly for dec_sum[i]\n                # Wait, let's think:\n                # When the current element continues an increasing sequence, the new subarrays are all the subarrays that end at i-1 extended by i, plus the subarray containing only i\n                # So, for example, if inc[i-1] is 2, meaning the subarrays [i-2, i-1] and [i-1], then adding i, we get [i-2, i-1, i], [i-1, i], and [i]\n                # The sum for these new subarrays is sum([i-2,i-1,i]) + sum([i-1,i]) + sum([i])\n                # Which is equal to sum([i-2,i-1]) + i * 3 (since each new subarray includes i)\n                # Wait, perhaps a better way is to model inc_sum[i] as the sum of all increasing consecutive subarrays ending at i\n                # So, if the current element continues the increasing sequence, then inc_sum[i] = inc_sum[i-1] + nums[i] * inc[i]\n                # Because each of the inc[i] subarrays ending at i includes nums[i], and there are inc[i] such subarrays\n                # Similarly for dec_sum[i]\n                # Let's test this with an example:\n                # Example 1: nums = [1,2,3]\n                # i=0: inc[0]=1, inc_sum[0]=1\n                # i=1: nums[1] = nums[0]+1, so inc[1]=2, inc_sum[1] = inc_sum[0] + 2*2 = 1 + 4 =5\n                # i=2: nums[2] = nums[1]+1, inc[2]=3, inc_sum[2] =5 +3*3=14\n                # dec_sum remains 0 for all\n                # Total sum is 14 + 0 =14, but the correct answer is 20\n                # Wait, this approach is missing the decreasing subarrays and also the single elements\n                # Because each single element is both increasing and decreasing\n                # So, perhaps we need to consider that each element contributes to both inc_sum and dec_sum, but we have to avoid double-counting\n                # Alternatively, perhaps the initial approach is not sufficient, and we need a different method\n                # Let's think differently: for each position, determine the maximum possible consecutive subarray ending there, and for each possible length l (from 1 to max_length), compute the sum of the subarray of length l ending at i, and add it to the total\n                # But for n=1e5, this would be O(n^2), which is too slow\n                # So we need a way to compute this in O(n) time\n                # Let's think about the properties of consecutive subarrays\n                # A consecutive subarray can be either increasing or decreasing\n                # For an increasing subarray of length l, the elements are a, a+1, a+2, ..., a+l-1\n                # The sum is l*a + l*(l-1)/2\n                # Similarly, for a decreasing subarray, the sum is l*a - l*(l-1)/2\n                # So, for each position i, if we know whether the current subarray is increasing or decreasing, and its length, we can compute the sum of all subarrays ending at i\n                # Let's try to model this\n                # We'll keep track of the current run's type (increasing, decreasing, or single) and its length\n                # For each i, we check if nums[i] - nums[i-1] is 1 or -1\n                # If it's 1, then the current run is increasing\n                # If it's -1, then the current run is decreasing\n                # Else, the run is broken, and we start a new run\n                # For each run, we can compute the sum of all possible subarrays within it\n                # For example, in an increasing run of length l, the number of subarrays is l*(l+1)/2\n                # But we need the sum of their values, not the count\n                # So, for each run, we can compute the sum of all possible subarrays within it\n                # Let's consider an increasing run starting at index s and ending at index e\n                # The elements are a, a+1, a+2, ..., a + (e-s)\n                # For each possible subarray length l (1 <= l <= e-s+1), the sum is sum_{k=0 to l-1} (a + k) = l*a + l*(l-1)/2\n                # The total sum for all subarrays in this run is sum_{l=1 to len} sum_{k=0 to l-1} (a +k)\n                # Which is sum_{l=1 to len} [l*a + l*(l-1)/2]\n                # This can be simplified as a * sum(l) + sum(l*(l-1)/2)\n                # Sum(l) from 1 to len is len*(len+1)/2\n                # Sum(l*(l-1)/2) from 1 to len is sum_{l=1 to len} (l^2 - l)/2 = [sum(l^2) - sum(l)] / 2\n                # Sum(l^2) from 1 to len is len*(len+1)*(2len+1)/6\n                # Sum(l) is len*(len+1)/2\n                # So, putting it all together:\n                # total_sum = a * (len*(len+1)/2) + [ (len*(len+1)*(2len+1)/6) - (len*(len+1)/2) ] / 2\n                # Simplify:\n                # total_sum = a * len*(len+1)/2 + [ len*(len+1)*(2len+1 - 3) ] / 12\n                # Because 6 is the denominator for sum(l^2), and 2 is the denominator for sum(l)\n                # Wait, let's recompute:\n                # sum(l*(l-1)/2) = 1/2 * sum(l^2 - l) = 1/2 [ sum(l^2) - sum(l) ]\n                # So, sum(l*(l-1)/2) = 1/2 [ len(len+1)(2len+1)/6 - len(len+1)/2 ]\n                # Factor out len(len+1)/2:\n                # = 1/2 [ len(len+1)/2 ( (2len+1)/3 - 1 ) ]\n                # = 1/2 [ len(len+1)/2 ( (2len+1 - 3)/3 ) ]\n                # = 1/2 [ len(len+1)/2 * (2len -2)/3 ]\n                # = 1/2 * len(len+1)(2len-2) / 6\n                # = len(len+1)(len-1) / 6\n                # So, total_sum = a * len*(len+1)/2 + len(len+1)(len-1)/6\n                # Similarly for decreasing runs, but the sum would be a * len*(len+1)/2 - len(len+1)(len-1)/6\n                # So, for each run, we can compute the sum of all its subarrays in O(1) time\n                # Now, the plan is:\n                # 1. Iterate through the array, identifying runs of consecutive increasing or decreasing elements\n                # 2. For each run, compute the sum of all its subarrays using the formulas above\n                # 3. Add this sum to the total\n                # 4. Also, account for single elements (which are both increasing and decreasing, but we should count them only once)\n                # Wait, but single elements are part of both increasing and decreasing runs, but we should count them only once\n                # So, perhaps we need to treat single elements separately\n                # Alternatively, when a run has length 1, it's counted once\n                # Let's test this approach with the first example:\n                # Example 1: nums = [1,2,3]\n                # The entire array is an increasing run of length 3\n                # a =1, len=3\n                # total_sum = 1*(3*4/2) + 3*4*2/6 = 6 + 24/6=6+4=10\n                # But the correct sum for this run is 1+2+3 + (1+2)+(2+3) + (1+2+3) = 6 +3+5+6=20\n                # Wait, but according to the formula, it's 10, which is incorrect\n                # So, the formula is not capturing the correct sum\n                # Hmm, perhaps I made a mistake in deriving the formula\n                # Let's recompute the sum for the increasing run [1,2,3]\n                # Subarrays:\n                # [1] sum=1\n                # [2] sum=2\n                # [3] sum=3\n                # [1,2] sum=3\n                # [2,3] sum=5\n                # [1,2,3] sum=6\n                # Total sum: 1+2+3+3+5+6=20\n                # According to the formula:\n                # a=1, len=3\n                # total_sum = 1*(3*4/2) + (3*4*2)/6 = 6 + 24/6=6+4=10\n                # Which is half of the correct value\n                # So, the formula is incorrect\n                # What's wrong here?\n                # Let's re-examine the derivation\n                # The sum of all subarrays in an increasing run is sum_{l=1 to len} sum_{k=0 to l-1} (a +k)\n                # Which is sum_{l=1 to len} [ l*a + l*(l-1)/2 ]\n                # So, total_sum = a * sum(l) + sum(l*(l-1)/2)\n                # Sum(l) from 1 to len is len*(len+1)/2\n                # Sum(l*(l-1)/2) from 1 to len is sum_{l=1 to len} (l^2 - l)/2 = [sum(l^2) - sum(l)] / 2\n                # Sum(l^2) is len(len+1)(2len+1)/6\n                # Sum(l) is len(len+1)/2\n                # So, sum(l*(l-1)/2) = [ len(len+1)(2len+1)/6 - len(len+1)/2 ] / 2\n                # Let's compute this for len=3:\n                # sum(l*(l-1)/2) = [3*4*7/6 - 3*4/2 ] /2 = [84/6 - 12/2]/2 = [14 -6]/2=8/2=4\n                # a*sum(l) =1*(3*4/2)=6\n                # total_sum=6+4=10, but correct is 20\n                # So, the formula is missing a factor of 2\n                # Wait, perhaps because each subarray is counted once, but in reality, each subarray is part of either an increasing or decreasing run, but not both\n                # Or perhaps the formula is correct, but the approach is not considering that each subarray can be part of multiple runs\n                # Alternatively, perhaps the formula is correct, but the way we are applying it is wrong\n                # Let's think differently: perhaps the formula should be multiplied by 2, because each subarray can be part of both increasing and decreasing runs, but in reality, they are only part of one\n                # No, that doesn't make sense\n                # Alternatively, perhaps the formula is correct, but the way we are identifying runs is incorrect\n                # For example, in the first example, the entire array is an increasing run, so the formula gives 10, but the correct sum is 20\n                # So, the formula is incorrect\n                # Let's try to rederive the formula\n                # For an increasing run starting at a, length l\n                # The subarrays are all possible consecutive subarrays within this run\n                # Each subarray of length k (1<=k<=l) contributes",
              "solution_hash": "8959af20a3817f855b93cd3f4df31508d3e36b406a53daeb76cbc55300fb2437",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpzs7l1crc.py\", line 401, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpzs7l1crc.py\", line 268, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0680093765258789
              },
              "depth": 2,
              "parent_id": "1_2",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_4",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_start = 0\n        for i in range(1, n):\n            if (nums[i] == nums[i-1] + 1) or (nums[i] == nums[i-1] - 1):\n                continue\n            else:\n                # Calculate all subarrays from current_start to i-1\n                length = i - current_start\n                # Sum of all subarrays in this consecutive sequence\n                sum_subarrays = 0\n                for l in range(1, length + 1):\n                    for s in range(current_start, current_start + length - l + 1):\n                        sum_subarrays += sum(nums[s:s+l])\n                total += sum_subarrays\n                current_start = i\n        # Handle the last segment\n        length = n - current_start\n        sum_subarrays = 0\n        for l in range(1, length + 1):\n            for s in range(current_start, current_start + length - l + 1):\n                sum_subarrays += sum(nums[s:s+l])\n        total += sum_subarrays\n        return total % MOD",
              "solution_hash": "fc129ee9da1638e0b1496a99d827ca78ab1910f685376b2f29e57fc84220f3d8",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpimnn6ndw.py\", line 246, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpimnn6ndw.py\", line 122, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n",
                "execution_time": 0.06696867942810059
              },
              "depth": 2,
              "parent_id": "1_2",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_5",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        i = 0\n        while i < n:\n            # Start a new consecutive sequence\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i+1] - nums[i] == 1:\n                    direction = 1\n                elif nums[i+1] - nums[i] == -1:\n                    direction = -1\n                else:\n                    # Single element\n                    total += nums[i]\n                    i += 1\n                    continue\n            else:\n                # Single element\n                total += nums[i]\n                i += 1\n                continue\n            \n            # Now, find the maximum length of the consecutive sequence starting at i\n            j = i + 1\n            while j < n and nums[j] - nums[j-1] == direction:\n                j += 1\n            # The length is j - i\n            length = j - i\n            # Now, calculate the sum of all subarrays within this consecutive sequence\n            # The number of subarrays is length * (length + 1) // 2\n            # Each subarray's sum can be calculated based on the starting and ending elements\n            # For a consecutive sequence, the sum of a subarray from a to b is (b - a + 1) * (nums[a] + nums[b]) // 2\n            # So, for each possible subarray within this sequence, we need to compute this\n            # However, this approach is O(n^2), which is not feasible for n=1e5\n            # Instead, we need a mathematical formula to compute the total sum efficiently\n            # Let's think about all possible subarrays in this consecutive sequence\n            # For each possible starting index s (from i to j-1), and ending index e (from s to j-1)\n            # The sum is (e - s + 1) * (nums[s] + nums[e]) // 2\n            # But calculating this for each s and e is O(n^2), which is too slow\n            # So, we need a way to compute this sum in O(1) per consecutive sequence\n            # Let's model the consecutive sequence as an arithmetic sequence\n            # The consecutive sequence is either increasing or decreasing by 1 each step\n            # Let's denote the starting element as a, and the direction as d (1 or -1)\n            a = nums[i]\n            d = direction\n            # The elements are a, a + d, a + 2d, ..., a + (length-1)d\n            # For a subarray starting at position s (0-based within the consecutive sequence) and ending at e (s <= e < length)\n            # The sum is (e - s + 1) * (a + s*d + a + e*d) // 2\n            # Simplify: (e - s + 1) * (2a + (s + e)d) // 2\n            # The total sum for all subarrays is the sum over s from 0 to length-1, and e from s to length-1 of the above expression\n            # Let's compute this sum\n            # Let's denote m = length\n            m = length\n            # The total sum can be broken down into two parts: the sum of (e - s + 1) and the sum of (s + e)\n            # Because d is either 1 or -1, but since it's a consecutive sequence, d is fixed for the entire sequence\n            # So, the total sum is (sum over s, e) [ (e - s + 1) * (2a + d(s + e)) / 2 ]\n            # Let's factor out 1/2: total = (1/2) * sum [ (e - s + 1)(2a + d(s + e)) ]\n            # Let's expand the terms inside:\n            # (e - s + 1)(2a) + (e - s + 1)(d)(s + e)\n            # So, total = (1/2) [ 2a * sum(e - s + 1) + d * sum( (e - s + 1)(s + e) ) ]\n            # Let's compute each part separately\n            # Compute sum(e - s + 1) for all s <= e\n            # sum_{s=0 to m-1} sum_{e=s to m-1} (e - s + 1)\n            # Let k = e - s + 1, which ranges from 1 to m - s\n            # So, for each s, the inner sum is sum_{k=1 to m - s} k = (m - s)(m - s + 1)/2\n            # So, sum(e - s + 1) = sum_{s=0 to m-1} (m - s)(m - s + 1)/2\n            # Let t = m - s, which ranges from m down to 1 as s increases from 0 to m-1\n            # So, sum becomes sum_{t=1 to m} t(t + 1)/2 = sum_{t=1 to m} (t^2 + t)/2\n            # Which is [sum t^2 + sum t ] / 2\n            # Sum t^2 from 1 to m is m(m+1)(2m+1)/6\n            # Sum t from 1 to m is m(m+1)/2\n            # So, sum(e - s + 1) = [ m(m+1)(2m+1)/6 + m(m+1)/2 ] / 2\n            # Simplify:\n            # = [ m(m+1)(2m+1 + 3) ] / (6 * 2 )\n            # Wait, let's compute it step by step\n            sum_e_s_plus_1 = (m * (m + 1) * (2 * m + 1) // 6 + m * (m + 1) // 2) // 2\n            # Now compute sum( (e - s + 1)(s + e) )\n            # Let's expand (e - s + 1)(s + e) = (e - s + 1)(e + s) = (e + s)(e - s + 1)\n            # Let's denote e = s + k - 1, where k ranges from 1 to m - s\n            # Then, e + s = 2s + k - 1\n            # e - s + 1 = k\n            # So, the term becomes k*(2s + k - 1)\n            # So, sum over s and k:\n            # sum_{s=0 to m-1} sum_{k=1 to m - s} k*(2s + k - 1)\n            # Let's split this into two parts:\n            # sum_{s,k} [ 2s*k + k(k - 1) ]\n            # So, total sum is 2s*k + k(k-1)\n            # Let's compute each part separately\n            # First part: sum_{s,k} 2s*k\n            # = 2 * sum_{s=0 to m-1} s * sum_{k=1 to m - s} k\n            # sum_{k=1 to t} k = t(t+1)/2, where t = m - s\n            # So, first part becomes 2 * sum_{s=0 to m-1} s * ( (m - s)(m - s + 1) ) / 2\n            # Simplify: sum_{s=0 to m-1} s * (m - s)(m - s + 1)\n            # Let t = m - s, s = m - t\n            # When s=0, t=m; s=m-1, t=1\n            # So, sum becomes sum_{t=1 to m} (m - t) * t * (t + 1)\n            # = sum_{t=1 to m} (m t (t + 1) - t^2 (t + 1))\n            # = m sum t(t+1) - sum t^2(t+1)\n            # Compute sum t(t+1) from 1 to m:\n            # t(t+1) = t^2 + t\n            # sum = sum t^2 + sum t = m(m+1)(2m+1)/6 + m(m+1)/2 = m(m+1)(m+2)/3\n            # Compute sum t^2(t+1) = sum t^3 + t^2\n            # sum t^3 = [m(m+1)/2]^2\n            # sum t^2 = m(m+1)(2m+1)/6\n            # So, sum t^2(t+1) = [m^2(m+1)^2 / 4] + [m(m+1)(2m+1)/6]\n            # Putting it all together:\n            # first_part = m * [m(m+1)(m+2)/3] - [m^2(m+1)^2 /4 + m(m+1)(2m+1)/6]\n            # This seems complicated, but perhaps there's a simpler way\n            # Alternatively, perhaps we can find a formula for the sum\n            # Let's compute sum_{s=0 to m-1} s*(m - s)(m - s + 1)\n            # Let's expand (m - s)(m - s + 1) = (m - s)(m - s + 1) = (m - s)(m - s) + (m - s) = (m - s)^2 + (m - s)\n            # So, s*(m - s)^2 + s*(m - s)\n            # So, sum becomes sum s(m - s)^2 + sum s(m - s)\n            # Let's compute each term\n            # sum s(m - s)^2 from s=0 to m-1\n            # Let t = m - s, s = m - t\n            # When s=0, t=m; s=m-1, t=1\n            # So, sum becomes sum_{t=1 to m} (m - t) * t^2\n            # = sum_{t=1 to m} m t^2 - t^3\n            # = m * sum t^2 - sum t^3\n            # = m * [m(m+1)(2m+1)/6] - [ (m(m+1)/2 )^2 ]\n            # Similarly, sum s(m - s) from s=0 to m-1\n            # Again, t = m - s\n            # sum (m - t) * t = sum m t - t^2\n            # = m * sum t - sum t^2\n            # = m * [m(m+1)/2] - [m(m+1)(2m+1)/6]\n            # So, putting it all together:\n            sum_s_k = 0\n            # Compute first part: sum_{s,k} 2s*k\n            # Which is 2 * sum_{s=0 to m-1} s * sum_{k=1 to m - s} k\n            # sum_{k=1 to t} k = t(t+1)/2, t = m - s\n            # So, sum_{s} s * t(t+1)/2, t = m - s\n            # So, sum_s_k_part1 = sum_{s=0 to m-1} s * (m - s)(m - s + 1)/2\n            # Which is sum_{s=0 to m-1} [s (m - s)(m - s + 1)] / 2\n            # As computed earlier, this is a complex expression, but perhaps we can find a formula\n            # Alternatively, perhaps we can compute it using known summation formulas\n            # Let's compute sum_{s=0 to m-1} s (m - s)(m - s + 1)\n            # Let's expand (m - s)(m - s + 1) = (m - s)(m - s) + (m - s) = (m - s)^2 + (m - s)\n            # So, s*(m - s)^2 + s*(m - s)\n            # So, sum becomes sum s(m - s)^2 + sum s(m - s)\n            # As before, let's compute each part\n            # Compute sum s(m - s)^2:\n            # Let t = m - s, s = m - t\n            # sum_{s=0 to m-1} s t^2 = sum_{t=1 to m} (m - t) t^2\n            # = m sum t^2 - sum t^3\n            # = m [m(m+1)(2m+1)/6] - [ (m(m+1)/2 )^2 ]\n            sum_t_sq = m * (m + 1) * (2 * m + 1) // 6\n            sum_t_cu = (m * (m + 1) // 2) ** 2\n            part1 = m * sum_t_sq - sum_t_cu\n            # Compute sum s(m - s):\n            # sum_{s=0 to m-1} s (m - s) = sum_{s=0 to m-1} (m s - s^2)\n            # = m sum s - sum s^2\n            sum_s = m * (m - 1) // 2\n            sum_s_sq = (m - 1) * m * (2 * m - 1) // 6\n            part2 = m * sum_s - sum_s_sq\n            # So, sum s(m - s)(m - s + 1) = part1 + part2\n            sum_s_k_part1 = (part1 + part2) // 2  # Because the first part is multiplied by 1/2\n            # Now compute the second part: sum_{s,k} k(k - 1)\n            # Which is sum_{s=0 to m-1} sum_{k=1 to m - s} k(k - 1)\n            # k(k - 1) = k^2 - k\n            # So, sum_{k=1 to t} k(k - 1) = sum k^2 - sum k = [t(t+1)(2t+1)/6] - [t(t+1)/2]\n            # = t(t+1)(2t+1 - 3)/6 = t(t+1)(2t - 2)/6 = t(t+1)(t - 1)/3\n            # So, for each s, t = m - s\n            # sum_{k=1 to t} k(k-1) = t(t+1)(t - 1)/3\n            # So, sum_{s=0 to m-1} t(t+1)(t - 1)/3, where t = m - s\n            # t ranges from m down to 1 as s increases from 0 to m-1\n            # So, sum becomes sum_{t=1 to m} t(t+1)(t - 1)/3\n            # = (1/3) sum_{t=1 to m} t(t^2 - 1)\n            # = (1/3) sum (t^3 - t)\n            # = (1/3) [ sum t^3 - sum t ]\n            sum_t_cu = (m * (m + 1) // 2) ** 2\n            sum_t = m * (m + 1) // 2\n            sum_s_k_part2 = (sum_t_cu - sum_t) // 3\n            # So, the total sum (e - s + 1)(s + e) is sum_s_k_part1 + sum_s_k_part2\n            sum_e_s_plus_1_s_e = sum_s_k_part1 + sum_s_k_part2\n            # Now, putting it all together\n            total_contribution = (2 * a * sum_e_s_plus_1 + d * sum_e_s_plus_1_s_e) // 2\n            total += total_contribution\n            # Move to the next position after the consecutive sequence\n            i = j\n        return total % MOD",
              "solution_hash": "12b0abf0b491d89a8163d3dc2cd26c4f1b13d4f6a0ebaa537c8d183281ebe808",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpp5pz9z7o.py\", line 404, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpp5pz9z7o.py\", line 272, in check\n    assert candidate(nums = [7, 6, 1, 2]) == 32\nAssertionError\n",
                "execution_time": 0.06702065467834473
              },
              "depth": 2,
              "parent_id": "1_2",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_6",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_length = 1\n        dec_length = 1\n        inc_sum = nums[0]\n        dec_sum = nums[0]\n        total += inc_sum  # Single element is counted once\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1] + 1:\n                inc_length += 1\n                inc_sum = inc_sum + nums[i] * inc_length - (nums[i] - (nums[i] - 1)) * (inc_length - 1) // 2\n                dec_length = 1\n                dec_sum = nums[i]\n            elif nums[i] == nums[i-1] - 1:\n                dec_length += 1\n                dec_sum = dec_sum + nums[i] * dec_length - (nums[i] + (nums[i] + 1)) * (dec_length - 1) // 2\n                inc_length = 1\n                inc_sum = nums[i]\n            else:\n                inc_length = 1\n                dec_length = 1\n                inc_sum = nums[i]\n                dec_sum = nums[i]\n            total += inc_sum + dec_sum\n            total %= MOD\n        return total % MOD",
          "solution_hash": "326bb010f4dee1b077545589e14cd5680f8527c7731eaf2660193f6140f2e962",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp520n94li.py\", line 249, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp520n94li.py\", line 116, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06895565986633301
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_7",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_length = 1\n        dec_length = 1\n        inc_sum = nums[0]\n        dec_sum = nums[0]\n        total += inc_sum  # Single element is counted once\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1] + 1:\n                inc_length += 1\n                inc_sum = inc_sum + nums[i] * inc_length - (nums[i] - (nums[i] - 1)) * (inc_length - 1) // 2\n                dec_length = 1\n                dec_sum = nums[i]\n            elif nums[i] == nums[i-1] - 1:\n                dec_length += 1\n                dec_sum = dec_sum + nums[i] * dec_length - (nums[i] + (nums[i] + 1)) * (dec_length - 1) // 2\n                inc_length = 1\n                inc_sum = nums[i]\n            else:\n                inc_length = 1\n                dec_length = 1\n                inc_sum = nums[i]\n                dec_sum = nums[i]\n            total += inc_sum + dec_sum\n            total %= MOD\n        return total % MOD",
              "solution_hash": "326bb010f4dee1b077545589e14cd5680f8527c7731eaf2660193f6140f2e962",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp520n94li.py\", line 249, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp520n94li.py\", line 116, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06895565986633301
              },
              "depth": 2,
              "parent_id": "1_6",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_8",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_length = 1\n        inc_sum = nums[0]\n        dec_length = 1\n        dec_sum = nums[0]\n        total = inc_sum\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1] + 1:\n                inc_length += 1\n                inc_sum = inc_sum + nums[i] * inc_length - (nums[i] - (nums[i-1] + 1)) * (inc_length - 1)\n                dec_length = 1\n                dec_sum = nums[i]\n            elif nums[i] == nums[i-1] - 1:\n                dec_length += 1\n                dec_sum = dec_sum + nums[i] * dec_length - (nums[i] + (nums[i-1] - 1)) * (dec_length - 1)\n                inc_length = 1\n                inc_sum = nums[i]\n            else:\n                inc_length = 1\n                inc_sum = nums[i]\n                dec_length = 1\n                dec_sum = nums[i]\n            total += inc_sum + dec_sum - nums[i]\n            total %= MOD\n        return total % MOD",
              "solution_hash": "f980e01993be43b0a4d56202e2dc200c8704fc2f40f94369b7d0830da0009302",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp5ykre8ri.py\", line 249, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp5ykre8ri.py\", line 116, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06848764419555664
              },
              "depth": 2,
              "parent_id": "1_6",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_9",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        current_length = 1\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                if direction == 1:\n                    current_length += 1\n                else:\n                    current_length = 2\n                    direction = 1\n                current_sum = current_sum + nums[i] * current_length - (nums[i] - (nums[i] - 1)) * (current_length - 1) // 2\n            elif diff == -1:\n                if direction == -1:\n                    current_length += 1\n                else:\n                    current_length = 2\n                    direction = -1\n                current_sum = current_sum + nums[i] * current_length - (nums[i] + (nums[i] + 1)) * (current_length - 1) // 2\n            else:\n                # Add the sum of all subarrays in the current sequence\n                if direction != 0:\n                    total += current_sum\n                current_sum = nums[i]\n                current_length = 1\n                direction = 0\n            # Add the single element if it's the start of a new sequence\n            if direction == 0:\n                total += nums[i]\n                total %= MOD\n        # Add the last sequence\n        if direction != 0:\n            total += current_sum\n        # Add all single elements\n        total += sum(nums)\n        return total % MOD",
              "solution_hash": "27eaba9818aa9fc5bdb89dd54664108e66478a2f703ab4995e65cc7fa1cf550b",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplmgwfq74.py\", line 261, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplmgwfq74.py\", line 128, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.07140660285949707
              },
              "depth": 2,
              "parent_id": "1_6",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = nums[0]\n        total += current_sum\n        prev = nums[0]\n        # We need to track the direction of the consecutive sequence\n        # 1 for increasing, -1 for decreasing, 0 for single element\n        direction = 0\n        for i in range(1, n):\n            diff = nums[i] - prev\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    current_sum += nums[i]\n                else:\n                    if diff == direction:\n                        current_sum += nums[i]\n                    else:\n                        # Direction changed, so the previous window ends here\n                        # Start a new window with the last two elements\n                        current_sum = prev + nums[i]\n                        direction = diff\n                total = (total + current_sum) % MOD\n            else:\n                # Not consecutive, reset\n                current_sum = nums[i]\n                direction = 0\n                total = (total + current_sum) % MOD\n            prev = nums[i]\n        return total % MOD",
      "solution_hash": "5206f1172a0044d4db3b8bfb2781cd598bc54c1a6339cb4f21f05fcf42ad9c6a",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmppzrkbr4c.py\", line 253, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmppzrkbr4c.py\", line 120, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
        "execution_time": 0.06615877151489258
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_11",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = inc_sum + dec_sum - nums[0]  # Subtract nums[0] to avoid double-counting\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            inc_len, inc_sum = new_inc_len, new_inc_sum\n            dec_len, dec_sum = new_dec_len, new_dec_sum\n            \n            contribution = inc_sum + dec_sum - current\n            total = (total + contribution) % MOD\n        \n        return total % MOD",
          "solution_hash": "43fbc819440865d27f6b63dbe84d1a087b5af88f70a4d842b775aec916471037",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpguy03jsl.py\", line 253, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpguy03jsl.py\", line 120, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06767678260803223
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_12",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = inc_sum\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            \n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            inc_len, inc_sum = new_inc_len, new_inc_sum\n            dec_len, dec_sum = new_dec_len, new_dec_sum\n            \n            contribution = inc_sum + dec_sum - current\n            total = (total + contribution) % MOD\n        \n        return total % MOD",
              "solution_hash": "ef33b83bc76c0ec6aa39438206fbe4ee7cf893a6a4ef2df18e8f772f12314211",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpmyura77g.py\", line 255, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpmyura77g.py\", line 122, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0680544376373291
              },
              "depth": 2,
              "parent_id": "1_11",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_13",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = nums[0]  # Start with the first element\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            # Calculate contribution without double-counting the current element\n            contribution = new_inc_sum + new_dec_sum - current\n            total = (total + contribution) % MOD\n            \n            # Update for next iteration\n            inc_len, inc_sum = new_inc_len, new_inc_sum\n            dec_len, dec_sum = new_dec_len, new_dec_sum\n        \n        return total % MOD",
              "solution_hash": "6966265ab91768705e61d2141400534d596a4853ba52c9f8c788b808194db2e7",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmprdl01j0_.py\", line 255, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmprdl01j0_.py\", line 122, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06713986396789551
              },
              "depth": 2,
              "parent_id": "1_11",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_14",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        inc_len = 1\n        inc_sum = nums[0]\n        dec_len = 1\n        dec_sum = nums[0]\n        total = inc_sum  # Only add once since it's the same as dec_sum\n        \n        for i in range(1, n):\n            current = nums[i]\n            prev = nums[i-1]\n            diff = current - prev\n            new_inc_len = 1\n            new_inc_sum = current\n            new_dec_len = 1\n            new_dec_sum = current\n            \n            if diff == 1:\n                new_inc_len = inc_len + 1\n                new_inc_sum = inc_sum + current\n            elif diff == -1:\n                new_dec_len = dec_len + 1\n                new_dec_sum = dec_sum + current\n            \n            # Calculate the contribution for all possible subarrays ending at i\n            # For increasing subarrays\n            if diff == 1:\n                contribution_inc = (new_inc_sum - (nums[i] * (new_inc_len - 1))) \n                # The sum of all subarrays ending here with increasing\n                # This is sum_{k=1 to new_inc_len} (sum of last k elements)\n                # Which is equal to new_inc_sum + (new_inc_sum - nums[i]) + ... \n                # But a smarter way is to realize that each new element adds (current * k) where k is the length\n                # Alternatively, the sum can be calculated as (current * (new_inc_len)) + (sum of previous subarrays)\n                # However, to avoid complexity, we can compute the sum of all possible subarrays ending here\n                # For an increasing subarray of length L, the number of subarrays is L, each of length 1 to L\n                # The sum for each is the sum of the last k elements for k=1 to L\n                # This can be computed as current * L + (current -1) * (L-1) + ... + (current - L +1) * 1\n                # But this is complex, so instead, we can track the sum incrementally\n                # The sum for all subarrays ending at i for increasing is the sum of the current subarray plus the sum of all subarrays ending at i-1 for increasing\n                # Wait, no. Because each new element extends the subarrays.\n                # For example, if the current subarray is of length 3, then the new subarrays are [current], [prev, current], [prev_prev, prev, current]\n                # Their sums are current, prev+current, prev_prev+prev+current\n                # So the total contribution is sum of these, which is (current) + (prev + current) + (prev_prev + prev + current) = 3*current + 2*prev + prev_prev\n                # Alternatively, the sum can be calculated as (current * new_inc_len) + (sum of previous elements multiplied by their respective counts)\n                # To avoid recalculating, we can track the sum of all possible subarrays ending at i for increasing and decreasing separately\n                # Let's define inc_subarrays_sum as the sum of all subarrays ending at i for increasing\n                # Similarly for dec_subarrays_sum\n                # Then, for each i, if the current subarray is increasing, inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                # Wait, perhaps a better approach is to track for each position, the sum of all subarrays ending there for increasing and decreasing\n                # Let me think differently: for each i, the number of consecutive subarrays ending at i is equal to the length of the current consecutive sequence\n                # For example, if the current increasing subarray is of length 3, then there are 3 subarrays ending at i: [i], [i-1,i], [i-2,i-1,i]\n                # The sum of these is sum_{k=1 to 3} sum(nums[i-k+1..i])\n                # To compute this efficiently, we can track the sum incrementally\n                # Let's define inc_subarrays_sum as the sum of all subarrays ending at i for increasing\n                # When the current element continues the increasing sequence, inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                # Similarly for decreasing\n                # So, in the code, we need to track inc_subarrays_sum and dec_subarrays_sum\n                # Initialize them as 0, and for each i, compute based on the previous values\n                # Let's adjust the code accordingly\n                # So, in the initial code, we have inc_len and inc_sum, but we need to track the sum of all subarrays ending at i for increasing\n                # Let's redefine inc_subarrays_sum as the sum of all subarrays ending at i for increasing\n                # Similarly for dec_subarrays_sum\n                # So, for each i:\n                # if diff == 1:\n                #     inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                # elif diff == -1:\n                #     dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                # else:\n                #     inc_subarrays_sum = current\n                #     dec_subarrays_sum = current\n                # Then, the contribution is inc_subarrays_sum + dec_subarrays_sum\n                # But wait, for the case where the current element is part of both increasing and decreasing? No, because the difference can't be both 1 and -1\n                # So, in the code, we need to track inc_subarrays_sum and dec_subarrays_sum\n                # Let's adjust the variables:\n                # inc_subarrays_sum: sum of all increasing consecutive subarrays ending at i\n                # dec_subarrays_sum: sum of all decreasing consecutive subarrays ending at i\n                # For each i:\n                # if diff == 1:\n                #     inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                #     dec_subarrays_sum = current  # because the current element can start a new decreasing subarray\n                # elif diff == -1:\n                #     dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                #     inc_subarrays_sum = current  # because the current element can start a new increasing subarray\n                # else:\n                #     inc_subarrays_sum = current\n                #     dec_subarrays_sum = current\n                # Then, the contribution is inc_subarrays_sum + dec_subarrays_sum\n                # But wait, in the case where the current element is part of neither, we still have to count the single element subarray\n                # So, in all cases, the contribution is inc_subarrays_sum + dec_subarrays_sum - current (since the single element is counted in both)\n                # Because when diff is neither 1 nor -1, both inc_subarrays_sum and dec_subarrays_sum are current, so their sum is 2*current, but we should only count it once\n                # So, the contribution is (inc_subarrays_sum + dec_subarrays_sum - current)\n                # Let's test this logic with example 1:\n                # Example 1: [1,2,3]\n                # i=0: inc_subarrays_sum=1, dec_subarrays_sum=1, contribution=1+1-1=1\n                # total=1\n                # i=1: diff=1\n                # new_inc_len=2, new_inc_sum=1+2=3\n                # inc_subarrays_sum = 1 (prev inc_subarrays_sum) + 2*2 = 1+4=5\n                # dec_subarrays_sum = 2\n                # contribution=5+2-2=5\n                # total=1+5=6\n                # i=2: diff=1\n                # new_inc_len=3, new_inc_sum=3+3=6\n                # inc_subarrays_sum =5 (prev inc_subarrays_sum) +3*3=5+9=14\n                # dec_subarrays_sum=3\n                # contribution=14+3-3=14\n                # total=6+14=20\n                # Which matches the expected output\n                # Another test case: example 3: [7,6,1,2]\n                # i=0: contribution=7\n                # i=1: diff=-1\n                # dec_subarrays_sum =0 +6*2=12 (assuming initial dec_subarrays_sum is 0)\n                # Wait, perhaps the initial values need to be set correctly\n                # Let's adjust the initial setup:\n                # At i=0, inc_subarrays_sum = nums[0], dec_subarrays_sum = nums[0]\n                # contribution = nums[0] + nums[0] - nums[0] = nums[0]\n                # So, initial total is nums[0]\n                # For i=1:\n                # diff =6-7=-1\n                # So, dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                # dec_subarrays_sum_prev is 7, new_dec_len is 2\n                # So dec_subarrays_sum =7 +6*2=19\n                # inc_subarrays_sum is set to current=6\n                # contribution=19 +6 -6=19\n                # total=7+19=26\n                # i=2: current=1, prev=6, diff=-5\n                # So, neither increasing nor decreasing\n                # inc_subarrays_sum=1, dec_subarrays_sum=1\n                # contribution=1+1-1=1\n                # total=26+1=27\n                # i=3: current=2, prev=1, diff=1\n                # So, inc_subarrays_sum = inc_subarrays_sum_prev (1) +2*2=1+4=5\n                # dec_subarrays_sum=2\n                # contribution=5+2-2=5\n                # total=27+5=32\n                # Which matches example 3's expected output\n                # So, the logic seems correct\n                # Now, let's adjust the code accordingly\n                # We'll track inc_subarrays_sum and dec_subarrays_sum\n                # Initialize them as nums[0]\n                # For each i from 1 to n-1:\n                # compute diff\n                # if diff ==1:\n                #     new_inc_len = inc_len +1\n                #     new_inc_sum = inc_sum + current\n                #     inc_subarrays_sum = inc_subarrays_sum_prev + current * new_inc_len\n                #     dec_subarrays_sum = current\n                # elif diff ==-1:\n                #     new_dec_len = dec_len +1\n                #     new_dec_sum = dec_sum + current\n                #     dec_subarrays_sum = dec_subarrays_sum_prev + current * new_dec_len\n                #     inc_subarrays_sum = current\n                # else:\n                #     inc_subarrays_sum = current\n                #     dec_subarrays_sum = current\n                # contribution = inc_subarrays_sum + dec_subarrays_sum - current\n                # total += contribution\n                # Also, update inc_len, inc_sum, dec_len, dec_sum accordingly\n                # So, in code:\n                # Initialize:\n                inc_subarrays_sum = nums[0]\n                dec_subarrays_sum = nums[0]\n                total = inc_subarrays_sum  # since contribution is nums[0]\n                \n                for i in range(1, n):\n                    current = nums[i]\n                    prev = nums[i-1]\n                    diff = current - prev\n                    new_inc_len = 1\n                    new_inc_sum = current\n                    new_dec_len = 1\n                    new_dec_sum = current\n                    \n                    if diff == 1:\n                        new_inc_len = inc_len + 1\n                        new_inc_sum = inc_sum + current\n                        inc_subarrays_sum = inc_subarrays_sum + current * new_inc_len\n                        dec_subarrays_sum = current\n                    elif diff == -1:\n                        new_dec_len = dec_len + 1\n                        new_dec_sum = dec_sum + current\n                        dec_subarrays_sum = dec_subarrays_sum + current * new_dec_len\n                        inc_subarrays_sum = current\n                    else:\n                        inc_subarrays_sum = current\n                        dec_subarrays_sum = current\n                    \n                    contribution = inc_subarrays_sum + dec_subarrays_sum - current\n                    total = (total + contribution) % MOD\n                    \n                    # Update the lengths and sums for next iteration\n                    if diff == 1:\n                        inc_len = new_inc_len\n                        inc_sum = new_inc_sum\n                    elif diff == -1:\n                        dec_len = new_dec_len\n                        dec_sum = new_dec_sum\n                    else:\n                        inc_len = 1\n                        inc_sum = current\n                        dec_len = 1\n                        dec_sum = current\n        \n        return total % MOD",
              "solution_hash": "3c624936825a5d638672aa3a5c34d874e46d1aac0212091081357be97be70e1d",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpmmjj0as2.py\", line 426, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpmmjj0as2.py\", line 293, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.07249975204467773
              },
              "depth": 2,
              "parent_id": "1_11",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_15",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    start = i-1\n                else:\n                    if diff != direction:\n                        # Direction changed, calculate all subarrays up to i-1\n                        length = i - start\n                        sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence with i-1 and i\n                        start = i-1\n                        direction = diff\n                # Add the current element as a single element\n                total += nums[i]\n            else:\n                # Not consecutive, calculate all subarrays up to i-1\n                if direction != 0:\n                    length = i - start\n                    sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n                # Add the current element\n                total += nums[i]\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            diff = nums[1] - nums[0] if n > 1 else 0\n            sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
          "solution_hash": "894f9dab9e8e5d6a0f5b87f6e416df8637cbfbe26a95d9bfe382e34090059b91",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpn94f3dpw.py\", line 268, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpn94f3dpw.py\", line 135, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06889939308166504
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_16",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            current_diff = nums[i] - nums[i-1]\n            if current_diff == 1 or current_diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = current_diff\n                    start = i-1\n                else:\n                    if current_diff != direction:\n                        # Direction changed, calculate all subarrays up to i-1\n                        length = i - start\n                        # Calculate sum of all subarrays in this sequence\n                        sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence with i-1 and i\n                        start = i-1\n                        direction = current_diff\n            else:\n                # Not consecutive, calculate all subarrays up to i-1\n                if direction != 0:\n                    length = i - start\n                    sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n            # Add the current element as a single element\n            total += nums[i]\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
              "solution_hash": "d8b1cbfa0ac71b8f7f5808eee1136f9740f460c7441bce89441386d6374cabab",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp309bnb10.py\", line 266, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp309bnb10.py\", line 133, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06798791885375977
              },
              "depth": 2,
              "parent_id": "1_15",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_17",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    direction = diff\n                    start = i-1\n                else:\n                    if diff != direction:\n                        # End of current sequence, calculate all subarrays\n                        length = i - start\n                        sum_subarrays = (nums[start] * length * (length + 1) // 2) + (diff_prev // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence\n                        start = i-1\n                        direction = diff\n                        # Add the current element as a single element\n                        total += nums[i]\n                        continue\n                # Continue the current sequence\n                # Add all possible subarrays ending at i\n                current_length = i - start + 1\n                sum_subarrays = (nums[start] * current_length) + (diff // 2) * (current_length * (current_length - 1))\n                total += sum_subarrays\n            else:\n                # End of current sequence, calculate all subarrays\n                if direction != 0:\n                    length = i - start\n                    sum_subarrays = (nums[start] * length * (length + 1) // 2) + (diff_prev // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n                # Add the current element\n                total += nums[i]\n            # Update previous difference\n            diff_prev = diff\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            sum_subarrays = (nums[start] * length * (length + 1) // 2) + (diff_prev // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
              "solution_hash": "47837edef5b02cf1044b3241f9dcf2e0e52d374b6acb67f7891af25f523e1d58",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpg4iuouvr.py\", line 274, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpg4iuouvr.py\", line 141, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06646871566772461
              },
              "depth": 2,
              "parent_id": "1_15",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_18",
              "solution": "class Solution:\n    def getSum(self, nums: list[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    direction = diff\n                    start = i-1\n                else:\n                    if diff != direction:\n                        # End of current consecutive sequence\n                        length = i - start\n                        sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                        total += sum_subarrays\n                        # Start new sequence\n                        start = i-1\n                        direction = diff\n            else:\n                if direction != 0:\n                    # End of current consecutive sequence\n                    length = i - start\n                    sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (diff // 2) * (length * (length - 1) // 2)\n                    total += sum_subarrays\n                # Reset\n                start = i\n                direction = 0\n            # Add the current element as a single element\n            total += nums[i]\n        \n        # Handle the last sequence\n        if direction != 0:\n            length = n - start\n            sum_subarrays = (nums[start] * (length * (length + 1) // 2)) + (direction // 2) * (length * (length - 1) // 2)\n            total += sum_subarrays\n        else:\n            # Add the last element if not part of any sequence\n            total += nums[-1]\n        \n        return total % MOD",
              "solution_hash": "2025951482123b95e24848760692abfb0b684cdf5ff5ee5028f4e2da33f1bd31",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpic4d6qz5.py\", line 264, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpic4d6qz5.py\", line 131, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06737685203552246
              },
              "depth": 2,
              "parent_id": "1_15",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_19",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        start = 0\n        direction = 0  # 1 for increasing, -1 for decreasing, 0 for single element\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                total += current_sum\n                direction = 0\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    start = i-1\n                    current_sum = nums[start] + nums[i]\n                    total += current_sum\n                else:\n                    if diff == direction:\n                        # Continue the current sequence\n                        current_sum += nums[i]\n                        total += current_sum\n                    else:\n                        # Direction changed, start new sequence with last two elements\n                        direction = diff\n                        start = i-1\n                        current_sum = nums[start] + nums[i]\n                        total += current_sum\n            else:\n                # Not consecutive, reset\n                direction = 0\n                start = i\n                current_sum = nums[i]\n                total += current_sum\n        \n        return total % MOD",
          "solution_hash": "9e0d7bdd6ab36179e97ccb2e6de8370e2c03636c3ac93cb82784333efb86a1b0",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpza0o_cxq.py\", line 262, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpza0o_cxq.py\", line 129, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06864690780639648
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_20",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        \n        for i in range(n):\n            # Each single element is a consecutive subarray\n            total += nums[i]\n            # Check for consecutive subarrays starting at i\n            if i == n - 1:\n                continue\n            # Determine the direction\n            direction = nums[i+1] - nums[i]\n            if direction not in (1, -1):\n                continue\n            # Now, check how far this consecutive sequence extends\n            current_sum = nums[i] + nums[i+1]\n            total += current_sum\n            j = i + 2\n            while j < n:\n                if nums[j] - nums[j-1] == direction:\n                    current_sum += nums[j]\n                    total += current_sum\n                    j += 1\n                else:\n                    break\n        return total % MOD",
              "solution_hash": "1a39163dce9a12138e4666101ec1998ed609db50e05a3feb237d5ab297e0613f",
              "test_result": {
                "status": "pass",
                "execution_time": 0.06919121742248535
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": true
            },
            {
              "node_id": "2_21",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        prev_diff = 0\n        current_length = 1\n        current_sum = nums[0]\n        total += current_sum\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if diff == prev_diff or prev_diff == 0:\n                    current_length += 1\n                    current_sum += nums[i]\n                else:\n                    current_length = 2\n                    current_sum = nums[i-1] + nums[i]\n                prev_diff = diff\n            else:\n                prev_diff = 0\n                current_length = 1\n                current_sum = nums[i]\n            \n            total += current_sum\n        \n        return total % MOD",
              "solution_hash": "bd70c12e49ad60d0640e9c7b72d90cf49785bfb72cedd428eeaf8b94bb27ba03",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmppdz0hbg3.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmppdz0hbg3.py\", line 114, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0708303451538086
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_22",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = 0\n        current_sum = 0\n        start = 0\n        direction = 0  # 1 for increasing, -1 for decreasing, 0 for single element\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                total += current_sum\n                direction = 0\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if direction == 0:\n                    # Starting a new consecutive sequence\n                    direction = diff\n                    current_sum = nums[i-1] + nums[i]\n                    total += current_sum\n                else:\n                    if diff == direction:\n                        # Continue the current sequence\n                        current_sum += nums[i]\n                        total += current_sum\n                    else:\n                        # Direction changed, start new sequence with last two elements\n                        direction = diff\n                        current_sum = nums[i-1] + nums[i]\n                        total += current_sum\n            else:\n                # Not consecutive, reset\n                direction = 0\n                current_sum = nums[i]\n                total += current_sum\n        \n        return total % MOD",
              "solution_hash": "c88b9f9d751d894fc2423432d77392019a676833904ae5e0d663f76f531d8739",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplyoz1q4h.py\", line 259, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplyoz1q4h.py\", line 126, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06859564781188965
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total += current_sum\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == 0 or direction == new_direction:\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
      "solution_hash": "2b34ee8593d44422f354dfecc103aae8a4e6753e9f96bb1734edd6e5f12a7fd6",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpj46vrx60.py\", line 259, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpj46vrx60.py\", line 126, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
        "execution_time": 0.07173490524291992
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_24",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start new subarrays\n                for j in range(current_start, i):\n                    total += sum(nums[j:i])\n                current_start = i\n                direction = 0\n            else:\n                if direction == 0:\n                    direction = new_direction\n                elif direction != new_direction:\n                    # End previous subarrays and start new\n                    for j in range(current_start, i-1):\n                        total += sum(nums[j:i])\n                    current_start = i-1\n                    direction = new_direction\n                # Add the current subarray\n                total += sum(nums[current_start:i])\n        \n        # Add all subarrays ending at the last element\n        for j in range(current_start, n):\n            total += sum(nums[j:n])\n        \n        return total % MOD",
          "solution_hash": "793fdf600b6645acd4cb1c744b9d1a9c9d6dc959ac250b38ef136052ad285bbd",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpu5wdkoa9.py\", line 257, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpu5wdkoa9.py\", line 126, in check\n    assert candidate(nums = [1, 3, 2, 4, 5, 7, 6, 8, 9, 10]) == 145\nAssertionError\n",
            "execution_time": 0.0688331127166748
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_25",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        prev_diff = None\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total += current_sum\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if prev_diff is None:\n                    prev_diff = diff\n                    current_sum += nums[i]\n                    current_length += 1\n                else:\n                    if diff == prev_diff:\n                        current_sum += nums[i]\n                        current_length += 1\n                    else:\n                        # Direction changed, reset\n                        current_sum = nums[i-1] + nums[i]\n                        current_length = 2\n                        prev_diff = diff\n            else:\n                # Not consecutive, reset\n                current_sum = nums[i]\n                current_length = 1\n                prev_diff = None\n            \n            # Add the sum of all subarrays ending at i\n            # The number of subarrays is current_length\n            # The sum is current_sum\n            total += current_sum\n            total %= MOD\n        \n        return total % MOD",
              "solution_hash": "e833724decf3d3d86042a313bd151ee45c907ddc5004c77923e3e4e31d5912b4",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpmhv77fm7.py\", line 261, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpmhv77fm7.py\", line 128, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06757402420043945
              },
              "depth": 2,
              "parent_id": "1_24",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_26",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_start = 0\n        direction = 0  # 0: not started, 1: increasing, -1: decreasing\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Calculate sum for all subarrays ending at i-1\n                length = i - current_start\n                if length > 1:\n                    total += nums[current_start] * length + (length - 1) * length // 2 * (nums[i-1] - nums[current_start]) // (length - 1)\n                else:\n                    total += nums[current_start]\n                current_start = i\n                direction = 0\n            else:\n                if direction == 0:\n                    direction = new_direction\n                elif direction != new_direction:\n                    # End previous run and start new\n                    length = i - current_start\n                    if length > 1:\n                        total += nums[current_start] * length + (length - 1) * length // 2 * (nums[i-1] - nums[current_start]) // (length - 1)\n                    else:\n                        total += nums[current_start]\n                    current_start = i - 1\n                    direction = new_direction\n                # Add the current subarray\n                length = i - current_start + 1\n                if length > 1:\n                    total += nums[current_start] * length + (length - 1) * length // 2 * (nums[i] - nums[current_start]) // (length - 1)\n                else:\n                    total += nums[current_start]\n        \n        # Add all subarrays from current_start to end\n        length = n - current_start\n        if length > 1:\n            total += nums[current_start] * length + (length - 1) * length // 2 * (nums[-1] - nums[current_start]) // (length - 1)\n        else:\n            total += nums[current_start]\n        \n        return total % MOD",
              "solution_hash": "754ae2ac52276b43b7e9e4cfbef06b61f67acb0dac5291e0b4a8447de0bddbe5",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpi5pxex_x.py\", line 270, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpi5pxex_x.py\", line 139, in check\n    assert candidate(nums = [1, 3, 2, 4, 5, 7, 6, 8, 9, 10]) == 145\nAssertionError\n",
                "execution_time": 0.06676959991455078
              },
              "depth": 2,
              "parent_id": "1_24",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_27",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = nums[0]\n        current_sum = nums[0]\n        prev_diff = 0  # 0: single element, 1: increasing, -1: decreasing\n        length = 1\n        \n        for i in range(1, n):\n            diff = nums[i] - nums[i-1]\n            if diff == 1 or diff == -1:\n                if diff == prev_diff or prev_diff == 0:\n                    # Continue the current consecutive sequence\n                    current_sum += nums[i] + (nums[i] - nums[i-1]) * (length)\n                    length += 1\n                else:\n                    # Change in direction, reset\n                    current_sum = nums[i-1] + nums[i]\n                    length = 2\n                prev_diff = diff\n            else:\n                # Not consecutive, reset\n                current_sum = nums[i]\n                length = 1\n                prev_diff = 0\n            \n            total += current_sum\n            total %= MOD\n        \n        return total % MOD",
              "solution_hash": "ffe0659ba90316fb13be805c5e76d89fb4cf7aee22c32ce2f058cc705c6278ab",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpq03r926c.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpq03r926c.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0676279067993164
              },
              "depth": 2,
              "parent_id": "1_24",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_28",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
          "solution_hash": "8c9af7c339d48db89f28428fbc918871e378c14f89e206ce094b6d2411ce91dd",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 262, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 129, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06892132759094238
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_29",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
              "solution_hash": "8c9af7c339d48db89f28428fbc918871e378c14f89e206ce094b6d2411ce91dd",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 262, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 129, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06892132759094238
              },
              "depth": 2,
              "parent_id": "1_28",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_30",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
              "solution_hash": "8c9af7c339d48db89f28428fbc918871e378c14f89e206ce094b6d2411ce91dd",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 262, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 129, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06892132759094238
              },
              "depth": 2,
              "parent_id": "1_28",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_31",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current consecutive subarray\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change direction, start a new subarray with last two elements\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
              "solution_hash": "8c9af7c339d48db89f28428fbc918871e378c14f89e206ce094b6d2411ce91dd",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 262, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 129, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06892132759094238
              },
              "depth": 2,
              "parent_id": "1_28",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_32",
          "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current trend or starting a new trend\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change in direction, reset the current subarray\n                    # The new subarray starts from the previous element\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
          "solution_hash": "8c9af7c339d48db89f28428fbc918871e378c14f89e206ce094b6d2411ce91dd",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 262, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 129, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06892132759094238
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_33",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        prev_diff = None  # None indicates start\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                prev_diff = 0  # 0 represents no previous difference\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_diff = 1\n            elif diff == -1:\n                new_diff = -1\n            else:\n                new_diff = 0  # Not consecutive\n            \n            if new_diff == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                prev_diff = 0\n            else:\n                if prev_diff == new_diff or prev_diff == 0:\n                    # Continue the current trend or starting a new trend\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    prev_diff = new_diff\n                else:\n                    # Change in direction, reset the current subarray\n                    # The new subarray starts from the previous element\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    prev_diff = new_diff\n        \n        return total % MOD",
              "solution_hash": "2d16da7f00fe2225f7efcd664a1240084efaf041bd01a00880865bfb1b185347",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpex9mf2xa.py\", line 264, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpex9mf2xa.py\", line 131, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06788420677185059
              },
              "depth": 2,
              "parent_id": "1_32",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_34",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        current_length = 0\n        direction = 0  # 0: start, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if new_direction == 0:\n                # Start a new subarray\n                current_sum = nums[i]\n                current_length = 1\n                total = (total + current_sum) % MOD\n                direction = 0\n            else:\n                if direction == new_direction or direction == 0:\n                    # Continue the current trend or starting a new trend\n                    current_length += 1\n                    current_sum += nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n                else:\n                    # Change in direction, reset the current subarray\n                    # The new subarray starts from the previous element\n                    current_sum = nums[i-1] + nums[i]\n                    current_length = 2\n                    total = (total + current_sum) % MOD\n                    direction = new_direction\n        \n        return total % MOD",
              "solution_hash": "8c9af7c339d48db89f28428fbc918871e378c14f89e206ce094b6d2411ce91dd",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 262, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplw5uwzmu.py\", line 129, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06892132759094238
              },
              "depth": 2,
              "parent_id": "1_32",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_35",
              "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total = 0\n        current_sum = 0\n        start = 0\n        direction = 0  # 0: not set, 1: increasing, -1: decreasing\n        \n        for i in range(n):\n            if i == 0:\n                current_sum = nums[i]\n                total = (total + current_sum) % MOD\n                continue\n            \n            diff = nums[i] - nums[i-1]\n            if diff == 1:\n                new_direction = 1\n            elif diff == -1:\n                new_direction = -1\n            else:\n                new_direction = 0\n            \n            if i == 1:\n                direction = new_direction\n                current_sum += nums[i]\n                total = (total + current_sum) % MOD\n            else:\n                if new_direction == 0:\n                    # Start new subarray\n                    start = i\n                    current_sum = nums[i]\n                    total = (total + current_sum) % MOD\n                    direction = 0\n                else:\n                    if new_direction == direction:\n                        # Continue the trend\n                        current_sum += nums[i]\n                        total = (total + current_sum) % MOD\n                    else:\n                        # Change in direction, reset start to i-1\n                        start = i - 1\n                        current_sum = nums[start] + nums[i]\n                        total = (total + current_sum) % MOD\n                        direction = new_direction\n            direction = new_direction\n        \n        return total % MOD",
              "solution_hash": "01b05ad23b79c9eb91958549b1ebf74aef9feabb61de8236fb1d0b07afd3c165",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpeajn506a.py\", line 265, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpeajn506a.py\", line 132, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0673666000366211
              },
              "depth": 2,
              "parent_id": "1_32",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 36,
    "candidates_generated": 36,
    "tests_passed": 2,
    "tests_failed": 34,
    "test_errors": 0,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 2813.5996482372284,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.05405405405405406,
      "pass@3": 0.1576576576576577,
      "pass@5": 0.25525525525525516,
      "pass@10": 0.472972972972973
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: name 'pairwise' is not defined",
            "completion_id": 36
          }
        ]
      ]
    },
    "solutions_evaluated": 37,
    "test_cases": 1
  }
}