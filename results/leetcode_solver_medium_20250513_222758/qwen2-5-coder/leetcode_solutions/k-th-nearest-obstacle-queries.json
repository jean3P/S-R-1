{
  "problem_id": "k-th-nearest-obstacle-queries",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "solved",
  "best_solution": "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results",
  "passed_solutions": [
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # This will act as a max-heap by storing negative distances\n        results = []\n        \n        for x, y in queries:\n            distance = -(abs(x) + abs(y))  # Use negative distance to simulate max-heap\n            heapq.heappush(max_heap, distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive distance\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            if len(max_heap) < k:\n                heapq.heappush(max_heap, -distance)\n            elif distance < -max_heap[0]:\n                heapq.heappushpop(max_heap, -distance)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max-heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                # The root of the max-heap is the k-th smallest distance (negated back to positive)\n                results.append(-max_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max-heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) == k:\n                results.append(-max_heap[0])  # Convert back to positive\n            else:\n                results.append(-1)\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) == k:\n                results.append(-max_heap[0])  # Convert back to positive\n            else:\n                results.append(-1)\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # Max-heap to store the k smallest distances\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # Max-heap to store the k smallest distances\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results"
  ],
  "all_solutions": [
    "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # This will act as a max-heap by storing negative distances\n        results = []\n        \n        for x, y in queries:\n            distance = -(abs(x) + abs(y))  # Use negative distance to simulate max-heap\n            heapq.heappush(max_heap, distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive distance\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            if len(max_heap) < k:\n                heapq.heappush(max_heap, -distance)\n            elif distance < -max_heap[0]:\n                heapq.heappushpop(max_heap, -distance)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max-heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                # The root of the max-heap is the k-th smallest distance (negated back to positive)\n                results.append(-max_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                results.append(min_heap[0])\n            else:\n                results.append(-1)\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) >= k:\n                results.append(min_heap[0])\n            else:\n                results.append(-1)\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max-heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) == k:\n                results.append(-max_heap[0])  # Convert back to positive\n            else:\n                results.append(-1)\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) == k:\n                results.append(-max_heap[0])  # Convert back to positive\n            else:\n                results.append(-1)\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # Max-heap to store the k smallest distances\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                results.append(min_heap[0])\n            else:\n                results.append(-1)\n        \n        return results",
    "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # Max-heap to store the k smallest distances\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
    "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results"
  ],
  "total_candidates": 18,
  "nodes_explored": 18,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
      "solution_hash": "9e6974ed31701ebc3668420863ad5fe58bee8cfae1ac7f85a680e49d3b71aba4",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpvt81u8sg.py\", line 193, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmpvt81u8sg.py\", line 104, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
        "execution_time": 0.06968569755554199
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_1",
          "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
          "solution_hash": "137eab093e5eedcde6f7145f3099b36ed88f80b79663549eef0ada3811756785",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06899261474609375
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_2",
          "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
          "solution_hash": "9c75a34f4aee2c8c41d9246adbe7ba98ff67a356c13987279818b565903af8e9",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmph9ba5o6a.py\", line 194, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmph9ba5o6a.py\", line 105, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
            "execution_time": 0.07241606712341309
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_3",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
              "solution_hash": "9c75a34f4aee2c8c41d9246adbe7ba98ff67a356c13987279818b565903af8e9",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmph9ba5o6a.py\", line 194, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmph9ba5o6a.py\", line 105, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
                "execution_time": 0.07241606712341309
              },
              "depth": 2,
              "parent_id": "1_2",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_4",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # This will act as a max-heap by storing negative distances\n        results = []\n        \n        for x, y in queries:\n            distance = -(abs(x) + abs(y))  # Use negative distance to simulate max-heap\n            heapq.heappush(max_heap, distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive distance\n        \n        return results",
              "solution_hash": "22feaa10f81eaea1daa5244024b1623cd1130271398fca2012cfaa80c6ed0286",
              "test_result": {
                "status": "pass",
                "execution_time": 0.06828498840332031
              },
              "depth": 2,
              "parent_id": "1_2",
              "children": [],
              "passed": true
            },
            {
              "node_id": "2_5",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            if len(max_heap) < k:\n                heapq.heappush(max_heap, -distance)\n            elif distance < -max_heap[0]:\n                heapq.heappushpop(max_heap, -distance)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])\n        \n        return results",
              "solution_hash": "18f27a4e98f94d200edd9fbcf72ae592af028d632674b8337a7681220256a7a7",
              "test_result": {
                "status": "pass",
                "execution_time": 0.07273316383361816
              },
              "depth": 2,
              "parent_id": "1_2",
              "children": [],
              "passed": true
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_6",
          "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max-heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
          "solution_hash": "137eab093e5eedcde6f7145f3099b36ed88f80b79663549eef0ada3811756785",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06899261474609375
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [],
          "passed": true
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
      "solution_hash": "9e6974ed31701ebc3668420863ad5fe58bee8cfae1ac7f85a680e49d3b71aba4",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpznk4e82_.py\", line 193, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmpznk4e82_.py\", line 104, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
        "execution_time": 0.07220721244812012
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_8",
          "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                # The root of the max-heap is the k-th smallest distance (negated back to positive)\n                results.append(-max_heap[0])\n        \n        return results",
          "solution_hash": "137eab093e5eedcde6f7145f3099b36ed88f80b79663549eef0ada3811756785",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06899261474609375
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_9",
          "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                results.append(min_heap[0])\n            else:\n                results.append(-1)\n        \n        return results",
          "solution_hash": "9c59b74ce5b5e7349652093c429dac0307bbed1829a5d5ea0747959488e91bb5",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp7o1tjdg9.py\", line 194, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmp7o1tjdg9.py\", line 105, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
            "execution_time": 0.06872320175170898
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_10",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) >= k:\n                results.append(min_heap[0])\n            else:\n                results.append(-1)\n        \n        return results",
              "solution_hash": "60869b3389a69af9d246f582923753e206596449f8ab25f30f96a87cefc5dd03",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp12lmffua.py\", line 194, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmp12lmffua.py\", line 105, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
                "execution_time": 0.06862425804138184
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_11",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(max_heap, -distance)  # Use negative to simulate max-heap\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) == k:\n                results.append(-max_heap[0])  # Convert back to positive\n            else:\n                results.append(-1)\n        \n        return results",
              "solution_hash": "5ea364941c4a39e5ed222990bd325aa30c11fac3e080f61054a7450746ce988f",
              "test_result": {
                "status": "pass",
                "execution_time": 0.06859350204467773
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": true
            },
            {
              "node_id": "2_12",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) == k:\n                results.append(-max_heap[0])  # Convert back to positive\n            else:\n                results.append(-1)\n        \n        return results",
              "solution_hash": "5ea364941c4a39e5ed222990bd325aa30c11fac3e080f61054a7450746ce988f",
              "test_result": {
                "status": "pass",
                "execution_time": 0.06859350204467773
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": true
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_13",
          "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(min_heap[0])\n        \n        return results",
          "solution_hash": "9c75a34f4aee2c8c41d9246adbe7ba98ff67a356c13987279818b565903af8e9",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmph9ba5o6a.py\", line 194, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmph9ba5o6a.py\", line 105, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
            "execution_time": 0.07241606712341309
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_14",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # Max-heap to store the k smallest distances\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
              "solution_hash": "137eab093e5eedcde6f7145f3099b36ed88f80b79663549eef0ada3811756785",
              "test_result": {
                "status": "pass",
                "execution_time": 0.06899261474609375
              },
              "depth": 2,
              "parent_id": "1_13",
              "children": [],
              "passed": true
            },
            {
              "node_id": "2_15",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, distance)\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) == k:\n                results.append(min_heap[0])\n            else:\n                results.append(-1)\n        \n        return results",
              "solution_hash": "9c59b74ce5b5e7349652093c429dac0307bbed1829a5d5ea0747959488e91bb5",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp7o1tjdg9.py\", line 194, in <module>\n    check(Solution().resultsArray)\n  File \"/scratch/local/21419949/tmp7o1tjdg9.py\", line 105, in check\n    assert candidate(queries = [[5, 5], [4, 4], [3, 3]],k = 1) == [10, 8, 6]\nAssertionError\n",
                "execution_time": 0.06872320175170898
              },
              "depth": 2,
              "parent_id": "1_13",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_16",
              "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        max_heap = []  # Max-heap to store the k smallest distances\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            # Use negative distance to simulate a max-heap using heapq (which is a min-heap by default)\n            heapq.heappush(max_heap, -distance)\n            \n            if len(max_heap) > k:\n                heapq.heappop(max_heap)\n            \n            if len(max_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-max_heap[0])  # Convert back to positive\n        \n        return results",
              "solution_hash": "137eab093e5eedcde6f7145f3099b36ed88f80b79663549eef0ada3811756785",
              "test_result": {
                "status": "pass",
                "execution_time": 0.06899261474609375
              },
              "depth": 2,
              "parent_id": "1_13",
              "children": [],
              "passed": true
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results",
      "solution_hash": "125231f8c4f1ecc5273fa4272118ca2459facf695688f6eef45c6d4a14d85ac9",
      "test_result": {
        "status": "pass",
        "execution_time": 0.06734442710876465
      },
      "depth": 0,
      "parent_id": null,
      "children": [],
      "passed": true
    }
  ],
  "stats": {
    "nodes_explored": 18,
    "candidates_generated": 18,
    "tests_passed": 10,
    "tests_failed": 8,
    "test_errors": 0,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 301.57644987106323,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.5789473684210527,
      "pass@3": 0.9422084623323014,
      "pass@5": 0.9951840385276918,
      "pass@10": 1.0
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 18
          }
        ]
      ]
    },
    "solutions_evaluated": 19,
    "test_cases": 1
  }
}