{
  "problem_id": "count-almost-equal-pairs-i",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Normalize each number by sorting its digits\n        normalized = [''.join(sorted(str(num))) for num in nums]\n        \n        # Count occurrences of each normalized form\n        count_map = defaultdict(int)\n        for norm in normalized:\n            count_map[norm] += 1\n        \n        # Calculate the number of almost equal pairs\n        pairs = 0\n        for count in count_map.values():\n            if count > 1:\n                # Combination formula C(n, 2) = n * (n - 1) / 2\n                pairs += count * (count - 1) // 2\n        \n        return pairs",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            diff = []\n            for a, b in zip(x, y):\n                if a != b:\n                    diff.append((a, b))\n                if len(diff) > 2:\n                    return False\n            return len(diff) == 2 and diff[0] == diff[1][::-1]\n        \n        nums_str = list(map(str, nums))\n        count = 0\n        n = len(nums_str)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: str, y: str) -> bool:\n            return sorted(x) == sorted(y)\n        \n        nums_str = list(map(str, nums))\n        count = 0\n        n = len(nums_str)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: int, y: int) -> bool:\n            return sorted(str(x)) == sorted(str(y))\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: str, y: str) -> bool:\n            return sorted(x) == sorted(y)\n        \n        nums_str = list(map(str, nums))\n        count = 0\n        n = len(nums_str)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff_indices = [i for i in range(len(x)) if x[i] != y[i]]\n            \n            # If there are exactly two differing positions, check if swapping them makes the numbers equal\n            if len(diff_indices) == 2:\n                i, j = diff_indices\n                return x[i] == y[j] and x[j] == y[i]\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        nums_str = list(map(str, nums))\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: int, y: int) -> bool:\n            # Convert numbers to strings and sort their digits\n            return sorted(str(x)) == sorted(str(y))\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: int, y: int) -> bool:\n            # Convert numbers to sorted tuples of their digits\n            x_digits = tuple(sorted(str(x)))\n            y_digits = tuple(sorted(str(y)))\n            return x_digits == y_digits\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: int, y: int) -> bool:\n            # Compare the digit counts of the two numbers\n            return Counter(str(x)) == Counter(str(y))\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str_i = str(nums[i])\n            variations_i = generate_swapped_variations(num_str_i)\n            for j in range(i + 1, n):\n                num_str_j = str(nums[j])\n                if num_str_j in variations_i or num_str_i == num_str_j:\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str_i = str(nums[i])\n            variations_i = generate_swapped_variations(num_str_i)\n            for j in range(i + 1, n):\n                if nums[j] in variations_i or nums[i] == nums[j]:\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return ''.join(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Create a dictionary to count occurrences of each sorted digit sequence\n        sorted_digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Sort the digits of the number\n            sorted_num = ''.join(sorted(str(num)))\n            \n            # If this sorted sequence has been seen before, it means we can form pairs\n            if sorted_num in sorted_digit_count:\n                count += sorted_digit_count[sorted_num]\n            \n            # Increment the count of this sorted sequence\n            sorted_digit_count[sorted_num] += 1\n        \n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and sort their digits\n            sx = sorted(str(x))\n            sy = sorted(str(y))\n            # Count mismatches\n            mismatch_count = sum(1 for a, b in zip(sx, sy) if a != b)\n            # They can be almost equal if there are at most 2 mismatches\n            return mismatch_count <= 2 and len(sx) == len(sy)\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            variations = set()\n            for i in range(len(num_str)):\n                for j in range(i + 1, len(num_str)):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]):\n                    count += 1\n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            sorted_num = sort_digits(num)\n            count += sorted_count[sorted_num]\n            sorted_count[sorted_num] += 1\n        \n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Create a dictionary to count occurrences of each sorted digit sequence\n        sorted_digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Sort the digits of the number\n            sorted_num = tuple(sorted(str(num)))\n            \n            # If this sorted sequence has been seen before, it means we can form pairs\n            if sorted_num in sorted_digit_count:\n                count += sorted_digit_count[sorted_num]\n            \n            # Increment the count of this sorted sequence\n            sorted_digit_count[sorted_num] += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            variations = set()\n            for i in range(len(num_str)):\n                for j in range(i + 1, len(num_str)):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]):\n                    count += 1\n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Create a dictionary to count occurrences of each sorted digit tuple\n        sorted_digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Sort the digits of the number\n            sorted_num = tuple(sorted(str(num)))\n            \n            # Add the current count of this sorted tuple to the result\n            count += sorted_digit_count[sorted_num]\n            \n            # Increment the count of this sorted tuple in the dictionary\n            sorted_digit_count[sorted_num] += 1\n        \n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            sorted_num = sorted_digits(num)\n            count += seen[sorted_num]\n            seen[sorted_num] += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            length = len(num_str)\n            variations = set()\n            for i in range(length):\n                for j in range(i + 1, length):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]) or nums[i] in generate_swapped_variations(nums[j]):\n                    count += 1\n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_representation(num):\n            return ''.join(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digit_representation(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Normalize each number by sorting its digits\n        normalized = defaultdict(int)\n        for num in nums:\n            norm_num = tuple(sorted(str(num)))\n            normalized[norm_num] += 1\n        \n        # Calculate the number of almost equal pairs\n        count = 0\n        for freq in normalized.values():\n            if freq > 1:\n                count += freq * (freq - 1) // 2\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_versions(num_str):\n            n = len(num_str)\n            versions = set()\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    versions.add(''.join(swapped))\n            return versions\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            swapped_versions = generate_swapped_versions(num_str)\n            for j in range(i + 1, n):\n                if str(nums[j]) in swapped_versions:\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_versions(num_str):\n            n = len(num_str)\n            versions = set()\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    versions.add(''.join(swapped))\n            return versions\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            swapped_versions = generate_swapped_versions(num_str)\n            for j in range(i + 1, n):\n                if str(nums[j]) in swapped_versions or str(nums[i]) == str(nums[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return ''.join(sorted(str(num)))\n        \n        count_dict = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            sorted_num = sort_digits(num)\n            count += count_dict[sorted_num]\n            count_dict[sorted_num] += 1\n        \n        return count",
    "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_string(num):\n            return ''.join(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digit_string(num) for num in nums]\n        sorted_counter = Counter(sorted_nums)\n        \n        for i in range(n):\n            sorted_num = sorted_nums[i]\n            count += sorted_counter[sorted_num] - 1  # Subtract 1 to exclude the number itself\n            sorted_counter[sorted_num] -= 1  # Decrement to avoid double counting\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            variations = generate_swapped_variations(num_str)\n            for j in range(i + 1, n):\n                if str(nums[j]) in variations:\n                    count += 1\n        \n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            variations.add(int(num_str))  # Include the original number\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            variations = generate_swapped_variations(num_str)\n            for j in range(i + 1, n):\n                if nums[j] in variations:\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return ''.join(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        digit_count = defaultdict(int)\n        \n        for num in nums:\n            sorted_num = sorted_digits(num)\n            count += digit_count[sorted_num]\n            digit_count[sorted_num] += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0] == (diff[1][1], diff[1][0])\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0] == (diff[1][1], diff[1][0]) or diff[1] == (diff[0][1], diff[0][0])\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count"
  ],
  "total_candidates": 39,
  "nodes_explored": 39,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Normalize each number by sorting its digits\n        normalized = [''.join(sorted(str(num))) for num in nums]\n        \n        # Count occurrences of each normalized form\n        count_map = defaultdict(int)\n        for norm in normalized:\n            count_map[norm] += 1\n        \n        # Calculate the number of almost equal pairs\n        pairs = 0\n        for count in count_map.values():\n            if count > 1:\n                # Combination formula C(n, 2) = n * (n - 1) / 2\n                pairs += count * (count - 1) // 2\n        \n        return pairs",
      "solution_hash": "48e0fad4dadeb40a9d22e819d577f4434988073222dbd56391cf014f94171e41",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpivz9v_ef.py\", line 231, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpivz9v_ef.py\", line 105, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
        "execution_time": 0.06757020950317383
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_1",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            diff = []\n            for a, b in zip(x, y):\n                if a != b:\n                    diff.append((a, b))\n                if len(diff) > 2:\n                    return False\n            return len(diff) == 2 and diff[0] == diff[1][::-1]\n        \n        nums_str = list(map(str, nums))\n        count = 0\n        n = len(nums_str)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
          "solution_hash": "41b33123ca15317ccd74ee1f488fb21856e4f970bb2016e6bc30a51e60d5f4c2",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmprzwvn2sj.py\", line 236, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmprzwvn2sj.py\", line 110, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.0687260627746582
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_2",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: str, y: str) -> bool:\n            return sorted(x) == sorted(y)\n        \n        nums_str = list(map(str, nums))\n        count = 0\n        n = len(nums_str)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "70ebd50f1bd543dee38e16a8b07f665be66fdcbc9c90b83f01863b64e906ad09",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp67loyny4.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp67loyny4.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06637430191040039
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_3",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: int, y: int) -> bool:\n            return sorted(str(x)) == sorted(str(y))\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "b4176719dc3a46d85df53d0c717f31047528f9a078d357dcbfa23f806ce0c422",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpifc6ztgi.py\", line 227, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpifc6ztgi.py\", line 101, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06594395637512207
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_4",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x: str, y: str) -> bool:\n            return sorted(x) == sorted(y)\n        \n        nums_str = list(map(str, nums))\n        count = 0\n        n = len(nums_str)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "70ebd50f1bd543dee38e16a8b07f665be66fdcbc9c90b83f01863b64e906ad09",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp67loyny4.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp67loyny4.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06637430191040039
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_5",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff_indices = [i for i in range(len(x)) if x[i] != y[i]]\n            \n            # If there are exactly two differing positions, check if swapping them makes the numbers equal\n            if len(diff_indices) == 2:\n                i, j = diff_indices\n                return x[i] == y[j] and x[j] == y[i]\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        nums_str = list(map(str, nums))\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums_str[i], nums_str[j]):\n                    count += 1\n        \n        return count",
          "solution_hash": "d9f2c548b08c43a567cc4b3234ffa81cb2564dec506cea57adf03f65caa463b9",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp2vl4z15h.py\", line 238, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp2vl4z15h.py\", line 112, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.06557178497314453
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_6",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: int, y: int) -> bool:\n            # Convert numbers to strings and sort their digits\n            return sorted(str(x)) == sorted(str(y))\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "a0f0ce9fb6b513cfc80e38e010c0328dbe6b9167a4fbb9f8da8a5e98b8f49cc4",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpbniqvq96.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpbniqvq96.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06681704521179199
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_7",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: int, y: int) -> bool:\n            # Convert numbers to sorted tuples of their digits\n            x_digits = tuple(sorted(str(x)))\n            y_digits = tuple(sorted(str(y)))\n            return x_digits == y_digits\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "7b4baa1ce82b0d2e1fcc005f85aebf1aa990e005a1f1c6850f0288fa290c22b7",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmphfcl5uil.py\", line 230, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmphfcl5uil.py\", line 104, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06704354286193848
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_8",
              "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_swap(x: int, y: int) -> bool:\n            # Compare the digit counts of the two numbers\n            return Counter(str(x)) == Counter(str(y))\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_swap(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "063f932a2a79ce75d15d08088a1ed5fe17bc1a15856722b04e04694e7713235e",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpmr00sl6i.py\", line 229, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpmr00sl6i.py\", line 103, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06820082664489746
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_9",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str_i = str(nums[i])\n            variations_i = generate_swapped_variations(num_str_i)\n            for j in range(i + 1, n):\n                num_str_j = str(nums[j])\n                if num_str_j in variations_i or num_str_i == num_str_j:\n                    count += 1\n        \n        return count",
          "solution_hash": "901c28549315d3b7ab5501a4ed240462ca7769edc8e3ecba80812d99888a82ff",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpc_jmh_cg.py\", line 236, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpc_jmh_cg.py\", line 110, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.06779217720031738
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_10",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str_i = str(nums[i])\n            variations_i = generate_swapped_variations(num_str_i)\n            for j in range(i + 1, n):\n                if nums[j] in variations_i or nums[i] == nums[j]:\n                    count += 1\n        \n        return count",
              "solution_hash": "05232935e7770a65a0665a655884d068be1ea37318b862836edd7fbbb34d1a23",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpqusbcpo3.py\", line 235, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpqusbcpo3.py\", line 109, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06696629524230957
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_11",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return ''.join(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
              "solution_hash": "7d38b3c3902a202d4764c2c919643b8836f9d6185bcfdab025f12f9641b0bebb",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmppojfqc0q.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmppojfqc0q.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06578397750854492
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_12",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Create a dictionary to count occurrences of each sorted digit sequence\n        sorted_digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Sort the digits of the number\n            sorted_num = ''.join(sorted(str(num)))\n            \n            # If this sorted sequence has been seen before, it means we can form pairs\n            if sorted_num in sorted_digit_count:\n                count += sorted_digit_count[sorted_num]\n            \n            # Increment the count of this sorted sequence\n            sorted_digit_count[sorted_num] += 1\n        \n        return count",
              "solution_hash": "1de9fe07a8e304b395b16136147c31ded95b2d7bef8327a507abb39df1594a19",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpp5qw3ebq.py\", line 232, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpp5qw3ebq.py\", line 106, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06572437286376953
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and sort their digits\n            sx = sorted(str(x))\n            sy = sorted(str(y))\n            # Count mismatches\n            mismatch_count = sum(1 for a, b in zip(sx, sy) if a != b)\n            # They can be almost equal if there are at most 2 mismatches\n            return mismatch_count <= 2 and len(sx) == len(sy)\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "solution_hash": "a0afd828166478e5420c94b6b310d2f2f6f2f6b8f1adacf912f71abc6e2fa544",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpyvacqzrs.py\", line 229, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpyvacqzrs.py\", line 103, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
        "execution_time": 0.06546568870544434
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_14",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            variations = set()\n            for i in range(len(num_str)):\n                for j in range(i + 1, len(num_str)):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]):\n                    count += 1\n        return count",
          "solution_hash": "73ba67f5414198f9d805a2602dedae1319ff1681b60038bae655788dc6f3b2c3",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpmenbvhtq.py\", line 232, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpmenbvhtq.py\", line 106, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.06649160385131836
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_15",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
              "solution_hash": "dc9af22fee4bef9c41d91ab35c4f0016c4c39ab5aeca18a6eec6fda629bbed9c",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpgaeozw7k.py\", line 227, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpgaeozw7k.py\", line 101, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06601738929748535
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_16",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            sorted_num = sort_digits(num)\n            count += sorted_count[sorted_num]\n            sorted_count[sorted_num] += 1\n        \n        return count",
              "solution_hash": "69043886326598e866c2cfa8d69d62324bb697fd4a7747e8740f6038f15c0c7a",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpk7rucst6.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpk7rucst6.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06625723838806152
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_17",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Create a dictionary to count occurrences of each sorted digit sequence\n        sorted_digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Sort the digits of the number\n            sorted_num = tuple(sorted(str(num)))\n            \n            # If this sorted sequence has been seen before, it means we can form pairs\n            if sorted_num in sorted_digit_count:\n                count += sorted_digit_count[sorted_num]\n            \n            # Increment the count of this sorted sequence\n            sorted_digit_count[sorted_num] += 1\n        \n        return count",
              "solution_hash": "312e3ed7e81d59903287ea615b8cf249b36246924c49df93c0ff17ed543efb11",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp3bulmiqr.py\", line 232, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp3bulmiqr.py\", line 106, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06679081916809082
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_18",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            variations = set()\n            for i in range(len(num_str)):\n                for j in range(i + 1, len(num_str)):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]):\n                    count += 1\n        return count",
          "solution_hash": "73ba67f5414198f9d805a2602dedae1319ff1681b60038bae655788dc6f3b2c3",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpmenbvhtq.py\", line 232, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpmenbvhtq.py\", line 106, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.06649160385131836
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_19",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Create a dictionary to count occurrences of each sorted digit tuple\n        sorted_digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Sort the digits of the number\n            sorted_num = tuple(sorted(str(num)))\n            \n            # Add the current count of this sorted tuple to the result\n            count += sorted_digit_count[sorted_num]\n            \n            # Increment the count of this sorted tuple in the dictionary\n            sorted_digit_count[sorted_num] += 1\n        \n        return count",
              "solution_hash": "e04f127239505b17241f4d36f64a6aa05d8fff38943eabc3ef93ad9c824a3527",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpvrpkb5kv.py\", line 231, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpvrpkb5kv.py\", line 105, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06753373146057129
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_20",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            sorted_num = sorted_digits(num)\n            count += seen[sorted_num]\n            seen[sorted_num] += 1\n        \n        return count",
              "solution_hash": "c4b434795b4d4f55e19d75c85b5d244e2782bdc15c34d1520cd2499c0b335921",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpsn_i7wiq.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpsn_i7wiq.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.0650625228881836
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_21",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
              "solution_hash": "5b5e04c010568faedc0bd995748e03517ad94dad055a3658e7e1f88db85568be",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplfv8i__8.py\", line 226, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmplfv8i__8.py\", line 100, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06563401222229004
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_22",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            length = len(num_str)\n            variations = set()\n            for i in range(length):\n                for j in range(i + 1, length):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]) or nums[i] in generate_swapped_variations(nums[j]):\n                    count += 1\n        return count",
          "solution_hash": "62774eea230fde519d6e996282f3708d65feac032d1a575a3a1447460799f828",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpwtxe48ce.py\", line 233, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpwtxe48ce.py\", line 119, in check\n    assert candidate(nums = [123, 321, 231, 123, 132, 213]) == 10\nAssertionError\n",
            "execution_time": 0.06685066223144531
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_23",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
              "solution_hash": "dc9af22fee4bef9c41d91ab35c4f0016c4c39ab5aeca18a6eec6fda629bbed9c",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpgaeozw7k.py\", line 227, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpgaeozw7k.py\", line 101, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06601738929748535
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_24",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_representation(num):\n            return ''.join(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digit_representation(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
              "solution_hash": "d2a194df37a9555076c6f749adc0c50f361fa0785bf837229c3f49d84285cf14",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpug8y9jf9.py\", line 227, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpug8y9jf9.py\", line 101, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.0670022964477539
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_25",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
              "solution_hash": "5b5e04c010568faedc0bd995748e03517ad94dad055a3658e7e1f88db85568be",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplfv8i__8.py\", line 226, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmplfv8i__8.py\", line 100, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06563401222229004
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Normalize each number by sorting its digits\n        normalized = defaultdict(int)\n        for num in nums:\n            norm_num = tuple(sorted(str(num)))\n            normalized[norm_num] += 1\n        \n        # Calculate the number of almost equal pairs\n        count = 0\n        for freq in normalized.values():\n            if freq > 1:\n                count += freq * (freq - 1) // 2\n        \n        return count",
      "solution_hash": "fb01eec8b926c431c19ea8b77bb072357e79f5ea0a6c2187f56c8cc8401cfa14",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpqosl028t.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpqosl028t.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
        "execution_time": 0.06618213653564453
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_27",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_versions(num_str):\n            n = len(num_str)\n            versions = set()\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    versions.add(''.join(swapped))\n            return versions\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            swapped_versions = generate_swapped_versions(num_str)\n            for j in range(i + 1, n):\n                if str(nums[j]) in swapped_versions:\n                    count += 1\n        \n        return count",
          "solution_hash": "96b8bf171e348261709f53f53032f38934b5a1fef71079c5c21390791a7c051e",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpte8s7wgc.py\", line 235, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpte8s7wgc.py\", line 109, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.06711411476135254
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_28",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_versions(num_str):\n            n = len(num_str)\n            versions = set()\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    versions.add(''.join(swapped))\n            return versions\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            swapped_versions = generate_swapped_versions(num_str)\n            for j in range(i + 1, n):\n                if str(nums[j]) in swapped_versions or str(nums[i]) == str(nums[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "fc526b15caf5a8b255ecc892d948d5ce49690a17f85dc18662dc1a1f9e3c4e14",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp_lhabcxp.py\", line 235, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp_lhabcxp.py\", line 109, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06684446334838867
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_29",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return ''.join(sorted(str(num)))\n        \n        count_dict = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            sorted_num = sort_digits(num)\n            count += count_dict[sorted_num]\n            count_dict[sorted_num] += 1\n        \n        return count",
              "solution_hash": "a949617f9a1ae68de08be7c46ac30d41f9a6ba58d28deb79cfdeef6497b6b44e",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp2fbjvl6x.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp2fbjvl6x.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06578516960144043
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_30",
              "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_string(num):\n            return ''.join(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digit_string(num) for num in nums]\n        sorted_counter = Counter(sorted_nums)\n        \n        for i in range(n):\n            sorted_num = sorted_nums[i]\n            count += sorted_counter[sorted_num] - 1  # Subtract 1 to exclude the number itself\n            sorted_counter[sorted_num] -= 1  # Decrement to avoid double counting\n        \n        return count",
              "solution_hash": "e69790cf8e647b3877370271ce34ff076390ab11aa50d18b4af41081f063cabe",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpm2mlfedo.py\", line 230, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpm2mlfedo.py\", line 104, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06488251686096191
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_31",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            variations = generate_swapped_variations(num_str)\n            for j in range(i + 1, n):\n                if str(nums[j]) in variations:\n                    count += 1\n        \n        return count",
          "solution_hash": "0be8b1f27daee9a39100e6a88d77da56192434ce579d5eb9e49404f2bc1646e1",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp5n5jajma.py\", line 235, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp5n5jajma.py\", line 109, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.06461048126220703
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_32",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            variations.add(int(num_str))  # Include the original number\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str = str(nums[i])\n            variations = generate_swapped_variations(num_str)\n            for j in range(i + 1, n):\n                if nums[j] in variations:\n                    count += 1\n        \n        return count",
              "solution_hash": "832bab652331899f77274faedb0560ded570ee326829470cac8eafbad7f2dd09",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpp_ufhvep.py\", line 237, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpp_ufhvep.py\", line 111, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06684374809265137
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_33",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return ''.join(sorted(str(num)))\n        \n        sorted_nums = [sort_digits(num) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
              "solution_hash": "7d38b3c3902a202d4764c2c919643b8836f9d6185bcfdab025f12f9641b0bebb",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmppojfqc0q.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmppojfqc0q.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06578397750854492
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_34",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        digit_count = defaultdict(int)\n        \n        for num in nums:\n            sorted_num = sorted_digits(num)\n            count += digit_count[sorted_num]\n            digit_count[sorted_num] += 1\n        \n        return count",
              "solution_hash": "25b94d42837af1ecfc8e425589e85976bea522336ad40b379bee760b8f88f4c1",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp238w572a.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp238w572a.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06511497497558594
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_35",
          "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0] == (diff[1][1], diff[1][0])\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count",
          "solution_hash": "c86645f0fd4e716d7488fb1fe1cf2126a1d32fd65635b9d1bdaafcfd3ca86c81",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpnvw790ku.py\", line 242, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmpnvw790ku.py\", line 116, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
            "execution_time": 0.06636953353881836
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_36",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count",
              "solution_hash": "f7e4ecfe714c0f4f7910f740843d0670fa43306e489b8dca759e214ae425c968",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp79q56q6j.py\", line 242, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp79q56q6j.py\", line 116, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06691479682922363
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_37",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0] == (diff[1][1], diff[1][0]) or diff[1] == (diff[0][1], diff[0][0])\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count",
              "solution_hash": "0a67c0a6ba63209cd92b6e60f38e8851be24dd6b5981a60f7f2dd2cb63252845",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp6y0tx8hc.py\", line 242, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp6y0tx8hc.py\", line 116, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06512832641601562
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_38",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_made_equal_by_one_swap(x: str, y: str) -> bool:\n            if len(x) != len(y):\n                return False\n            \n            diff = []\n            for i in range(len(x)):\n                if x[i] != y[i]:\n                    diff.append((x[i], y[i]))\n                \n                if len(diff) > 2:\n                    return False\n            \n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                return diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_made_equal_by_one_swap(str(nums[i]), str(nums[j])):\n                    count += 1\n        \n        return count",
              "solution_hash": "f7e4ecfe714c0f4f7910f740843d0670fa43306e489b8dca759e214ae425c968",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp79q56q6j.py\", line 242, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419949/tmp79q56q6j.py\", line 116, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n",
                "execution_time": 0.06691479682922363
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 39,
    "candidates_generated": 39,
    "tests_passed": 0,
    "tests_failed": 39,
    "test_errors": 0,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 646.4369916915894,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.025000000000000022,
      "pass@3": 0.07499999999999996,
      "pass@5": 0.125,
      "pass@10": 0.25
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 37
          }
        ],
        [
          38,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 38
          }
        ],
        [
          39,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 39
          }
        ]
      ]
    },
    "solutions_evaluated": 40,
    "test_cases": 1
  }
}