{
  "problem_id": "sum-of-consecutive-subarrays",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum = (total_sum + nums[start + j] * (length - j)) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, start + length):\n                # Sum of subarrays starting at index j\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, start + length):\n                # Sum of subarrays starting at index j\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, start + length):\n                # Sum of subarrays starting at index j\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            current_sum = 0\n            length = 0\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                length += 1\n                current_sum = (current_sum + nums[i] * (length + 1)) % MOD\n                i += 1\n            \n            # Add the last element of the current sequence\n            length += 1\n            current_sum = (current_sum + nums[i] * (length + 1)) % MOD\n            \n            # Add the current sequence's sum to the total sum\n            total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            # Sum of all subarrays formula: (length * (length + 1) / 2) * (sum of the sequence)\n            sequence_sum = sum(nums[start:i+1])\n            total_sum = (total_sum + sequence_sum * length * (length + 1) // 2) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] in all subarrays starting from nums[j]\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] in all subarrays starting from nums[j]\n                total_sum = (total_sum + nums[j] * (j - start + 1) * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_sum = 0\n        length = 0\n        \n        for i in range(n):\n            if i == 0 or nums[i] - nums[i - 1] not in [1, -1]:\n                # Reset the current sum and length if the sequence breaks\n                current_sum = nums[i]\n                length = 1\n            else:\n                # Extend the current consecutive sequence\n                current_sum += nums[i]\n                length += 1\n            \n            # Add the sum of all subarrays ending at the current position\n            total_sum = (total_sum + current_sum * length) % MOD\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_start = 0\n        \n        for i in range(1, n):\n            if nums[i] - nums[i - 1] not in [1, -1]:\n                # Calculate the sum of all subarrays in the previous consecutive sequence\n                length = i - current_start\n                for j in range(current_start, i):\n                    total_sum = (total_sum + nums[j] * (j - current_start + 1) * (length - (j - current_start))) % MOD\n                current_start = i\n        \n        # Handle the last consecutive sequence\n        length = n - current_start\n        for j in range(current_start, n):\n            total_sum = (total_sum + nums[j] * (j - current_start + 1) * (length - (j - current_start))) % MOD\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_sum = 0\n        length = 0\n        \n        for i in range(n):\n            if i == 0 or nums[i] - nums[i - 1] not in [1, -1]:\n                # Reset the current sum and length if the sequence breaks\n                current_sum = nums[i]\n                length = 1\n            else:\n                # Extend the current consecutive sequence\n                current_sum += nums[i]\n                length += 1\n            \n            # Add the contribution of the current element to the total sum\n            total_sum = (total_sum + current_sum) % MOD\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_length = 1\n        \n        for i in range(1, n):\n            if nums[i] - nums[i - 1] in [1, -1]:\n                current_length += 1\n            else:\n                # Calculate the sum of all subarrays in the current consecutive segment\n                total_sum = (total_sum + self.sum_of_consecutive_subarrays(nums[i - current_length:i])) % MOD\n                current_length = 1\n        \n        # Add the last segment\n        total_sum = (total_sum + self.sum_of_consecutive_subarrays(nums[n - current_length:n])) % MOD\n        \n        return total_sum\n    \n    def sum_of_consecutive_subarrays(self, subarray: List[int]) -> int:\n        n = len(subarray)\n        total = 0\n        for i in range(n):\n            # Each element contributes to (i + 1) * (n - i) subarrays\n            total += subarray[i] * (i + 1) * (n - i)\n        return total",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            subarray_sum = 0\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                subarray_sum += current_sum\n            \n            total_sum = (total_sum + subarray_sum) % MOD\n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Sum of all subarrays in the range nums[start:end]\n            # For each starting point i in the range, the subarrays are:\n            # nums[i], nums[i:i+1], ..., nums[i:end]\n            # The sum of these subarrays can be computed using the formula for the sum of arithmetic series\n            subarray_sum = 0\n            for i in range(length):\n                # Sum of subarrays starting at index i\n                subarray_sum += (length - i) * (nums[start + i] * (i + 1) + (i * (i + 1)) // 2)\n            \n            total_sum = (total_sum + subarray_sum) % MOD\n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        current_sum = nums[0]\n        length = 1\n        \n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1 or nums[i] == nums[i - 1] - 1:\n                length += 1\n                current_sum += nums[i]\n            else:\n                # Calculate the sum of all subarrays in the current segment\n                total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n                # Reset for the next segment\n                length = 1\n                current_sum = nums[i]\n        \n        # Add the last segment\n        total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range nums[start:end]\n            for i in range(start, end):\n                # Sum of subarrays starting at index i\n                subarray_sum = (end - i) * nums[i]\n                total_sum = (total_sum + subarray_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range nums[start:end]\n            segment_length = end - start\n            segment_sum = 0\n            current_sum = 0\n            \n            for i in range(segment_length):\n                current_sum += nums[start + i]\n                segment_sum += current_sum\n            \n            total_sum = (total_sum + segment_sum) % MOD\n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            subarray_sum = 0\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                subarray_sum += current_sum\n            \n            total_sum = (total_sum + subarray_sum) % MOD\n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                # Add the sum of subarrays ending at index i\n                total_sum = (total_sum + current_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Calculate the sum of all subarrays in the range [start, end)\n            for i in range(start, end):\n                # Sum of subarrays starting at i\n                subarray_sum = (length - (i - start)) * nums[i]\n                total_sum = (total_sum + subarray_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Sum of all subarrays in the range [start, end)\n            # For each starting point i in [start, end), the number of subarrays ending at j (i <= j < end) is (j - i + 1)\n            # The contribution of nums[i] to the total sum is nums[i] * (number of times it appears in all subarrays)\n            # This can be calculated as nums[i] * (length - i) * (i - start + 1)\n            for i in range(start, end):\n                total_sum = (total_sum + nums[i] * (length - i) * (i - start + 1)) % MOD\n            \n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Calculate the sum of all subarrays in the range [start, end)\n            # For a segment of length `length`, the sum of all subarrays can be calculated using the formula:\n            # sum = (length * (length + 1) / 2) * (sum of the segment)\n            segment_sum = sum(nums[start:end])\n            total_sum = (total_sum + (length * (length + 1) // 2) * segment_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        current_sum = nums[0]\n        length = 1\n        \n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1 or nums[i] == nums[i - 1] - 1:\n                length += 1\n                current_sum += nums[i]\n            else:\n                # Calculate the sum of all subarrays in the current consecutive segment\n                total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n                # Reset for the next segment\n                current_sum = nums[i]\n                length = 1\n        \n        # Add the last segment\n        total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            current_sum = nums[start]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                current_sum += nums[end]\n                length = end - start + 1\n                total_sum = (total_sum + current_sum) % MOD\n                end += 1\n            \n            start = end\n        \n        return total_sum",
    "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            direction = None\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i + 1] == nums[i] + 1:\n                    direction = 1\n                elif nums[i + 1] == nums[i] - 1:\n                    direction = -1\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and ((direction == 1 and nums[i + 1] == nums[i] + 1) or \n                                 (direction == -1 and nums[i + 1] == nums[i] - 1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum = (total_sum + nums[start + j] * (j + 1) * (length - j)) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Add the single element subarray sum\n            total_sum = (total_sum + nums[i]) % MOD\n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the last element of the increasing sequence\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the start for decreasing sequence check\n            i = start\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1  # Move to the next unprocessed element\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset i and current_sum for decreasing sequence check\n            i = start\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1  # Move to the next element\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            direction = None\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i + 1] == nums[i] + 1:\n                    direction = 1\n                elif nums[i + 1] == nums[i] - 1:\n                    direction = -1\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and ((direction == 1 and nums[i + 1] == nums[i] + 1) or \n                                 (direction == -1 and nums[i + 1] == nums[i] - 1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the start and check for decreasing consecutive sequence\n            i = start\n            current_sum = nums[i]\n            \n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_sum = 0\n        length = 0\n        direction = None\n        \n        for i in range(n):\n            if i == 0 or nums[i] != nums[i - 1] + 1 and nums[i] != nums[i - 1] - 1:\n                # Reset for a new sequence\n                current_sum = nums[i]\n                length = 1\n                direction = nums[i] - nums[i - 1] if i > 0 else None\n            else:\n                # Continue the current sequence\n                if direction is None or (direction == 1 and nums[i] == nums[i - 1] + 1) or (direction == -1 and nums[i] == nums[i - 1] - 1):\n                    current_sum += nums[i]\n                    length += 1\n                else:\n                    # Sequence changed direction, reset\n                    current_sum = nums[i]\n                    length = 1\n                    direction = nums[i] - nums[i - 1]\n            \n            # Add the sum of all subarrays ending at the current position\n            total_sum = (total_sum + current_sum * length) % MOD\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            direction = None\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i + 1] == nums[i] + 1:\n                    direction = 1\n                elif nums[i + 1] == nums[i] - 1:\n                    direction = -1\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and ((direction == 1 and nums[i + 1] == nums[i] + 1) or \n                                 (direction == -1 and nums[i + 1] == nums[i] - 1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Move to the next element\n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Add single element subarray sum\n            total_sum = (total_sum + nums[i]) % MOD\n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the last element of the increasing sequence\n            i = start\n            \n            # Check for decreasing consecutive sequence\n            current_sum = nums[i]\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Move to the next element\n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            i = start\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
    "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum"
  ],
  "total_candidates": 39,
  "nodes_explored": 39,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum = (total_sum + nums[start + j] * (length - j)) % MOD\n            \n            i += 1\n        \n        return total_sum",
      "solution_hash": "a7ab68a78ab498f3af9a4bf46f7653c7af8e3fad183abd948422634750215585",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpf50yvo65.py\", line 244, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpf50yvo65.py\", line 111, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
        "execution_time": 0.06686806678771973
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_1",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, start + length):\n                # Sum of subarrays starting at index j\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
          "solution_hash": "34a37c1df6e24cfb6750a58aefab10d9ddaad02cfb3c324f3c6e42815b981183",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmprmwkinnd.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmprmwkinnd.py\", line 114, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06692695617675781
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_2",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, start + length):\n                # Sum of subarrays starting at index j\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "34a37c1df6e24cfb6750a58aefab10d9ddaad02cfb3c324f3c6e42815b981183",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmprmwkinnd.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmprmwkinnd.py\", line 114, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06692695617675781
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_3",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, start + length):\n                # Sum of subarrays starting at index j\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "34a37c1df6e24cfb6750a58aefab10d9ddaad02cfb3c324f3c6e42815b981183",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmprmwkinnd.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmprmwkinnd.py\", line 114, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06692695617675781
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_4",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            current_sum = 0\n            length = 0\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                length += 1\n                current_sum = (current_sum + nums[i] * (length + 1)) % MOD\n                i += 1\n            \n            # Add the last element of the current sequence\n            length += 1\n            current_sum = (current_sum + nums[i] * (length + 1)) % MOD\n            \n            # Add the current sequence's sum to the total sum\n            total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "c130defc30d62411310c6a71b2b623969ea192b60fc360d9549e7e537ba9727e",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpuqmfxlqk.py\", line 252, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpuqmfxlqk.py\", line 119, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06668615341186523
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_5",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            # Sum of all subarrays formula: (length * (length + 1) / 2) * (sum of the sequence)\n            sequence_sum = sum(nums[start:i+1])\n            total_sum = (total_sum + sequence_sum * length * (length + 1) // 2) % MOD\n            \n            i += 1\n        \n        return total_sum",
          "solution_hash": "a7ecfcf524ae62ddd3128a7fb8c55aeaa33443b3818d861505a39599cb43ec29",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp28syufod.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp28syufod.py\", line 114, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06691837310791016
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_6",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] in all subarrays starting from nums[j]\n                total_sum = (total_sum + nums[j] * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "34c683c07135a7d913f33b79ca60acf067920850c8f2564e685c46869d90f7d3",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpdqrg95_z.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpdqrg95_z.py\", line 114, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06688666343688965
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_7",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] in all subarrays starting from nums[j]\n                total_sum = (total_sum + nums[j] * (j - start + 1) * (length - (j - start))) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "031c97613e3a0dd3eb798517df180b149a1bea8c920dfc00d48f6e9ca84ba5e2",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp2azxbdu4.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp2azxbdu4.py\", line 123, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n",
                "execution_time": 0.06563639640808105
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_8",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "7d120336914d351631b2df4ecb89a3320687c59b4546e15c9452c3bb58a62c3b",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpo2dgzgub.py\", line 248, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpo2dgzgub.py\", line 115, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06641077995300293
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_9",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_sum = 0\n        length = 0\n        \n        for i in range(n):\n            if i == 0 or nums[i] - nums[i - 1] not in [1, -1]:\n                # Reset the current sum and length if the sequence breaks\n                current_sum = nums[i]\n                length = 1\n            else:\n                # Extend the current consecutive sequence\n                current_sum += nums[i]\n                length += 1\n            \n            # Add the sum of all subarrays ending at the current position\n            total_sum = (total_sum + current_sum * length) % MOD\n        \n        return total_sum",
          "solution_hash": "aeeabeec226106db35655bcd1555582f86b2d0767e9ccdc2d9f20d0ee891a72b",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpz8kz3vke.py\", line 241, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpz8kz3vke.py\", line 108, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.07286500930786133
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_10",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_start = 0\n        \n        for i in range(1, n):\n            if nums[i] - nums[i - 1] not in [1, -1]:\n                # Calculate the sum of all subarrays in the previous consecutive sequence\n                length = i - current_start\n                for j in range(current_start, i):\n                    total_sum = (total_sum + nums[j] * (j - current_start + 1) * (length - (j - current_start))) % MOD\n                current_start = i\n        \n        # Handle the last consecutive sequence\n        length = n - current_start\n        for j in range(current_start, n):\n            total_sum = (total_sum + nums[j] * (j - current_start + 1) * (length - (j - current_start))) % MOD\n        \n        return total_sum",
              "solution_hash": "8f3d4c79cfa1813d8493b5d7872f3fdcbeb982213e00c15e70fa8b4e598b840e",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp3wacnxr2.py\", line 240, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp3wacnxr2.py\", line 116, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n",
                "execution_time": 0.06722450256347656
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_11",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_sum = 0\n        length = 0\n        \n        for i in range(n):\n            if i == 0 or nums[i] - nums[i - 1] not in [1, -1]:\n                # Reset the current sum and length if the sequence breaks\n                current_sum = nums[i]\n                length = 1\n            else:\n                # Extend the current consecutive sequence\n                current_sum += nums[i]\n                length += 1\n            \n            # Add the contribution of the current element to the total sum\n            total_sum = (total_sum + current_sum) % MOD\n        \n        return total_sum",
              "solution_hash": "f4b3cc369d46012e6846e952ebe59ebca737ff3e34fabab441bca59db6723cb4",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpxi_qnoaz.py\", line 241, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpxi_qnoaz.py\", line 108, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0710446834564209
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_12",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_length = 1\n        \n        for i in range(1, n):\n            if nums[i] - nums[i - 1] in [1, -1]:\n                current_length += 1\n            else:\n                # Calculate the sum of all subarrays in the current consecutive segment\n                total_sum = (total_sum + self.sum_of_consecutive_subarrays(nums[i - current_length:i])) % MOD\n                current_length = 1\n        \n        # Add the last segment\n        total_sum = (total_sum + self.sum_of_consecutive_subarrays(nums[n - current_length:n])) % MOD\n        \n        return total_sum\n    \n    def sum_of_consecutive_subarrays(self, subarray: List[int]) -> int:\n        n = len(subarray)\n        total = 0\n        for i in range(n):\n            # Each element contributes to (i + 1) * (n - i) subarrays\n            total += subarray[i] * (i + 1) * (n - i)\n        return total",
              "solution_hash": "600ef372effb4bed36c37d4a7165b3082421b3d877060e57dd7664a8b053d1d0",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmplxij6al_.py\", line 246, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmplxij6al_.py\", line 122, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n",
                "execution_time": 0.06590962409973145
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            subarray_sum = 0\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                subarray_sum += current_sum\n            \n            total_sum = (total_sum + subarray_sum) % MOD\n            start = end\n        \n        return total_sum",
      "solution_hash": "7c76635b959195c0db4cbe327334c5166dc3122c076520481e95e93bb7256b57",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpam1qnfrs.py\", line 243, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpam1qnfrs.py\", line 110, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
        "execution_time": 0.06635594367980957
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_14",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Sum of all subarrays in the range nums[start:end]\n            # For each starting point i in the range, the subarrays are:\n            # nums[i], nums[i:i+1], ..., nums[i:end]\n            # The sum of these subarrays can be computed using the formula for the sum of arithmetic series\n            subarray_sum = 0\n            for i in range(length):\n                # Sum of subarrays starting at index i\n                subarray_sum += (length - i) * (nums[start + i] * (i + 1) + (i * (i + 1)) // 2)\n            \n            total_sum = (total_sum + subarray_sum) % MOD\n            start = end\n        \n        return total_sum",
          "solution_hash": "462e67d2e86063a4c7059f8cc32f563fa9d853b0ce539a809cd3ceeccb647982",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpu6_rk7m7.py\", line 248, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpu6_rk7m7.py\", line 115, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06646895408630371
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_15",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        current_sum = nums[0]\n        length = 1\n        \n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1 or nums[i] == nums[i - 1] - 1:\n                length += 1\n                current_sum += nums[i]\n            else:\n                # Calculate the sum of all subarrays in the current segment\n                total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n                # Reset for the next segment\n                length = 1\n                current_sum = nums[i]\n        \n        # Add the last segment\n        total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n        \n        return total_sum",
              "solution_hash": "7d7780ba4aeef1175208226f84662e3a9465cfedf7e2b5796bd0fbfc6de57736",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpn2lebzr3.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpn2lebzr3.py\", line 112, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06876039505004883
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_16",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range nums[start:end]\n            for i in range(start, end):\n                # Sum of subarrays starting at index i\n                subarray_sum = (end - i) * nums[i]\n                total_sum = (total_sum + subarray_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
              "solution_hash": "7d853f43ca1115219f5744193b5141e31ff6170efea7f71cde6afa11efc961d8",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpudgo41as.py\", line 243, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpudgo41as.py\", line 110, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.07254695892333984
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_17",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range nums[start:end]\n            segment_length = end - start\n            segment_sum = 0\n            current_sum = 0\n            \n            for i in range(segment_length):\n                current_sum += nums[start + i]\n                segment_sum += current_sum\n            \n            total_sum = (total_sum + segment_sum) % MOD\n            start = end\n        \n        return total_sum",
              "solution_hash": "7c00046af4ceeffd1fec2319b6857e7b3ced11c1c7bedc830b60e4e4a52e9a00",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpi9ueh9s5.py\", line 247, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpi9ueh9s5.py\", line 114, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0719294548034668
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_18",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            subarray_sum = 0\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                subarray_sum += current_sum\n            \n            total_sum = (total_sum + subarray_sum) % MOD\n            start = end\n        \n        return total_sum",
          "solution_hash": "7648a23117d33b42aba453d8f1032b7f30e8b91bce885df4beec463572043b60",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpu304dj0h.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpu304dj0h.py\", line 112, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06728935241699219
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_19",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
              "solution_hash": "a02351262a47d344f8fe3cfb76feb2dab693c052bd474d5f4941207d669c1fd8",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpnkdbba1x.py\", line 243, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpnkdbba1x.py\", line 110, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0681159496307373
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_20",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                # Add the sum of subarrays ending at index i\n                total_sum = (total_sum + current_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
              "solution_hash": "a02351262a47d344f8fe3cfb76feb2dab693c052bd474d5f4941207d669c1fd8",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpnkdbba1x.py\", line 243, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpnkdbba1x.py\", line 110, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.0681159496307373
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_21",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Calculate the sum of all subarrays in the range [start, end)\n            for i in range(start, end):\n                # Sum of subarrays starting at i\n                subarray_sum = (length - (i - start)) * nums[i]\n                total_sum = (total_sum + subarray_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
              "solution_hash": "d898659e4d113353126cdf74845b73e095b76e169be020f47e81628625dc23b9",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpchdtrgxc.py\", line 244, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpchdtrgxc.py\", line 111, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.07288002967834473
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_22",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Sum of all subarrays in the range [start, end)\n            # For each starting point i in [start, end), the number of subarrays ending at j (i <= j < end) is (j - i + 1)\n            # The contribution of nums[i] to the total sum is nums[i] * (number of times it appears in all subarrays)\n            # This can be calculated as nums[i] * (length - i) * (i - start + 1)\n            for i in range(start, end):\n                total_sum = (total_sum + nums[i] * (length - i) * (i - start + 1)) % MOD\n            \n            start = end\n        \n        return total_sum",
          "solution_hash": "30704de73821a275677d1cd2b8ee612f91a978537c392de83d810e164b921b65",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp3n7c4ofu.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp3n7c4ofu.py\", line 112, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06714892387390137
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_23",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                end += 1\n            \n            length = end - start\n            # Calculate the sum of all subarrays in the range [start, end)\n            # For a segment of length `length`, the sum of all subarrays can be calculated using the formula:\n            # sum = (length * (length + 1) / 2) * (sum of the segment)\n            segment_sum = sum(nums[start:end])\n            total_sum = (total_sum + (length * (length + 1) // 2) * segment_sum) % MOD\n            \n            start = end\n        \n        return total_sum",
              "solution_hash": "c34fcbabf4cd0ce4735ef648b59bfcfc5109820eb4d3ae69bf83f6a6ece04675",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp7vjhcrfh.py\", line 244, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp7vjhcrfh.py\", line 111, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06735634803771973
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_24",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        current_sum = nums[0]\n        length = 1\n        \n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1 or nums[i] == nums[i - 1] - 1:\n                length += 1\n                current_sum += nums[i]\n            else:\n                # Calculate the sum of all subarrays in the current consecutive segment\n                total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n                # Reset for the next segment\n                current_sum = nums[i]\n                length = 1\n        \n        # Add the last segment\n        total_sum = (total_sum + (length * (length + 1) // 2) * current_sum) % MOD\n        \n        return total_sum",
              "solution_hash": "ed8e0644b8bf02c3f040573f6b350f589f35c9a3a2d0190aeb1f35a555efff34",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpid0vt6dw.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpid0vt6dw.py\", line 112, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06624078750610352
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_25",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            current_sum = nums[start]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            while end < n and (nums[end] == nums[end - 1] + 1 or nums[end] == nums[end - 1] - 1):\n                current_sum += nums[end]\n                length = end - start + 1\n                total_sum = (total_sum + current_sum) % MOD\n                end += 1\n            \n            start = end\n        \n        return total_sum",
              "solution_hash": "9849ed99db98308ff97637cbcfb5ad49940baa067bb438917b71f2f0ba167cff",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpoo2ijc41.py\", line 243, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpoo2ijc41.py\", line 110, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06658935546875
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            direction = None\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i + 1] == nums[i] + 1:\n                    direction = 1\n                elif nums[i + 1] == nums[i] - 1:\n                    direction = -1\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and ((direction == 1 and nums[i + 1] == nums[i] + 1) or \n                                 (direction == -1 and nums[i + 1] == nums[i] - 1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum = (total_sum + nums[start + j] * (j + 1) * (length - j)) % MOD\n            \n            i += 1\n        \n        return total_sum",
      "solution_hash": "f30ecbd6c34789265550de1ae63ece5a0ad469f8b4c1815aed9f88ab58d3c337",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpwdyvwbm0.py\", line 248, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpwdyvwbm0.py\", line 124, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n",
        "execution_time": 0.07300376892089844
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_27",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Add the single element subarray sum\n            total_sum = (total_sum + nums[i]) % MOD\n            i += 1\n        \n        return total_sum",
          "solution_hash": "37182b2776e6e2e296f6bf794cd0d3865d18f0c2d73a2ccd27e4422baa693e0d",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpyl8hfi78.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpyl8hfi78.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06664109230041504
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_28",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the last element of the increasing sequence\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "c49710d6ac09dc623f73e72bf18240280f0906e00828c8f03d76e193c105ad22",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpm63bc6l6.py\", line 249, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpm63bc6l6.py\", line 116, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06694698333740234
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_29",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the start for decreasing sequence check\n            i = start\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1  # Move to the next unprocessed element\n        \n        return total_sum",
              "solution_hash": "a52e0d5c63355663c60ee302939436328e60ac49cb9166c3bd4b0ffa40e3c375",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06638813018798828
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_30",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset i and current_sum for decreasing sequence check\n            i = start\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1  # Move to the next element\n        \n        return total_sum",
              "solution_hash": "a52e0d5c63355663c60ee302939436328e60ac49cb9166c3bd4b0ffa40e3c375",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06638813018798828
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_31",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            direction = None\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i + 1] == nums[i] + 1:\n                    direction = 1\n                elif nums[i + 1] == nums[i] - 1:\n                    direction = -1\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and ((direction == 1 and nums[i + 1] == nums[i] + 1) or \n                                 (direction == -1 and nums[i + 1] == nums[i] - 1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
          "solution_hash": "52ee28dd4df6ac15186c940ed4e234662b494a9392a495bc6ed036da1fbeda0a",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp2w31wqbb.py\", line 252, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp2w31wqbb.py\", line 119, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06613445281982422
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_32",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the start and check for decreasing consecutive sequence\n            i = start\n            current_sum = nums[i]\n            \n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "a52e0d5c63355663c60ee302939436328e60ac49cb9166c3bd4b0ffa40e3c375",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06638813018798828
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_33",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        current_sum = 0\n        length = 0\n        direction = None\n        \n        for i in range(n):\n            if i == 0 or nums[i] != nums[i - 1] + 1 and nums[i] != nums[i - 1] - 1:\n                # Reset for a new sequence\n                current_sum = nums[i]\n                length = 1\n                direction = nums[i] - nums[i - 1] if i > 0 else None\n            else:\n                # Continue the current sequence\n                if direction is None or (direction == 1 and nums[i] == nums[i - 1] + 1) or (direction == -1 and nums[i] == nums[i - 1] - 1):\n                    current_sum += nums[i]\n                    length += 1\n                else:\n                    # Sequence changed direction, reset\n                    current_sum = nums[i]\n                    length = 1\n                    direction = nums[i] - nums[i - 1]\n            \n            # Add the sum of all subarrays ending at the current position\n            total_sum = (total_sum + current_sum * length) % MOD\n        \n        return total_sum",
              "solution_hash": "61c90d055769452bf81fe7728746f65b26f69fd58945eb042e2616999242cdb1",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpi1ksblpt.py\", line 249, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpi1ksblpt.py\", line 116, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06666398048400879
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_34",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            direction = None\n            \n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                if nums[i + 1] == nums[i] + 1:\n                    direction = 1\n                elif nums[i + 1] == nums[i] - 1:\n                    direction = -1\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and ((direction == 1 and nums[i + 1] == nums[i] + 1) or \n                                 (direction == -1 and nums[i + 1] == nums[i] - 1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Move to the next element\n            i += 1\n        \n        return total_sum",
              "solution_hash": "52ee28dd4df6ac15186c940ed4e234662b494a9392a495bc6ed036da1fbeda0a",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp2w31wqbb.py\", line 252, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp2w31wqbb.py\", line 119, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06613445281982422
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_35",
          "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Add single element subarray sum\n            total_sum = (total_sum + nums[i]) % MOD\n            i += 1\n        \n        return total_sum",
          "solution_hash": "37182b2776e6e2e296f6bf794cd0d3865d18f0c2d73a2ccd27e4422baa693e0d",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpyl8hfi78.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpyl8hfi78.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
            "execution_time": 0.06664109230041504
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_36",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset to the last element of the increasing sequence\n            i = start\n            \n            # Check for decreasing consecutive sequence\n            current_sum = nums[i]\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Move to the next element\n            i += 1\n        \n        return total_sum",
              "solution_hash": "a52e0d5c63355663c60ee302939436328e60ac49cb9166c3bd4b0ffa40e3c375",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06638813018798828
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_37",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            i = start\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "a52e0d5c63355663c60ee302939436328e60ac49cb9166c3bd4b0ffa40e3c375",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 250, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmp69dbseps.py\", line 117, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06638813018798828
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_38",
              "solution": "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            current_sum = nums[i]\n            total_sum = (total_sum + current_sum) % MOD  # Add single element subarray\n            \n            # Check for increasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] + 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            # Reset current_sum for decreasing sequence check\n            current_sum = nums[i]\n            \n            # Check for decreasing consecutive sequence\n            while i + 1 < n and nums[i + 1] == nums[i] - 1:\n                i += 1\n                current_sum += nums[i]\n                total_sum = (total_sum + current_sum) % MOD\n            \n            i += 1\n        \n        return total_sum",
              "solution_hash": "c49710d6ac09dc623f73e72bf18240280f0906e00828c8f03d76e193c105ad22",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpm63bc6l6.py\", line 249, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21419949/tmpm63bc6l6.py\", line 116, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n",
                "execution_time": 0.06694698333740234
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 39,
    "candidates_generated": 39,
    "tests_passed": 0,
    "tests_failed": 39,
    "test_errors": 0,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 842.3613810539246,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.0,
      "pass@3": 0.0,
      "pass@5": 0.0,
      "pass@10": 0.0
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 37
          }
        ],
        [
          38,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 38
          }
        ],
        [
          39,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: name 'pairwise' is not defined",
            "completion_id": 39
          }
        ]
      ]
    },
    "solutions_evaluated": 40,
    "test_cases": 1
  }
}