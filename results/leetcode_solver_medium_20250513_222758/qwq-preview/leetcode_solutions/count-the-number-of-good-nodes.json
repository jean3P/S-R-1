{
  "problem_id": "count-the-number-of-good-nodes",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "unsolved",
  "best_solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) <= 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count",
  "passed_solutions": [
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        # DFS function to calculate subtree sizes and check for good nodes\n        def dfs(node, parent):\n            child_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    child_size = dfs(child, node)\n                    child_sizes.append(child_size)\n            # If all child subtree sizes are the same, increment good_count\n            if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(child_sizes)\n        \n        # Start DFS from root node 0\n        dfs(0, -1)\n        return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                # DFS function to calculate subtree sizes and check for good nodes\n                def dfs(node, parent):\n                    child_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            child_size = dfs(child, node)\n                            child_sizes.append(child_size)\n                    # If all child subtree sizes are the same, increment good_count\n                    if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(child_sizes)\n                \n                # Start DFS from root node 0\n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        # DFS function to calculate subtree sizes and check for good nodes\n        def dfs(node, parent):\n            child_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    child_size = dfs(child, node)\n                    child_sizes.append(child_size)\n            # A node is good if:\n            # - It's a leaf node (no children)\n            # - All its children have the same subtree size\n            if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(child_sizes)\n        \n        # Start DFS from root node 0\n        dfs(0, -1)\n        return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            # Also, consider nodes with no children as good\n            if len(subtree_sizes) <= 1 or all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) <= 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count"
  ],
  "all_solutions": [
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                # DFS function to calculate subtree sizes and check for good nodes\n                def dfs(node, parent):\n                    child_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            child_size = dfs(child, node)\n                            child_sizes.append(child_size)\n                    # If all child subtree sizes are the same, increment good_count\n                    if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(child_sizes)\n                \n                # Start DFS from root node 0\n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        # DFS function to calculate subtree sizes and check for good nodes\n        def dfs(node, parent):\n            child_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    child_size = dfs(child, node)\n                    child_sizes.append(child_size)\n            # If all child subtree sizes are the same, increment good_count\n            if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(child_sizes)\n        \n        # Start DFS from root node 0\n        dfs(0, -1)\n        return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                # DFS function to calculate subtree sizes and check for good nodes\n                def dfs(node, parent):\n                    child_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            child_size = dfs(child, node)\n                            child_sizes.append(child_size)\n                    # If all child subtree sizes are the same, increment good_count\n                    if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(child_sizes)\n                \n                # Start DFS from root node 0\n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        # DFS function to calculate subtree sizes and check for good nodes\n        def dfs(node, parent):\n            child_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    child_size = dfs(child, node)\n                    child_sizes.append(child_size)\n            # A node is good if:\n            # - It's a leaf node (no children)\n            # - All its children have the same subtree size\n            if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(child_sizes)\n        \n        # Start DFS from root node 0\n        dfs(0, -1)\n        return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # If all subtree sizes are the same, increment good_count\n                    if all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)  # Start DFS from root node 0\n                return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                n = len(edges) + 1  # Number of nodes\n                parent = [-1] * n\n                stack = [(0, -1)]  # Start from root node 0 with parent -1\n                subtree_sizes = [0] * n\n                good_count = 0\n                \n                # First DFS to calculate subtree sizes\n                while stack:\n                    node, par = stack[-1]\n                    if parent[node] == -1:\n                        parent[node] = par\n                        children = [child for child in adj[node] if child != par]\n                        if not children:\n                            subtree_sizes[node] = 1\n                            stack.pop()\n                        else:\n                            stack.extend([(child, node) for child in children])\n                    else:\n                        children = [child for child in adj[node] if child != par]\n                        sizes = [subtree_sizes[child] for child in children]\n                        if all(size == sizes[0] for size in sizes):\n                            good_count += 1\n                        subtree_sizes[node] = 1 + sum(sizes)\n                        stack.pop()\n                \n                return good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                n = len(edges) + 1  # Number of nodes\n                parent = [-1] * n\n                subtree_sizes = [0] * n\n                good_count = 0\n                \n                def dfs(node):\n                    parent[node] = -1  # Root has no parent\n                    children = [child for child in adj[node] if child != parent[node]]\n                    if not children:\n                        subtree_sizes[node] = 1\n                        return 1\n                    sizes = []\n                    for child in children:\n                        parent[child] = node\n                        sizes.append(dfs(child))\n                    if len(set(sizes)) == 1:\n                        nonlocal good_count\n                        good_count += 1\n                    subtree_sizes[node] = 1 + sum(sizes)\n                    return subtree_sizes[node]\n                \n                dfs(0)  # Start DFS from root node 0\n                return good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        n = len(edges) + 1  # Number of nodes\n        parent = [-1] * n\n        subtree_sizes = [0] * n\n        good_count = 0\n        \n        def dfs(node):\n            nonlocal good_count\n            parent[node] = -1  # Root has no parent\n            subtree_sizes[node] = 1  # Include itself\n            children = [child for child in adj[node] if child != parent[node]]\n            sizes = []\n            for child in children:\n                parent[child] = node\n                sizes.append(dfs(child))\n            # All subtree sizes from children\n            if all(size == sizes[0] for size in sizes):\n                good_count += 1\n            subtree_sizes[node] += sum(sizes)\n            return subtree_sizes[node]\n        \n        dfs(0)  # Start from root node 0\n        return good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                n = len(edges) + 1  # Number of nodes\n                parent = [-1] * n\n                subtree_sizes = [0] * n\n                good_count = 0\n                \n                def dfs(node):\n                    parent[node] = -1  # Root has no parent\n                    children = [child for child in adj[node] if child != parent[node]]\n                    if not children:\n                        subtree_sizes[node] = 1\n                        return 1\n                    sizes = []\n                    for child in children:\n                        parent[child] = node\n                        sizes.append(dfs(child))\n                    if len(set(sizes)) == 1:\n                        nonlocal good_count\n                        good_count += 1\n                    subtree_sizes[node] = 1 + sum(sizes)\n                    return subtree_sizes[node]\n                \n                dfs(0)  # Start DFS from root node 0\n                return good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # If all subtree sizes are the same, increment good_count\n                    if all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)  # Start DFS from root node 0\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            if all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # If all subtree sizes are the same, increment good_count\n                    if all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)  # Start DFS from root node 0\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            # Also, consider nodes with no children as good\n            if len(subtree_sizes) <= 1 or all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # Check if all subtree sizes are the same\n                    if len(set(subtree_sizes)) <= 1:\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # A node is good if all its children subtrees have the same size\n            # If it has no children, it's considered good\n            if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # A node is good if all its children subtrees have the same size\n            # If it has no children, it's considered good\n            if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) <= 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count"
  ],
  "total_candidates": 24,
  "nodes_explored": 24,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                # DFS function to calculate subtree sizes and check for good nodes\n                def dfs(node, parent):\n                    child_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            child_size = dfs(child, node)\n                            child_sizes.append(child_size)\n                    # If all child subtree sizes are the same, increment good_count\n                    if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(child_sizes)\n                \n                # Start DFS from root node 0\n                dfs(0, -1)\n                return self.good_count",
      "solution_hash": "fff7648b1602c0743956ba4d49ad0f219e016d64be92cd128ef314175eb42e8e",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "  File \"/scratch/local/21419949/tmpo81di3cq.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
        "execution_time": 0.05362677574157715
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_1",
          "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        # DFS function to calculate subtree sizes and check for good nodes\n        def dfs(node, parent):\n            child_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    child_size = dfs(child, node)\n                    child_sizes.append(child_size)\n            # If all child subtree sizes are the same, increment good_count\n            if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(child_sizes)\n        \n        # Start DFS from root node 0\n        dfs(0, -1)\n        return self.good_count",
          "solution_hash": "fff7648b1602c0743956ba4d49ad0f219e016d64be92cd128ef314175eb42e8e",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06849408149719238
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_2",
          "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                # DFS function to calculate subtree sizes and check for good nodes\n                def dfs(node, parent):\n                    child_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            child_size = dfs(child, node)\n                            child_sizes.append(child_size)\n                    # If all child subtree sizes are the same, increment good_count\n                    if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(child_sizes)\n                \n                # Start DFS from root node 0\n                dfs(0, -1)\n                return self.good_count",
          "solution_hash": "fff7648b1602c0743956ba4d49ad0f219e016d64be92cd128ef314175eb42e8e",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06849408149719238
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_3",
          "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        # DFS function to calculate subtree sizes and check for good nodes\n        def dfs(node, parent):\n            child_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    child_size = dfs(child, node)\n                    child_sizes.append(child_size)\n            # A node is good if:\n            # - It's a leaf node (no children)\n            # - All its children have the same subtree size\n            if not child_sizes or all(size == child_sizes[0] for size in child_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(child_sizes)\n        \n        # Start DFS from root node 0\n        dfs(0, -1)\n        return self.good_count",
          "solution_hash": "fff7648b1602c0743956ba4d49ad0f219e016d64be92cd128ef314175eb42e8e",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06849408149719238
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [],
          "passed": true
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # If all subtree sizes are the same, increment good_count\n                    if all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)  # Start DFS from root node 0\n                return self.good_count",
      "solution_hash": "f086ee731ec7afd1f70f7f574d16c5f4573088f15f7dd8d730bc1ff438268fb0",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "  File \"/scratch/local/21419949/tmp4etxfyyf.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
        "execution_time": 0.057920217514038086
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_5",
          "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                n = len(edges) + 1  # Number of nodes\n                parent = [-1] * n\n                stack = [(0, -1)]  # Start from root node 0 with parent -1\n                subtree_sizes = [0] * n\n                good_count = 0\n                \n                # First DFS to calculate subtree sizes\n                while stack:\n                    node, par = stack[-1]\n                    if parent[node] == -1:\n                        parent[node] = par\n                        children = [child for child in adj[node] if child != par]\n                        if not children:\n                            subtree_sizes[node] = 1\n                            stack.pop()\n                        else:\n                            stack.extend([(child, node) for child in children])\n                    else:\n                        children = [child for child in adj[node] if child != par]\n                        sizes = [subtree_sizes[child] for child in children]\n                        if all(size == sizes[0] for size in sizes):\n                            good_count += 1\n                        subtree_sizes[node] = 1 + sum(sizes)\n                        stack.pop()\n                \n                return good_count",
          "solution_hash": "b3ec6ed42d4dc0e0940f3ac650ce7776d7db065707d87e7e2e899bac25eae1d9",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "  File \"/scratch/local/21419949/tmpyf23n34i.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
            "execution_time": 0.05361437797546387
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_6",
              "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                n = len(edges) + 1  # Number of nodes\n                parent = [-1] * n\n                subtree_sizes = [0] * n\n                good_count = 0\n                \n                def dfs(node):\n                    parent[node] = -1  # Root has no parent\n                    children = [child for child in adj[node] if child != parent[node]]\n                    if not children:\n                        subtree_sizes[node] = 1\n                        return 1\n                    sizes = []\n                    for child in children:\n                        parent[child] = node\n                        sizes.append(dfs(child))\n                    if len(set(sizes)) == 1:\n                        nonlocal good_count\n                        good_count += 1\n                    subtree_sizes[node] = 1 + sum(sizes)\n                    return subtree_sizes[node]\n                \n                dfs(0)  # Start DFS from root node 0\n                return good_count",
              "solution_hash": "80db865465fb2e347ea4aca6bd68f001077168340503e9c01bf8f99a8b28a904",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp1h4g0ppp.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.053635597229003906
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_7",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        n = len(edges) + 1  # Number of nodes\n        parent = [-1] * n\n        subtree_sizes = [0] * n\n        good_count = 0\n        \n        def dfs(node):\n            nonlocal good_count\n            parent[node] = -1  # Root has no parent\n            subtree_sizes[node] = 1  # Include itself\n            children = [child for child in adj[node] if child != parent[node]]\n            sizes = []\n            for child in children:\n                parent[child] = node\n                sizes.append(dfs(child))\n            # All subtree sizes from children\n            if all(size == sizes[0] for size in sizes):\n                good_count += 1\n            subtree_sizes[node] += sum(sizes)\n            return subtree_sizes[node]\n        \n        dfs(0)  # Start from root node 0\n        return good_count",
              "solution_hash": "b390d94715ec913f85d1d9c398957c01d37c08ff7302d5d7fc9229b5c857ed47",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 167, in <module>\n    check(Solution().countGoodNodes)\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 117, in check\n    assert candidate(edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [1, 6], [2, 7], [3, 8]]) == 6\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 112, in countGoodNodes\n    dfs(0)  # Start from root node 0\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 105, in dfs\n    sizes.append(dfs(child))\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 105, in dfs\n    sizes.append(dfs(child))\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 105, in dfs\n    sizes.append(dfs(child))\n  [Previous line repeated 992 more times]\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 101, in dfs\n    children = [child for child in adj[node] if child != parent[node]]\n  File \"/scratch/local/21419949/tmpgo9v6i92.py\", line 101, in <listcomp>\n    children = [child for child in adj[node] if child != parent[node]]\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "execution_time": 0.06766843795776367
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_8",
              "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                n = len(edges) + 1  # Number of nodes\n                parent = [-1] * n\n                subtree_sizes = [0] * n\n                good_count = 0\n                \n                def dfs(node):\n                    parent[node] = -1  # Root has no parent\n                    children = [child for child in adj[node] if child != parent[node]]\n                    if not children:\n                        subtree_sizes[node] = 1\n                        return 1\n                    sizes = []\n                    for child in children:\n                        parent[child] = node\n                        sizes.append(dfs(child))\n                    if len(set(sizes)) == 1:\n                        nonlocal good_count\n                        good_count += 1\n                    subtree_sizes[node] = 1 + sum(sizes)\n                    return subtree_sizes[node]\n                \n                dfs(0)  # Start DFS from root node 0\n                return good_count",
              "solution_hash": "80db865465fb2e347ea4aca6bd68f001077168340503e9c01bf8f99a8b28a904",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp1h4g0ppp.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.053635597229003906
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_9",
          "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # If all subtree sizes are the same, increment good_count\n                    if all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)  # Start DFS from root node 0\n                return self.good_count",
          "solution_hash": "f086ee731ec7afd1f70f7f574d16c5f4573088f15f7dd8d730bc1ff438268fb0",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "  File \"/scratch/local/21419949/tmpp2fizqpl.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
            "execution_time": 0.05411362648010254
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_10",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            if all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
              "solution_hash": "f086ee731ec7afd1f70f7f574d16c5f4573088f15f7dd8d730bc1ff438268fb0",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmpp2fizqpl.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.05411362648010254
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_11",
              "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                adj = defaultdict(list)\n                for a, b in edges:\n                    adj[a].append(b)\n                    adj[b].append(a)\n                \n                self.good_count = 0  # Counter for good nodes\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in adj[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # If all subtree sizes are the same, increment good_count\n                    if all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)  # Start DFS from root node 0\n                return self.good_count",
              "solution_hash": "f086ee731ec7afd1f70f7f574d16c5f4573088f15f7dd8d730bc1ff438268fb0",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmpp2fizqpl.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.05411362648010254
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_12",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
              "solution_hash": "8216368caf762c419ac355858b33fd62fcac5b0c66203c7e85ff999620b69941",
              "test_result": {
                "status": "pass",
                "execution_time": 0.06974172592163086
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": true
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_13",
          "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        adj = defaultdict(list)\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n        \n        self.good_count = 0  # Counter for good nodes\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in adj[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # If all subtree sizes are the same, increment good_count\n            # Also, consider nodes with no children as good\n            if len(subtree_sizes) <= 1 or all(size == subtree_sizes[0] for size in subtree_sizes):\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)  # Start DFS from root node 0\n        return self.good_count",
          "solution_hash": "07f7a364d10c4220b6e3b166ab96e31ee9ddbe87204ae3f8bf15518d2c7bc583",
          "test_result": {
            "status": "pass",
            "execution_time": 0.07352471351623535
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [],
          "passed": true
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # Check if all subtree sizes are the same\n                    if len(set(subtree_sizes)) <= 1:\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
      "solution_hash": "af3f1203c91bdc1b690a6817f8551c1d7f8f673faee03f981d2929c092159419",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "  File \"/scratch/local/21419949/tmp7sqlxzq1.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
        "execution_time": 0.05743813514709473
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_15",
          "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
          "solution_hash": "42a3256b70cbf45f944ee8c8a5a54f330d91b93ccbcbdd13d40cd448369cce10",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "  File \"/scratch/local/21419949/tmp56de0bmu.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
            "execution_time": 0.0549163818359375
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_16",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # A node is good if all its children subtrees have the same size\n            # If it has no children, it's considered good\n            if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count",
              "solution_hash": "42a3256b70cbf45f944ee8c8a5a54f330d91b93ccbcbdd13d40cd448369cce10",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp56de0bmu.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.0549163818359375
              },
              "depth": 2,
              "parent_id": "1_15",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_17",
              "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
              "solution_hash": "42a3256b70cbf45f944ee8c8a5a54f330d91b93ccbcbdd13d40cd448369cce10",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp56de0bmu.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.0549163818359375
              },
              "depth": 2,
              "parent_id": "1_15",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_18",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # A node is good if all its children subtrees have the same size\n            # If it has no children, it's considered good\n            if not subtree_sizes or len(set(subtree_sizes)) == 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count",
              "solution_hash": "42a3256b70cbf45f944ee8c8a5a54f330d91b93ccbcbdd13d40cd448369cce10",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp56de0bmu.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.0549163818359375
              },
              "depth": 2,
              "parent_id": "1_15",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_19",
          "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
          "solution_hash": "e7e2feaef78a08baa12f9ae12c12e050bc6ebd07dc3f12ede94dcac417c026f2",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "  File \"/scratch/local/21419949/tmpmk5grmxt.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
            "execution_time": 0.053609609603881836
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_20",
              "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
              "solution_hash": "e7e2feaef78a08baa12f9ae12c12e050bc6ebd07dc3f12ede94dcac417c026f2",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmpmk5grmxt.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.053609609603881836
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_21",
              "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
              "solution_hash": "e7e2feaef78a08baa12f9ae12c12e050bc6ebd07dc3f12ede94dcac417c026f2",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmpmk5grmxt.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.053609609603881836
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_22",
              "solution": "from typing import List\n        from collections import defaultdict\n\n        class Solution:\n            def countGoodNodes(self, edges: List[List[int]]) -> int:\n                # Build adjacency list\n                tree = defaultdict(list)\n                for a, b in edges:\n                    tree[a].append(b)\n                    tree[b].append(a)\n                \n                self.good_count = 0\n                \n                def dfs(node, parent):\n                    subtree_sizes = []\n                    for child in tree[node]:\n                        if child != parent:\n                            size = dfs(child, node)\n                            subtree_sizes.append(size)\n                    # A node is good if all its children subtrees have the same size\n                    # If it has no children, it's considered good\n                    if not subtree_sizes or all(size == subtree_sizes[0] for size in subtree_sizes):\n                        self.good_count += 1\n                    # Return the size of the subtree rooted at this node\n                    return 1 + sum(subtree_sizes)\n                \n                dfs(0, -1)\n                return self.good_count",
              "solution_hash": "e7e2feaef78a08baa12f9ae12c12e050bc6ebd07dc3f12ede94dcac417c026f2",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmpmk5grmxt.py\", line 82\n    from collections import defaultdict\nIndentationError: unexpected indent\n",
                "execution_time": 0.053609609603881836
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_23",
          "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build adjacency list\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        self.good_count = 0\n        \n        def dfs(node, parent):\n            subtree_sizes = []\n            for child in tree[node]:\n                if child != parent:\n                    size = dfs(child, node)\n                    subtree_sizes.append(size)\n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) <= 1:\n                self.good_count += 1\n            # Return the size of the subtree rooted at this node\n            return 1 + sum(subtree_sizes)\n        \n        dfs(0, -1)\n        return self.good_count",
          "solution_hash": "af3f1203c91bdc1b690a6817f8551c1d7f8f673faee03f981d2929c092159419",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06812071800231934
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [],
          "passed": true
        }
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 24,
    "candidates_generated": 24,
    "tests_passed": 6,
    "tests_failed": 18,
    "test_errors": 0,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 702.2841963768005,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.3600000000000001,
      "pass@3": 0.7565217391304347,
      "pass@5": 0.9177865612648222,
      "pass@10": 0.9975501413379997
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: maximum recursion depth exceeded in comparison",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 96)",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 24
          }
        ]
      ]
    },
    "solutions_evaluated": 25,
    "test_cases": 1
  }
}