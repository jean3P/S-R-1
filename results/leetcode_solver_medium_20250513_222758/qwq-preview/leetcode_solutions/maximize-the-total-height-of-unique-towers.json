{
  "problem_id": "maximize-the-total-height-of-unique-towers",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "solved",
  "best_solution": "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Sort the maximum heights in descending order\n        sorted_heights = sorted(maximumHeight, reverse=True)\n        \n        assigned_height = []\n        current_height = inf\n        for max_h in sorted_heights:\n            if max_h < current_height:\n                current_height = max_h\n            else:\n                current_height -= 1\n                if current_height <= 0 or current_height > max_h:\n                    return -1\n            assigned_height.append(current_height)\n        \n        return sum(assigned_height)",
  "passed_solutions": [
    "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Sort the maximum heights in descending order\n        sorted_heights = sorted(maximumHeight, reverse=True)\n        \n        assigned_height = []\n        current_height = inf\n        for max_h in sorted_heights:\n            if max_h < current_height:\n                current_height = max_h\n            else:\n                current_height -= 1\n                if current_height <= 0 or current_height > max_h:\n                    return -1\n            assigned_height.append(current_height)\n        \n        return sum(assigned_height)",
    "class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Sort the maximum heights in descending order\n                sorted_heights = sorted(maximumHeight, reverse=True)\n                \n                assigned_height = float('inf')\n                total_sum = 0\n                \n                for max_height in sorted_heights:\n                    if max_height < assigned_height:\n                        assigned_height = max_height\n                    else:\n                        assigned_height -= 1\n                        if assigned_height <= 0:\n                            return -1\n                    total_sum += assigned_height\n                \n                return total_sum"
  ],
  "all_solutions": [
    "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Sort the maximum heights in descending order\n        sorted_heights = sorted(maximumHeight, reverse=True)\n        \n        assigned_height = []\n        current_height = inf\n        for max_h in sorted_heights:\n            if max_h < current_height:\n                current_height = max_h\n            else:\n                current_height -= 1\n                if current_height <= 0 or current_height > max_h:\n                    return -1\n            assigned_height.append(current_height)\n        \n        return sum(assigned_height)",
    "class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Sort the maximum heights in descending order\n                sorted_heights = sorted(maximumHeight, reverse=True)\n                \n                assigned_height = float('inf')\n                total_sum = 0\n                \n                for max_height in sorted_heights:\n                    if max_height < assigned_height:\n                        assigned_height = max_height\n                    else:\n                        assigned_height -= 1\n                        if assigned_height <= 0:\n                            return -1\n                    total_sum += assigned_height\n                \n                return total_sum",
    "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        maximumHeight.sort(reverse=True)\n        current_height = 1\n        total_sum = 0\n        for max_height in maximumHeight:\n            if current_height > max_height:\n                return -1\n            total_sum += current_height\n            current_height += 1\n        return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                # Sort the maximum heights in ascending order\n                maximumHeight.sort()\n                assigned_height = 0\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Assign the maximum possible unique height <= max_height\n                    assigned_height = max(assigned_height + 1, max_height)\n                    if assigned_height > max_height:\n                        return -1\n                    total_sum += assigned_height\n                \n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                for max_height in maximumHeight:\n                    # Find the smallest positive integer not in assigned and <= max_height\n                    height = 1\n                    while height in assigned or height > max_height:\n                        height += 1\n                        if height > max_height:\n                            return -1\n                    assigned.add(height)\n                    total_sum += height\n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                # Sort the maximum heights in descending order\n                sorted_heights = sorted(maximumHeight, reverse=True)\n                assigned_height = float('inf')\n                total_sum = 0\n                \n                for max_height in sorted_heights:\n                    # Assign the maximum possible unique height <= max_height\n                    if assigned_height > max_height:\n                        assigned_height = max_height\n                    if assigned_height <= 0:\n                        return -1\n                    total_sum += assigned_height\n                    assigned_height -= 1\n                \n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                for max_height in reversed(sorted(maximumHeight)):\n                    while max_height in assigned and max_height > 0:\n                        max_height -= 1\n                    if max_height == 0:\n                        return -1\n                    assigned.add(max_height)\n                    total_sum += max_height\n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Sort the maximum heights in ascending order\n                maximumHeight.sort()\n                \n                assigned_height = 0\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Assign the smallest possible unique height that is <= max_height\n                    assigned_height = max(assigned_height + 1, max_height)\n                    \n                    # If the assigned height exceeds the max_height, it's impossible\n                    if assigned_height > max_height:\n                        return -1\n                    total_sum += assigned_height\n                \n                return total_sum",
    "from typing import List\n\nclass Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Sort the indices based on maximum heights in descending order\n        sorted_indices = sorted(range(len(maximumHeight)), key=lambda i: -maximumHeight[i])\n        \n        assigned_heights = {}\n        current_height = maximumHeight[sorted_indices[0]]\n        \n        for idx in sorted_indices:\n            max_height = maximumHeight[idx]\n            if current_height > max_height:\n                # Find the largest possible height that is <= max_height and not already assigned\n                while current_height > max_height or current_height in assigned_heights:\n                    current_height -= 1\n                if current_height < 1:\n                    return -1\n            if current_height in assigned_heights:\n                return -1\n            assigned_heights[current_height] = True\n            current_height -= 1\n        \n        # Calculate the total sum of assigned heights\n        return sum(assigned_heights.keys())",
    "from typing import List\n\nclass Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Create a list of tuples (max_height, index) and sort it in descending order\n        max_heights_with_indices = sorted([(height, idx) for idx, height in enumerate(maximumHeight)], reverse=True)\n        \n        assigned = {}\n        total_sum = 0\n        current_height = 1 << 31  # Start with a height larger than any possible maximum height\n        \n        for height, idx in max_heights_with_indices:\n            # Assign the largest possible unique height <= max_height\n            while current_height > height or current_height in assigned:\n                current_height -= 1\n            if current_height < 1:\n                return -1  # No valid height can be assigned\n            assigned[current_height] = idx\n            total_sum += current_height\n            current_height -= 1  # Decrement for the next assignment\n        \n        return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                for max_height in reversed(sorted(maximumHeight)):\n                    # Find the maximum possible unique height for this tower\n                    while max_height in assigned and max_height > 0:\n                        max_height -= 1\n                    if max_height == 0:\n                        return -1  # Cannot assign a positive height\n                    assigned.add(max_height)\n                    total_sum += max_height\n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Sort the maximum heights in ascending order\n                maximumHeight.sort()\n                \n                assigned_height = 0\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Assign the smallest possible unique height that is <= max_height\n                    assigned_height = max(assigned_height + 1, max_height)\n                    \n                    # If the assigned height exceeds the max_height, it's impossible\n                    if assigned_height > max_height:\n                        return -1\n                    \n                    total_sum += assigned_height\n                \n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Try to assign the maximum possible unique height <= max_height\n                    for h in range(max_height, 0, -1):\n                        if h not in assigned:\n                            assigned.add(h)\n                            total_sum += h\n                            break\n                    else:\n                        # If no unique height can be assigned, return -1\n                        return -1\n                \n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Create a list of (max_height, index) tuples and sort by max_height in descending order\n                towers = sorted(enumerate(maximumHeight), key=lambda x: -x[1])\n                \n                # Initialize a set to keep track of assigned heights\n                assigned = set()\n                \n                # Initialize the total sum\n                total_sum = 0\n                \n                # Initialize the current height to be assigned\n                current_height = len(maximumHeight)\n                \n                for idx, max_height in towers:\n                    # Find the largest possible height <= max_height that hasn't been assigned yet\n                    while current_height > 0 and current_height in assigned:\n                        current_height -= 1\n                    if current_height > max_height:\n                        # If the smallest available height is greater than the max_height, try to adjust\n                        if max_height in assigned:\n                            # If max_height is already assigned, it's impossible\n                            return -1\n                        else:\n                            # Assign the max_height\n                            assigned.add(max_height)\n                            total_sum += max_height\n                            current_height = max_height - 1\n                    else:\n                        # Assign the current_height\n                        assigned.add(current_height)\n                        total_sum += current_height\n                        current_height -= 1\n                \n                return total_sum",
    "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                assigned = set()\n                total_sum = 0\n                \n                for max_height in sorted(maximumHeight, reverse=True):\n                    # Find the largest possible height <= max_height that hasn't been assigned yet\n                    height = max_height\n                    while height in assigned and height > 0:\n                        height -= 1\n                    if height == 0:\n                        # No unique height can be assigned\n                        return -1\n                    assigned.add(height)\n                    total_sum += height\n                \n                return total_sum"
  ],
  "total_candidates": 15,
  "nodes_explored": 15,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Sort the maximum heights in descending order\n        sorted_heights = sorted(maximumHeight, reverse=True)\n        \n        assigned_height = []\n        current_height = inf\n        for max_h in sorted_heights:\n            if max_h < current_height:\n                current_height = max_h\n            else:\n                current_height -= 1\n                if current_height <= 0 or current_height > max_h:\n                    return -1\n            assigned_height.append(current_height)\n        \n        return sum(assigned_height)",
      "solution_hash": "57469f6c552333d5c4d6f94ee0815220f504b54680e965e75db3ac72cd88dfc7",
      "test_result": {
        "status": "pass",
        "execution_time": 0.06765460968017578
      },
      "depth": 0,
      "parent_id": null,
      "children": [],
      "passed": true
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Sort the maximum heights in descending order\n                sorted_heights = sorted(maximumHeight, reverse=True)\n                \n                assigned_height = float('inf')\n                total_sum = 0\n                \n                for max_height in sorted_heights:\n                    if max_height < assigned_height:\n                        assigned_height = max_height\n                    else:\n                        assigned_height -= 1\n                        if assigned_height <= 0:\n                            return -1\n                    total_sum += assigned_height\n                \n                return total_sum",
      "solution_hash": "2a4515738e02016836909d8952a589c09279f250364c0f6be7f1da8440b6c54b",
      "test_result": {
        "status": "pass",
        "execution_time": 0.06991791725158691
      },
      "depth": 0,
      "parent_id": null,
      "children": [],
      "passed": true
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        maximumHeight.sort(reverse=True)\n        current_height = 1\n        total_sum = 0\n        for max_height in maximumHeight:\n            if current_height > max_height:\n                return -1\n            total_sum += current_height\n            current_height += 1\n        return total_sum",
      "solution_hash": "5d92dbb8ad231d9e55804afa1c4a29e82c41c251e3a6ccb6e026f8d68423fd72",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmpsijq8lzw.py\", line 172, in <module>\n    check(Solution().maximumTotalSum)\n  File \"/scratch/local/21419949/tmpsijq8lzw.py\", line 95, in check\n    assert candidate(maximumHeight = [2, 3, 4, 3]) == 10\nAssertionError\n",
        "execution_time": 0.07022881507873535
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_3",
          "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                # Sort the maximum heights in ascending order\n                maximumHeight.sort()\n                assigned_height = 0\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Assign the maximum possible unique height <= max_height\n                    assigned_height = max(assigned_height + 1, max_height)\n                    if assigned_height > max_height:\n                        return -1\n                    total_sum += assigned_height\n                \n                return total_sum",
          "solution_hash": "2df51c7602f39dcf82958cd6d3c2286327e75151301e50f3cc264d07a7faa324",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "  File \"/scratch/local/21419949/tmpvgceyej7.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
            "execution_time": 0.05499601364135742
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_4",
              "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                for max_height in maximumHeight:\n                    # Find the smallest positive integer not in assigned and <= max_height\n                    height = 1\n                    while height in assigned or height > max_height:\n                        height += 1\n                        if height > max_height:\n                            return -1\n                    assigned.add(height)\n                    total_sum += height\n                return total_sum",
              "solution_hash": "d73ee315a157cc96bf2761c0745877ebc63d85d314bc5b146ab409ae02cdbf1c",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp86l901qv.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
                "execution_time": 0.05450773239135742
              },
              "depth": 2,
              "parent_id": "1_3",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_5",
              "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                # Sort the maximum heights in descending order\n                sorted_heights = sorted(maximumHeight, reverse=True)\n                assigned_height = float('inf')\n                total_sum = 0\n                \n                for max_height in sorted_heights:\n                    # Assign the maximum possible unique height <= max_height\n                    if assigned_height > max_height:\n                        assigned_height = max_height\n                    if assigned_height <= 0:\n                        return -1\n                    total_sum += assigned_height\n                    assigned_height -= 1\n                \n                return total_sum",
              "solution_hash": "f0e5c42024e2dac30e107b76eeac28197f54df067ef88c6aca5f06e5803d3a09",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp2mkoa3_c.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
                "execution_time": 0.05316567420959473
              },
              "depth": 2,
              "parent_id": "1_3",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_6",
              "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                for max_height in reversed(sorted(maximumHeight)):\n                    while max_height in assigned and max_height > 0:\n                        max_height -= 1\n                    if max_height == 0:\n                        return -1\n                    assigned.add(max_height)\n                    total_sum += max_height\n                return total_sum",
              "solution_hash": "f49cb871330d66fbed84707aa3f9aed98371b4d4d3745317c2612d43e96f2787",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmprnfwhd2b.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
                "execution_time": 0.05236506462097168
              },
              "depth": 2,
              "parent_id": "1_3",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_7",
          "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Sort the maximum heights in ascending order\n                maximumHeight.sort()\n                \n                assigned_height = 0\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Assign the smallest possible unique height that is <= max_height\n                    assigned_height = max(assigned_height + 1, max_height)\n                    \n                    # If the assigned height exceeds the max_height, it's impossible\n                    if assigned_height > max_height:\n                        return -1\n                    total_sum += assigned_height\n                \n                return total_sum",
          "solution_hash": "b69394924872c6193eea965238c997b776d0b2b150ead9f9aaaed6401ad1e1eb",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "  File \"/scratch/local/21419949/tmpm2_h48u7.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
            "execution_time": 0.05303668975830078
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_8",
              "solution": "from typing import List\n\nclass Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Sort the indices based on maximum heights in descending order\n        sorted_indices = sorted(range(len(maximumHeight)), key=lambda i: -maximumHeight[i])\n        \n        assigned_heights = {}\n        current_height = maximumHeight[sorted_indices[0]]\n        \n        for idx in sorted_indices:\n            max_height = maximumHeight[idx]\n            if current_height > max_height:\n                # Find the largest possible height that is <= max_height and not already assigned\n                while current_height > max_height or current_height in assigned_heights:\n                    current_height -= 1\n                if current_height < 1:\n                    return -1\n            if current_height in assigned_heights:\n                return -1\n            assigned_heights[current_height] = True\n            current_height -= 1\n        \n        # Calculate the total sum of assigned heights\n        return sum(assigned_heights.keys())",
              "solution_hash": "51213b537f2e0a26198b6de64ec2c201d04c193380c62c8b28662f8d32b3bb3a",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419949/tmp5ezjchih.py\", line 189, in <module>\n    check(Solution().maximumTotalSum)\n  File \"/scratch/local/21419949/tmp5ezjchih.py\", line 119, in check\n    assert candidate(maximumHeight = [2, 2, 1]) == -1\nAssertionError\n",
                "execution_time": 0.06765508651733398
              },
              "depth": 2,
              "parent_id": "1_7",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_9",
              "solution": "from typing import List\n\nclass Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        if not maximumHeight:\n            return -1\n        \n        # Create a list of tuples (max_height, index) and sort it in descending order\n        max_heights_with_indices = sorted([(height, idx) for idx, height in enumerate(maximumHeight)], reverse=True)\n        \n        assigned = {}\n        total_sum = 0\n        current_height = 1 << 31  # Start with a height larger than any possible maximum height\n        \n        for height, idx in max_heights_with_indices:\n            # Assign the largest possible unique height <= max_height\n            while current_height > height or current_height in assigned:\n                current_height -= 1\n            if current_height < 1:\n                return -1  # No valid height can be assigned\n            assigned[current_height] = idx\n            total_sum += current_height\n            current_height -= 1  # Decrement for the next assignment\n        \n        return total_sum",
              "solution_hash": "63f31a9026cd24781aacd648a6cc25cce717d90eae8b68cd0309b4a2e276d696",
              "test_result": {
                "status": "timeout",
                "error_message": "Test execution timed out after 10 seconds"
              },
              "depth": 2,
              "parent_id": "1_7",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_10",
              "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                for max_height in reversed(sorted(maximumHeight)):\n                    # Find the maximum possible unique height for this tower\n                    while max_height in assigned and max_height > 0:\n                        max_height -= 1\n                    if max_height == 0:\n                        return -1  # Cannot assign a positive height\n                    assigned.add(max_height)\n                    total_sum += max_height\n                return total_sum",
              "solution_hash": "f49cb871330d66fbed84707aa3f9aed98371b4d4d3745317c2612d43e96f2787",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmprnfwhd2b.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
                "execution_time": 0.05236506462097168
              },
              "depth": 2,
              "parent_id": "1_7",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_11",
          "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Sort the maximum heights in ascending order\n                maximumHeight.sort()\n                \n                assigned_height = 0\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Assign the smallest possible unique height that is <= max_height\n                    assigned_height = max(assigned_height + 1, max_height)\n                    \n                    # If the assigned height exceeds the max_height, it's impossible\n                    if assigned_height > max_height:\n                        return -1\n                    \n                    total_sum += assigned_height\n                \n                return total_sum",
          "solution_hash": "b69394924872c6193eea965238c997b776d0b2b150ead9f9aaaed6401ad1e1eb",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "  File \"/scratch/local/21419949/tmpm2_h48u7.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
            "execution_time": 0.05303668975830078
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_12",
              "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                assigned = set()\n                total_sum = 0\n                \n                for max_height in maximumHeight:\n                    # Try to assign the maximum possible unique height <= max_height\n                    for h in range(max_height, 0, -1):\n                        if h not in assigned:\n                            assigned.add(h)\n                            total_sum += h\n                            break\n                    else:\n                        # If no unique height can be assigned, return -1\n                        return -1\n                \n                return total_sum",
              "solution_hash": "f427f4f3ac440c4464dc838bb2b7dbe7b8ff0e9a4c6d6cf50d7de199d4d4e125",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmph4nzakin.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
                "execution_time": 0.05543208122253418
              },
              "depth": 2,
              "parent_id": "1_11",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_13",
              "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                # Create a list of (max_height, index) tuples and sort by max_height in descending order\n                towers = sorted(enumerate(maximumHeight), key=lambda x: -x[1])\n                \n                # Initialize a set to keep track of assigned heights\n                assigned = set()\n                \n                # Initialize the total sum\n                total_sum = 0\n                \n                # Initialize the current height to be assigned\n                current_height = len(maximumHeight)\n                \n                for idx, max_height in towers:\n                    # Find the largest possible height <= max_height that hasn't been assigned yet\n                    while current_height > 0 and current_height in assigned:\n                        current_height -= 1\n                    if current_height > max_height:\n                        # If the smallest available height is greater than the max_height, try to adjust\n                        if max_height in assigned:\n                            # If max_height is already assigned, it's impossible\n                            return -1\n                        else:\n                            # Assign the max_height\n                            assigned.add(max_height)\n                            total_sum += max_height\n                            current_height = max_height - 1\n                    else:\n                        # Assign the current_height\n                        assigned.add(current_height)\n                        total_sum += current_height\n                        current_height -= 1\n                \n                return total_sum",
              "solution_hash": "fd1df91b30dc61ed47906335bf4f3c5470b1e97d7ea080bb856851eab06ab8ba",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmp6v7e81yu.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
                "execution_time": 0.054529428482055664
              },
              "depth": 2,
              "parent_id": "1_11",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_14",
              "solution": "from typing import List\n\n        class Solution:\n            def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n                if not maximumHeight:\n                    return -1\n                \n                assigned = set()\n                total_sum = 0\n                \n                for max_height in sorted(maximumHeight, reverse=True):\n                    # Find the largest possible height <= max_height that hasn't been assigned yet\n                    height = max_height\n                    while height in assigned and height > 0:\n                        height -= 1\n                    if height == 0:\n                        # No unique height can be assigned\n                        return -1\n                    assigned.add(height)\n                    total_sum += height\n                \n                return total_sum",
              "solution_hash": "ba8de6b5477e7d8627f02ce84d8130eadcca496d0d0a955f6f1407ed10f2e6c7",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "  File \"/scratch/local/21419949/tmplzdv5giu.py\", line 83\n    class Solution:\nIndentationError: unexpected indent\n",
                "execution_time": 0.05474233627319336
              },
              "depth": 2,
              "parent_id": "1_11",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 15,
    "candidates_generated": 15,
    "tests_passed": 2,
    "tests_failed": 12,
    "test_errors": 1,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 304.5036835670471,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.1875,
      "pass@3": 0.4892857142857143,
      "pass@5": 0.7053571428571428,
      "pass@10": 0.9642857142857143
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "timed out",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 15
          }
        ]
      ]
    },
    "solutions_evaluated": 16,
    "test_cases": 1
  }
}