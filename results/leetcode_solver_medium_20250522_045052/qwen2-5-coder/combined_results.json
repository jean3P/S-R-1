[
  {
    "problem_id": "shortest-distance-after-road-addition-queries-i",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "from typing import List\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(graph, start, end):\n            dist = [float('inf')] * n\n            dist[start] = 0\n            pq = [(0, start)]\n            while pq:\n                current_dist, u = heappop(pq)\n                if u == end:\n                    return current_dist\n                if current_dist > dist[u]:\n                    continue\n                for v, weight in graph[u]:\n                    distance = current_dist + weight\n                    if distance < dist[v]:\n                        dist[v] = distance\n                        heappush(pq, (distance, v))\n            return dist[end]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append((i + 1, 1))\n        \n        results = []\n        for u, v in queries:\n            graph[u].append((v, 1))\n            shortest_path = dijkstra(graph, 0, n - 1)\n            results.append(shortest_path)\n        \n        return results",
    "passed_solutions": [
      "from typing import List\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(graph, start, end):\n            dist = [float('inf')] * n\n            dist[start] = 0\n            pq = [(0, start)]\n            while pq:\n                current_dist, u = heappop(pq)\n                if u == end:\n                    return current_dist\n                if current_dist > dist[u]:\n                    continue\n                for v, weight in graph[u]:\n                    distance = current_dist + weight\n                    if distance < dist[v]:\n                        dist[v] = distance\n                        heappush(pq, (distance, v))\n            return dist[end]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append((i + 1, 1))\n        \n        results = []\n        for u, v in queries:\n            graph[u].append((v, 1))\n            shortest_path = dijkstra(graph, 0, n - 1)\n            results.append(shortest_path)\n        \n        return results"
    ],
    "all_solutions": [
      "from typing import List\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(graph, start, end):\n            dist = [float('inf')] * n\n            dist[start] = 0\n            pq = [(0, start)]\n            while pq:\n                current_dist, u = heappop(pq)\n                if u == end:\n                    return current_dist\n                if current_dist > dist[u]:\n                    continue\n                for v, weight in graph[u]:\n                    distance = current_dist + weight\n                    if distance < dist[v]:\n                        dist[v] = distance\n                        heappush(pq, (distance, v))\n            return dist[end]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append((i + 1, 1))\n        \n        results = []\n        for u, v in queries:\n            graph[u].append((v, 1))\n            shortest_path = dijkstra(graph, 0, n - 1)\n            results.append(shortest_path)\n        \n        return results"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "from typing import List\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(graph, start, end):\n            dist = [float('inf')] * n\n            dist[start] = 0\n            pq = [(0, start)]\n            while pq:\n                current_dist, u = heappop(pq)\n                if u == end:\n                    return current_dist\n                if current_dist > dist[u]:\n                    continue\n                for v, weight in graph[u]:\n                    distance = current_dist + weight\n                    if distance < dist[v]:\n                        dist[v] = distance\n                        heappush(pq, (distance, v))\n            return dist[end]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append((i + 1, 1))\n        \n        results = []\n        for u, v in queries:\n            graph[u].append((v, 1))\n            shortest_path = dijkstra(graph, 0, n - 1)\n            results.append(shortest_path)\n        \n        return results",
        "solution_hash": "2eee5492f8cb0eb8b86b5fd400c03b1f688085bc89e8c36708f66bdcfb437ff9",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 14.140262842178345,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        14.140262842178345
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 1113,
          "max": 1113,
          "avg": 1113.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 124.75182151794434,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "number-of-subsequences-with-odd-sum",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "unsolved",
    "best_solution": "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence has an even sum (0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number doesn't change the parity of the sum\n                even_count = (even_count * 2) % MOD\n                odd_count = (odd_count * 2) % MOD\n            else:\n                # Odd number flips the parity of the sum\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
    "passed_solutions": [
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence has an even sum (0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number doesn't change the parity of the sum\n                even_count = (even_count * 2) % MOD\n                odd_count = (odd_count * 2) % MOD\n            else:\n                # Odd number flips the parity of the sum\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count"
    ],
    "all_solutions": [
      "class Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 0  # No empty subsequence initially\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2 + even_count) % MOD\n            else:\n                new_odd_count = (even_count + odd_count + 1) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # Start with the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count + 1\n        \n        return odd_count % MOD",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # Start with the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count + 1\n        \n        return odd_count % MOD",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # Start with the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = (new_odd_count + 1) % MOD  # Add the single-element subsequence [num]\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 0  # No empty subsequence initially\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2 + even_count) % MOD\n            else:\n                new_odd_count = (even_count + odd_count + 1) % MOD\n                even_count = (even_count * 2 + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # Start with the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = (new_odd_count + 1) % MOD\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence is considered even (sum = 0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number: doubles the number of subsequences of each type\n                even_count = (even_count * 2) % MOD\n            else:\n                # Odd number: flips the parity of existing subsequences\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # Start with the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = (new_odd_count + 1) % MOD  # Add 1 for the subsequence consisting of just this odd number\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 0  # No empty subsequence initially\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2 + even_count) % MOD\n            else:\n                new_odd_count = (even_count + odd_count + 1) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # Start with the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count + 1\n        \n        return odd_count % MOD",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # Start with the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = (new_odd_count + 1) % MOD  # Add 1 for the subsequence consisting of just this number\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        total_subsequences = 1  # This includes the empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even numbers do not change the parity of the sum\n                total_subsequences = (total_subsequences * 2) % MOD\n            else:\n                # Odd numbers flip the parity of the sum\n                new_odd_count = (total_subsequences - odd_count) % MOD\n                odd_count = (odd_count + new_odd_count) % MOD\n        \n        return odd_count",
      "class Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence has an even sum (0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number doesn't change the parity of the sum\n                even_count = (even_count * 2) % MOD\n            else:\n                # Odd number flips the parity of the sum\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence has an even sum (0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number doesn't change the parity of the sum\n                even_count = (even_count * 2) % MOD\n            else:\n                # Odd number flips the parity of the sum\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "# Test case\nnums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]\nsolution = Solution()\nprint(solution.subsequenceCount(nums))  # Expected output: 1024",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence has an even sum (0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number doesn't change the parity of the sum\n                even_count = (even_count * 2) % MOD\n            else:\n                # Odd number flips the parity of the sum\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
      "from typing import List\n\nclass Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence has an even sum (0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number doesn't change the parity of the sum\n                even_count = (even_count * 2) % MOD\n                odd_count = (odd_count * 2) % MOD\n            else:\n                # Odd number flips the parity of the sum\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count"
    ],
    "total_candidates": 18,
    "nodes_explored": 18,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count = (even_count * 2) % MOD\n            else:\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count * 2) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
        "solution_hash": "7f0507ce4cbb263d0be85fcb3964a927c56583fc4afcc77ca43895b206fc9df6",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmplccu_o5v.py\", line 191, in <module>\n    check(Solution().subsequenceCount)\n  File \"/scratch/local/21926554/tmplccu_o5v.py\", line 99, in check\n    assert candidate(nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]) == 1024\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmplccu_o5v.py` failed. (See above for error)\n",
          "execution_time": 14.002283573150635,
          "failed_tests": [
            {
              "input": "nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]",
              "expected": "1024",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmplccu_o5v.py\", line 191, in <module>\n    check(Solution().subsequenceCount)\n  File \"/scratch/local/21926554/tmplccu_o5v.py\", line 99, in check\n    assert candidate(nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]) == 1024\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmplccu_o5v.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_1",
          "1_5",
          "1_9"
        ],
        "passed": false
      },
      {
        "node_id": "0_1",
        "solution": "class Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        even_count = 1  # The empty subsequence has an even sum (0)\n        odd_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Even number doesn't change the parity of the sum\n                even_count = (even_count * 2) % MOD\n            else:\n                # Odd number flips the parity of the sum\n                new_odd_count = (even_count + odd_count) % MOD\n                even_count = (even_count + odd_count) % MOD\n                odd_count = new_odd_count\n        \n        return odd_count",
        "solution_hash": "d36fc7ec9c5d48a751783d98ce85ec2fe271734db5b7f7869fd63d6eca9b1101",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpgwove44v.py\", line 193, in <module>\n    check(Solution().subsequenceCount)\n  File \"/scratch/local/21926554/tmpgwove44v.py\", line 101, in check\n    assert candidate(nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]) == 1024\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpgwove44v.py` failed. (See above for error)\n",
          "execution_time": 13.686547756195068,
          "failed_tests": [
            {
              "input": "nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]",
              "expected": "1024",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpgwove44v.py\", line 193, in <module>\n    check(Solution().subsequenceCount)\n  File \"/scratch/local/21926554/tmpgwove44v.py\", line 101, in check\n    assert candidate(nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]) == 1024\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpgwove44v.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_14"
        ],
        "passed": false
      }
    ],
    "stats": {
      "nodes_explored": 18,
      "candidates_generated": 18,
      "tests_passed": 1,
      "tests_failed": 17,
      "test_errors": 0,
      "execution_times": [
        14.002283573150635,
        13.615220308303833,
        14.178704738616943,
        14.178704738616943,
        13.649035215377808,
        13.61664342880249,
        13.649035215377808,
        13.898020267486572,
        13.649035215377808,
        13.615220308303833,
        14.178704738616943,
        13.649035215377808,
        13.853267669677734,
        13.686547756195068,
        13.898020267486572,
        14.01155138015747,
        13.898020267486572,
        13.620327949523926
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 1,
        "iteration_limit": 1
      },
      "solution_diversity": {
        "unique_solutions": 10,
        "unique_ratio": 0.5555555555555556,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 149,
          "max": 716,
          "avg": 569.8888888888889
        }
      },
      "test_case_analysis": {
        "hardest_cases": {
          "nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]": 16
        },
        "first_failing_tests": {
          "nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]": 16
        }
      },
      "feedback_impact": {
        "depths": {
          "1": {
            "attempts": 6,
            "improvements": 0,
            "solved": 0
          },
          "2": {
            "attempts": 12,
            "improvements": 1,
            "solved": 1
          }
        },
        "error_types": {
          "assertion_failure": {
            "attempts": 6,
            "improvements": 2
          }
        },
        "test_case_improvements": {
          "nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]": 1
        },
        "error_transitions": {
          "assertion_failure->assertion_failure": 14,
          "assertion_failure->name_error": 1,
          "assertion_failure->unknown": 1
        }
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 2,
          "avg_depth": 1.5555555555555556,
          "solutions_per_depth": {
            "0": 2,
            "1": 4,
            "2": 12
          },
          "passing_solutions_per_depth": {
            "0": 0,
            "1": 0,
            "2": 1
          }
        },
        "pass_at_k": {
          "pass@1": 0.10526315789473684,
          "pass@3": 0.29824561403508776,
          "pass@5": 0.4678362573099415,
          "pass@10": 0.7894736842105263
        },
        "solutions_evaluated": 19,
        "passing_solution_depths": {
          "min": 2,
          "max": 2,
          "avg": 2.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 0.05555555555555555,
          "branch_success_rate": 0.05555555555555555
        },
        "error_recovery": {
          "total_attempts": 6,
          "total_improvements": 2,
          "recovery_rate": 0.3333333333333333
        },
        "top_errors": [
          [
            "assertion_failure",
            6
          ]
        ],
        "hardest_test_cases": [
          [
            "nums = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]",
            16
          ]
        ],
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 1,
          "iteration_limit": 1
        }
      }
    },
    "processing_time": 495.9669179916382,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.10526315789473684,
        "pass@3": 0.29824561403508776,
        "pass@5": 0.4678362573099415,
        "pass@10": 0.7894736842105263
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 5
            }
          ],
          [
            6,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 6
            }
          ],
          [
            7,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 7
            }
          ],
          [
            8,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 8
            }
          ],
          [
            9,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 9
            }
          ],
          [
            10,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 10
            }
          ],
          [
            11,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 11
            }
          ],
          [
            12,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 12
            }
          ],
          [
            13,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 13
            }
          ],
          [
            14,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 14
            }
          ],
          [
            15,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: name 'Solution' is not defined",
              "completion_id": 15
            }
          ],
          [
            16,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 16
            }
          ],
          [
            17,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 17
            }
          ],
          [
            18,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 18
            }
          ]
        ]
      },
      "solutions_evaluated": 19,
      "test_cases": 1
    }
  },
  {
    "problem_id": "count-the-number-of-good-nodes",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "unsolved",
    "best_solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # Collect subtree sizes of all children\n            subtree_sizes = [dfs(neighbor, node) for neighbor in graph[node] if neighbor != parent]\n            \n            # If there are no children, the subtree size is 1 and it's a good node\n            if not subtree_sizes:\n                self.good_nodes_count += 1\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count",
    "passed_solutions": [
      "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # Collect subtree sizes of all children\n            subtree_sizes = [dfs(neighbor, node) for neighbor in graph[node] if neighbor != parent]\n            \n            # If there are no children, the subtree size is 1 and it's a good node\n            if not subtree_sizes:\n                self.good_nodes_count += 1\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count"
    ],
    "all_solutions": [
      "class Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # If the node is a leaf, its subtree size is 1\n            if len(graph[node]) == 1 and node != 0:\n                return 1\n            \n            subtree_sizes = []\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    subtree_size = dfs(neighbor, node)\n                    subtree_sizes.append(subtree_size)\n            \n            # If there are no children, the subtree size is 1\n            if not subtree_sizes:\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count",
      "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # Collect subtree sizes of all children\n            subtree_sizes = [dfs(neighbor, node) for neighbor in graph[node] if neighbor != parent]\n            \n            # If there are no children, the subtree size is 1\n            if not subtree_sizes:\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count",
      "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # Collect subtree sizes of all children\n            subtree_sizes = [dfs(neighbor, node) for neighbor in graph[node] if neighbor != parent]\n            \n            # If there are no children, the subtree size is 1\n            if not subtree_sizes:\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count",
      "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # Collect subtree sizes of all children\n            subtree_sizes = [dfs(neighbor, node) for neighbor in graph[node] if neighbor != parent]\n            \n            # If there are no children, the subtree size is 1 and it's a good node\n            if not subtree_sizes:\n                self.good_nodes_count += 1\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count",
      "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # Collect subtree sizes of all children\n            subtree_sizes = [dfs(neighbor, node) for neighbor in graph[node] if neighbor != parent]\n            \n            # If there are no children, the subtree size is 1\n            if not subtree_sizes:\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count"
    ],
    "total_candidates": 5,
    "nodes_explored": 5,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        # Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            # If the node is a leaf, its subtree size is 1\n            if len(graph[node]) == 1 and node != 0:\n                return 1\n            \n            subtree_sizes = []\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    subtree_size = dfs(neighbor, node)\n                    subtree_sizes.append(subtree_size)\n            \n            # If there are no children, the subtree size is 1\n            if not subtree_sizes:\n                return 1\n            \n            # Check if all subtree sizes are the same\n            if len(set(subtree_sizes)) == 1:\n                self.good_nodes_count += 1\n            \n            # Return the total size of the subtree rooted at 'node'\n            return sum(subtree_sizes) + 1\n        \n        self.good_nodes_count = 0\n        dfs(0, -1)  # Start DFS from the root node (0) with no parent (-1)\n        return self.good_nodes_count",
        "solution_hash": "f12552949a9c45fa28a2cfed7f392c623487c4a9ecd349310fef34b3f9091477",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp3djke4qk.py\", line 169, in <module>\n    check(Solution().countGoodNodes)\n  File \"/scratch/local/21926554/tmp3djke4qk.py\", line 119, in check\n    assert candidate(edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [1, 6], [2, 7], [3, 8]]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp3djke4qk.py` failed. (See above for error)\n",
          "execution_time": 13.866004943847656,
          "failed_tests": [
            {
              "input": "edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [1, 6], [2, 7], [3, 8]]",
              "expected": "6",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp3djke4qk.py\", line 169, in <module>\n    check(Solution().countGoodNodes)\n  File \"/scratch/local/21926554/tmp3djke4qk.py\", line 119, in check\n    assert candidate(edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [1, 6], [2, 7], [3, 8]]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp3djke4qk.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_1"
        ],
        "passed": false
      }
    ],
    "stats": {
      "nodes_explored": 5,
      "candidates_generated": 5,
      "tests_passed": 1,
      "tests_failed": 4,
      "test_errors": 0,
      "execution_times": [
        13.866004943847656,
        13.86540675163269,
        13.86540675163269,
        13.564661502838135,
        13.86540675163269
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 1,
        "iteration_limit": 1
      },
      "solution_diversity": {
        "unique_solutions": 3,
        "unique_ratio": 0.6,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 1067,
          "max": 1277,
          "avg": 1121.8
        }
      },
      "test_case_analysis": {
        "hardest_cases": {
          "edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [1, 6], [2, 7], [3, 8]]": 4
        },
        "first_failing_tests": {
          "edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [1, 6], [2, 7], [3, 8]]": 4
        }
      },
      "feedback_impact": {
        "depths": {
          "1": {
            "attempts": 3,
            "improvements": 0,
            "solved": 0
          },
          "2": {
            "attempts": 3,
            "improvements": 0,
            "solved": 1
          }
        },
        "error_types": {
          "assertion_failure": {
            "attempts": 2,
            "improvements": 1
          }
        },
        "test_case_improvements": {},
        "error_transitions": {
          "assertion_failure->assertion_failure": 3,
          "assertion_failure->unknown": 1
        }
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 2,
          "avg_depth": 1.4,
          "solutions_per_depth": {
            "0": 1,
            "1": 1,
            "2": 3
          },
          "passing_solutions_per_depth": {
            "0": 0,
            "1": 0,
            "2": 1
          }
        },
        "pass_at_k": {
          "pass@1": 0.33333333333333326,
          "pass@3": 0.8,
          "pass@5": 1.0
        },
        "solutions_evaluated": 6,
        "passing_solution_depths": {
          "min": 2,
          "max": 2,
          "avg": 2.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 0.2,
          "branch_success_rate": 0.2
        },
        "error_recovery": {
          "total_attempts": 2,
          "total_improvements": 1,
          "recovery_rate": 0.5
        },
        "top_errors": [
          [
            "assertion_failure",
            2
          ]
        ],
        "hardest_test_cases": [
          [
            "edges = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [1, 6], [2, 7], [3, 8]]",
            4
          ]
        ],
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 1,
          "iteration_limit": 1
        }
      }
    },
    "processing_time": 232.56738376617432,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.33333333333333326,
        "pass@3": 0.8,
        "pass@5": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 5
            }
          ]
        ]
      },
      "solutions_evaluated": 6,
      "test_cases": 1
    }
  },
  {
    "problem_id": "construct-string-with-minimum-cost-easy",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        n = len(target)\n        dp = [inf] * (n + 1)\n        dp[0] = 0  # Base case: no cost to create an empty string\n        \n        for i in range(1, n + 1):\n            for j, word in enumerate(words):\n                if i >= len(word) and target[i - len(word):i] == word:\n                    dp[i] = min(dp[i], dp[i - len(word)] + costs[j])\n        \n        return dp[n] if dp[n] != inf else -1",
    "passed_solutions": [
      "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        n = len(target)\n        dp = [inf] * (n + 1)\n        dp[0] = 0  # Base case: no cost to create an empty string\n        \n        for i in range(1, n + 1):\n            for j, word in enumerate(words):\n                if i >= len(word) and target[i - len(word):i] == word:\n                    dp[i] = min(dp[i], dp[i - len(word)] + costs[j])\n        \n        return dp[n] if dp[n] != inf else -1"
    ],
    "all_solutions": [
      "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        n = len(target)\n        dp = [inf] * (n + 1)\n        dp[0] = 0  # Base case: no cost to create an empty string\n        \n        for i in range(1, n + 1):\n            for j, word in enumerate(words):\n                if i >= len(word) and target[i - len(word):i] == word:\n                    dp[i] = min(dp[i], dp[i - len(word)] + costs[j])\n        \n        return dp[n] if dp[n] != inf else -1"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        n = len(target)\n        dp = [inf] * (n + 1)\n        dp[0] = 0  # Base case: no cost to create an empty string\n        \n        for i in range(1, n + 1):\n            for j, word in enumerate(words):\n                if i >= len(word) and target[i - len(word):i] == word:\n                    dp[i] = min(dp[i], dp[i - len(word)] + costs[j])\n        \n        return dp[n] if dp[n] != inf else -1",
        "solution_hash": "3828e72ee16e1913a2f8eb6e6ac528a3f193e231cbc53620e3b1739093215eca",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.625241041183472,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.625241041183472
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 499,
          "max": 499,
          "avg": 499.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 58.525126934051514,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "find-the-power-of-k-size-subarrays-i",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results",
    "passed_solutions": [
      "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results"
    ],
    "all_solutions": [
      "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results",
        "solution_hash": "64b9e7ec99f50ea4762484c836a077060180c80e05701fd37a98ee8837485564",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.614400863647461,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.614400863647461
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 499,
          "max": 499,
          "avg": 499.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 52.40123248100281,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "find-the-power-of-k-size-subarrays-ii",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results",
    "passed_solutions": [
      "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results"
    ],
    "all_solutions": [
      "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        def is_consecutive_sorted(subarray):\n            return all(subarray[i] + 1 == subarray[i + 1] for i in range(len(subarray) - 1))\n        \n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if is_consecutive_sorted(subarray):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results",
        "solution_hash": "64b9e7ec99f50ea4762484c836a077060180c80e05701fd37a98ee8837485564",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.614400863647461,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.614400863647461
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 499,
          "max": 499,
          "avg": 499.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 38.17679286003113,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "maximum-energy-boost-from-two-drinks",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        # dp[i][0] means max energy boost up to hour i drinking from A at hour i\n        # dp[i][1] means max energy boost up to hour i drinking from B at hour i\n        dp = [[0, 0] for _ in range(n)]\n        \n        # Initialize the first hour\n        dp[0][0] = energyDrinkA[0]\n        dp[0][1] = energyDrinkB[0]\n        \n        for i in range(1, n):\n            # If we drink from A at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][0] = max(dp[i-1][0] + energyDrinkA[i], dp[i-1][1] + energyDrinkA[i] - energyDrinkB[i-1])\n            # If we drink from B at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][1] = max(dp[i-1][1] + energyDrinkB[i], dp[i-1][0] + energyDrinkB[i] - energyDrinkA[i-1])\n        \n        # The result is the maximum energy boost we can achieve by the end of the nth hour\n        return max(dp[n-1][0], dp[n-1][1])",
    "passed_solutions": [
      "class Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        # dp[i][0] means max energy boost up to hour i drinking from A at hour i\n        # dp[i][1] means max energy boost up to hour i drinking from B at hour i\n        dp = [[0, 0] for _ in range(n)]\n        \n        # Initialize the first hour\n        dp[0][0] = energyDrinkA[0]\n        dp[0][1] = energyDrinkB[0]\n        \n        for i in range(1, n):\n            # If we drink from A at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][0] = max(dp[i-1][0] + energyDrinkA[i], dp[i-1][1] + energyDrinkA[i] - energyDrinkB[i-1])\n            # If we drink from B at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][1] = max(dp[i-1][1] + energyDrinkB[i], dp[i-1][0] + energyDrinkB[i] - energyDrinkA[i-1])\n        \n        # The result is the maximum energy boost we can achieve by the end of the nth hour\n        return max(dp[n-1][0], dp[n-1][1])"
    ],
    "all_solutions": [
      "class Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        # dp[i][0] means max energy boost up to hour i drinking from A at hour i\n        # dp[i][1] means max energy boost up to hour i drinking from B at hour i\n        dp = [[0, 0] for _ in range(n)]\n        \n        # Initialize the first hour\n        dp[0][0] = energyDrinkA[0]\n        dp[0][1] = energyDrinkB[0]\n        \n        for i in range(1, n):\n            # If we drink from A at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][0] = max(dp[i-1][0] + energyDrinkA[i], dp[i-1][1] + energyDrinkA[i] - energyDrinkB[i-1])\n            # If we drink from B at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][1] = max(dp[i-1][1] + energyDrinkB[i], dp[i-1][0] + energyDrinkB[i] - energyDrinkA[i-1])\n        \n        # The result is the maximum energy boost we can achieve by the end of the nth hour\n        return max(dp[n-1][0], dp[n-1][1])"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        # dp[i][0] means max energy boost up to hour i drinking from A at hour i\n        # dp[i][1] means max energy boost up to hour i drinking from B at hour i\n        dp = [[0, 0] for _ in range(n)]\n        \n        # Initialize the first hour\n        dp[0][0] = energyDrinkA[0]\n        dp[0][1] = energyDrinkB[0]\n        \n        for i in range(1, n):\n            # If we drink from A at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][0] = max(dp[i-1][0] + energyDrinkA[i], dp[i-1][1] + energyDrinkA[i] - energyDrinkB[i-1])\n            # If we drink from B at hour i, we could have come from A or B at hour i-1 with a penalty\n            dp[i][1] = max(dp[i-1][1] + energyDrinkB[i], dp[i-1][0] + energyDrinkB[i] - energyDrinkA[i-1])\n        \n        # The result is the maximum energy boost we can achieve by the end of the nth hour\n        return max(dp[n-1][0], dp[n-1][1])",
        "solution_hash": "a3cfd1f6edf67bf54511a59b36b6f9a3a99eeb24210255b77511bbb9853f32c5",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.606029272079468,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.606029272079468
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 1049,
          "max": 1049,
          "avg": 1049.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 75.71853756904602,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "count-almost-equal-pairs-i",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "unsolved",
    "best_solution": null,
    "passed_solutions": [],
    "all_solutions": [
      "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Function to create a sorted tuple of digits from a number\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        # Dictionary to count occurrences of each sorted digit pattern\n        digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Get the sorted digit pattern\n            pattern = sorted_digits(num)\n            # Add the current count of this pattern to the result\n            count += digit_count[pattern]\n            # Increment the count of this pattern in the dictionary\n            digit_count[pattern] += 1\n        \n        return count",
      "from itertools import permutations\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            variations = set()\n            for i, j in permutations(range(len(num_str)), 2):\n                swapped = list(num_str)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_representation(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sorted_digit_representation(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        return count",
      "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            sorted_num = sort_digits(num)\n            count += sorted_count[sorted_num]\n            sorted_count[sorted_num] += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_representation(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        digit_representations = [sorted_digit_representation(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if digit_representations[i] == digit_representations[j]:\n                    count += 1\n        return count",
      "from itertools import permutations\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_permutations(num):\n            # Generate all unique permutations of the digits of the number\n            return set(int(''.join(p)) for p in permutations(str(num)))\n        \n        count = 0\n        n = len(nums)\n        \n        # Check each pair (i, j) with i < j\n        for i in range(n):\n            perms_i = generate_permutations(nums[i])\n            for j in range(i + 1, n):\n                if nums[j] in perms_i:\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and sort their digits\n            sx = sorted(str(x))\n            sy = sorted(str(y))\n            \n            # If sorted digits are not the same, they cannot be made equal by one swap\n            if sx != sy:\n                return False\n            \n            # Count mismatches between the original strings\n            mismatch_count = sum(1 for a, b in zip(str(x), str(y)) if a != b)\n            \n            # They can be made equal by one swap if there are exactly two mismatches\n            return mismatch_count == 2\n        \n        count = 0\n        n = len(nums)\n        \n        # Check each pair (i, j) with i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and count digits\n            cx = Counter(str(x))\n            cy = Counter(str(y))\n            \n            # If the numbers have different lengths, they cannot be made almost equal\n            if len(cx) != len(cy):\n                return False\n            \n            # Find the difference in digit counts\n            diff = 0\n            for digit in cx:\n                if cx[digit] != cy.get(digit, 0):\n                    diff += abs(cx[digit] - cy.get(digit, 0))\n                    if diff > 2:\n                        return False\n            \n            # They can be made almost equal if there are at most two differing digits\n            return diff == 2\n        \n        count = 0\n        n = len(nums)\n        \n        # Check each pair (i, j) with i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            # Return a sorted tuple of digit counts\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = 0\n        n = len(nums)\n        digit_counts = [get_digit_count(num) for num in nums]\n        \n        # Check each pair (i, j) with i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                if digit_counts[i] == digit_counts[j]:\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_numbers(num_str):\n            n = len(num_str)\n            swapped_numbers = set()\n            for i in range(n):\n                for j in range(i + 1, n):\n                    # Swap digits at positions i and j\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    swapped_numbers.add(''.join(swapped))\n            return swapped_numbers\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str_i = str(nums[i])\n            swapped_numbers_i = generate_swapped_numbers(num_str_i)\n            for j in range(i + 1, n):\n                num_str_j = str(nums[j])\n                if num_str_j in swapped_numbers_i or num_str_i in generate_swapped_numbers(num_str_j):\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_sequence(num):\n            return ''.join(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_sequences = [sorted_digit_sequence(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_sequences[i] == sorted_sequences[j]:\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digit_representation(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            rep_i = sorted_digit_representation(nums[i])\n            for j in range(i + 1, n):\n                rep_j = sorted_digit_representation(nums[j])\n                if rep_i == rep_j:\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        n = len(nums)\n        sorted_nums = [sort_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
      "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import Counter\n        \n        # Normalize each number by sorting its digits\n        normalized = [''.join(sorted(str(num))) for num in nums]\n        \n        # Count occurrences of each normalized form\n        count = Counter(normalized)\n        \n        # Calculate the number of almost equal pairs\n        pairs = 0\n        for c in count.values():\n            # If there are c numbers with the same normalized form,\n            # we can choose 2 out of c in c*(c-1)/2 ways\n            pairs += c * (c - 1) // 2\n        \n        return pairs",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(num1, num2):\n            # Convert numbers to strings\n            str1, str2 = str(num1), str(num2)\n            \n            # If lengths differ, they cannot be made almost equal by swapping\n            if len(str1) != len(str2):\n                return False\n            \n            # Count digit frequencies\n            count1 = Counter(str1)\n            count2 = Counter(str2)\n            \n            # Find differences in digit counts\n            diff = 0\n            for digit in set(count1.keys()).union(set(count2.keys())):\n                if count1[digit] != count2[digit]:\n                    diff += abs(count1[digit] - count2[digit])\n                    if diff > 2:\n                        return False\n            \n            # They can be made almost equal if the total difference is 0 or 2\n            return diff == 0 or diff == 2\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(num1, num2):\n            # Convert numbers to strings\n            str1, str2 = str(num1), str(num2)\n            \n            # If lengths differ, they cannot be made almost equal by swapping\n            if len(str1) != len(str2):\n                return False\n            \n            # Find differing positions\n            diffs = []\n            for i in range(len(str1)):\n                if str1[i] != str2[i]:\n                    diffs.append((str1[i], str2[i]))\n                    if len(diffs) > 2:\n                        return False\n            \n            # They can be made almost equal if there are exactly 0 or 2 differences\n            # and the differences are complements of each other\n            if len(diffs) == 0:\n                return True\n            if len(diffs) == 2:\n                return diffs[0] == (diffs[1][1], diffs[1][0])\n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(num1, num2):\n            # Convert numbers to sorted strings\n            str1, str2 = sorted(str(num1)), sorted(str(num2))\n            \n            # If lengths differ, they cannot be made almost equal by swapping\n            if len(str1) != len(str2):\n                return False\n            \n            # Check if sorted strings are identical\n            return str1 == str2\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(num1, num2):\n            # Convert numbers to sorted strings\n            str1, str2 = sorted(str(num1)), sorted(str(num2))\n            \n            # If lengths differ, they cannot be made almost equal by swapping\n            if len(str1) != len(str2):\n                return False\n            \n            # Count mismatches\n            mismatches = sum(c1 != c2 for c1, c2 in zip(str1, str2))\n            \n            # They can be made almost equal if there are 0 or 2 mismatches\n            return mismatches == 0 or mismatches == 2\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
      "from itertools import permutations\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_versions(num):\n            num_str = str(num)\n            swapped_versions = set()\n            for perm in permutations(num_str):\n                swapped_versions.add(int(''.join(perm)))\n            return swapped_versions\n        \n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                swapped_i = generate_swapped_versions(nums[i])\n                swapped_j = generate_swapped_versions(nums[j])\n                if swapped_i & swapped_j:\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        n = len(nums)\n        count = 0\n        sorted_nums = [sorted_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        n = len(nums)\n        count = 0\n        sorted_nums = [sort_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        n = len(nums)\n        count = 0\n        sorted_nums = [sort_digits(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if sorted_nums[i] == sorted_nums[j]:\n                    count += 1\n        \n        return count",
      "from itertools import combinations\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num_str):\n            variations = set()\n            for i, j in combinations(range(len(num_str)), 2):\n                swapped = list(num_str)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                variations.add(''.join(swapped))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            num_str_i = str(nums[i])\n            variations_i = generate_swapped_variations(num_str_i)\n            for j in range(i + 1, n):\n                num_str_j = str(nums[j])\n                if num_str_j in variations_i or num_str_i in generate_swapped_variations(num_str_j):\n                    count += 1\n        \n        return count",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Sort the digits of each number and count occurrences\n        sorted_digit_counts = Counter(''.join(sorted(str(num))) for num in nums)\n        \n        # Calculate the number of almost equal pairs\n        count = 0\n        for count_val in sorted_digit_counts.values():\n            if count_val > 1:\n                # Use combination formula to count pairs\n                count += count_val * (count_val - 1) // 2\n        \n        return count",
      "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Create a dictionary to store sorted tuples of digits\n        digit_count = defaultdict(int)\n        \n        # Count occurrences of each sorted tuple of digits\n        for num in nums:\n            sorted_digits = tuple(sorted(str(num)))\n            digit_count[sorted_digits] += 1\n        \n        count = 0\n        \n        # Calculate the number of almost equal pairs\n        for num in nums:\n            sorted_digits = tuple(sorted(str(num)))\n            count += digit_count[sorted_digits] - 1\n        \n        # Since each pair is counted twice, divide by 2\n        return count // 2",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        # Sort the digits of each number and count occurrences\n        sorted_digit_counts = Counter(''.join(sorted(str(num))) for num in nums)\n        \n        count = 0\n        for sorted_digits, freq in sorted_digit_counts.items():\n            # If there are freq numbers with the same sorted digits,\n            # we can choose 2 out of these freq numbers in C(freq, 2) ways.\n            count += freq * (freq - 1) // 2\n        \n        return count",
      "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and sort their digits\n            sx = sorted(str(x))\n            sy = sorted(str(y))\n            # Check if they have at most one differing digit position\n            diff_count = sum(1 for a, b in zip(sx, sy) if a != b)\n            return diff_count <= 2\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings\n            sx = str(x)\n            sy = str(y)\n            \n            # If lengths differ, they cannot be made equal by swapping\n            if len(sx) != len(sy):\n                return False\n            \n            # Count mismatches in digit positions\n            mismatch_positions = []\n            for a, b in zip(sx, sy):\n                if a != b:\n                    mismatch_positions.append((a, b))\n            \n            # If there are no mismatches or exactly two mismatches that can be swapped, they are almost equal\n            if len(mismatch_positions) == 0:\n                return True\n            if len(mismatch_positions) == 2:\n                (a1, b1), (a2, b2) = mismatch_positions\n                return a1 == b2 and a2 == b1\n            \n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to sorted tuples of digits\n            sx = tuple(sorted(str(x)))\n            sy = tuple(sorted(str(y)))\n            \n            # If sorted digit sequences match, they are almost equal\n            return sx == sy\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and sort their digits\n            sx = sorted(str(x))\n            sy = sorted(str(y))\n            \n            # If sorted digits are the same, they can be made equal by swapping\n            return sx == sy\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and sort their digits\n            sx = ''.join(sorted(str(x)))\n            sy = ''.join(sorted(str(y)))\n            \n            # If sorted digit strings are equal, they can be made almost equal\n            return sx == sy\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings, sort their digits, and compare\n            return sorted(str(x)) == sorted(str(y))\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to counters of their digits\n            return Counter(str(x)) == Counter(str(y))\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swapped_variations(num):\n            num_str = str(num)\n            length = len(num_str)\n            variations = set()\n            for i in range(length):\n                for j in range(i + 1, length):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(int(''.join(swapped)))\n            return variations\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] in generate_swapped_variations(nums[i]) or nums[i] in generate_swapped_variations(nums[j]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            str_x, str_y = str(x), str(y)\n            if len(str_x) != len(str_y):\n                return False\n            \n            # Check if y can be obtained by swapping any two digits in x\n            for i in range(len(str_x)):\n                for j in range(i + 1, len(str_x)):\n                    swapped_str_x = str_x[:i] + str_x[j] + str_x[i+1:j] + str_x[i] + str_x[j+1:]\n                    if swapped_str_x == str_y:\n                        return True\n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and count their digits\n            cx = Counter(str(x))\n            cy = Counter(str(y))\n            # Check if they have the same multiset of digits\n            return cx == cy\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Sort the digits of both numbers and compare\n            return sorted(str(x)) == sorted(str(y))\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings, sort the digits, and compare\n            return sorted(str(x)) == sorted(str(y))\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
      "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            sx = str(x)\n            sy = str(y)\n            if len(sx) != len(sy):\n                return False\n            diff = []\n            for a, b in zip(sx, sy):\n                if a != b:\n                    diff.append((a, b))\n                if len(diff) > 2:\n                    return False\n            return len(diff) == 0 or (len(diff) == 2 and diff[0] == diff[1][::-1])\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count"
    ],
    "total_candidates": 39,
    "nodes_explored": 39,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Function to create a sorted tuple of digits from a number\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        # Dictionary to count occurrences of each sorted digit pattern\n        digit_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            # Get the sorted digit pattern\n            pattern = sorted_digits(num)\n            # Add the current count of this pattern to the result\n            count += digit_count[pattern]\n            # Increment the count of this pattern in the dictionary\n            digit_count[pattern] += 1\n        \n        return count",
        "solution_hash": "b6c3779ab981fc8cd9a505d2a671476354eff15a2cabd978430ff63cc220bc86",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpkm1uhnvz.py\", line 232, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926554/tmpkm1uhnvz.py\", line 106, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpkm1uhnvz.py` failed. (See above for error)\n",
          "execution_time": 13.613884925842285,
          "failed_tests": [
            {
              "input": "nums = [101, 110, 111, 1001, 1100]",
              "expected": "5",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpkm1uhnvz.py\", line 232, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926554/tmpkm1uhnvz.py\", line 106, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpkm1uhnvz.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_1",
          "1_5",
          "1_9"
        ],
        "passed": false
      },
      {
        "node_id": "0_1",
        "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import Counter\n        \n        # Normalize each number by sorting its digits\n        normalized = [''.join(sorted(str(num))) for num in nums]\n        \n        # Count occurrences of each normalized form\n        count = Counter(normalized)\n        \n        # Calculate the number of almost equal pairs\n        pairs = 0\n        for c in count.values():\n            # If there are c numbers with the same normalized form,\n            # we can choose 2 out of c in c*(c-1)/2 ways\n            pairs += c * (c - 1) // 2\n        \n        return pairs",
        "solution_hash": "492a3ee800982c88580d816bc6365de7bbe28983f5d56bbb0602a0678028e4ba",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp8dd9rbv8.py\", line 229, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926554/tmp8dd9rbv8.py\", line 103, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp8dd9rbv8.py` failed. (See above for error)\n",
          "execution_time": 13.582126140594482,
          "failed_tests": [
            {
              "input": "nums = [101, 110, 111, 1001, 1100]",
              "expected": "5",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp8dd9rbv8.py\", line 229, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926554/tmp8dd9rbv8.py\", line 103, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp8dd9rbv8.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_14",
          "1_18",
          "1_22"
        ],
        "passed": false
      },
      {
        "node_id": "0_2",
        "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(x, y):\n            # Convert numbers to strings and sort their digits\n            sx = sorted(str(x))\n            sy = sorted(str(y))\n            # Check if they have at most one differing digit position\n            diff_count = sum(1 for a, b in zip(sx, sy) if a != b)\n            return diff_count <= 2\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
        "solution_hash": "2c1ce8f5de7b16f8003db44b7d0d94b1662a5402b81a3c5321929799f2ab6d0c",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp3kj94ka4.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926554/tmp3kj94ka4.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp3kj94ka4.py` failed. (See above for error)\n",
          "execution_time": 13.557672023773193,
          "failed_tests": [
            {
              "input": "nums = [101, 110, 111, 1001, 1100]",
              "expected": "5",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp3kj94ka4.py\", line 228, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926554/tmp3kj94ka4.py\", line 102, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp3kj94ka4.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_27",
          "1_31",
          "1_35"
        ],
        "passed": false
      }
    ],
    "stats": {
      "nodes_explored": 39,
      "candidates_generated": 39,
      "tests_passed": 0,
      "tests_failed": 39,
      "test_errors": 0,
      "execution_times": [
        13.613884925842285,
        13.606680631637573,
        13.608325004577637,
        13.56480884552002,
        13.568980693817139,
        13.588903427124023,
        14.122604131698608,
        13.655479907989502,
        13.61370587348938,
        13.651018381118774,
        13.598929166793823,
        13.584593296051025,
        13.59031867980957,
        13.582126140594482,
        13.578234672546387,
        13.620606184005737,
        13.572403907775879,
        13.602911949157715,
        13.622562885284424,
        13.57459306716919,
        13.595978498458862,
        13.595978498458862,
        13.582817077636719,
        13.593690395355225,
        13.57956600189209,
        13.6004159450531,
        13.557672023773193,
        13.591385126113892,
        13.606889486312866,
        13.598703622817993,
        13.630451202392578,
        13.601631164550781,
        14.117732763290405,
        13.64104700088501,
        13.601916313171387,
        13.64582085609436,
        13.601631164550781,
        13.601631164550781,
        13.82011890411377
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      },
      "solution_diversity": {
        "unique_solutions": 36,
        "unique_ratio": 0.9230769230769231,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 457,
          "max": 1236,
          "avg": 690.1538461538462
        }
      },
      "test_case_analysis": {
        "hardest_cases": {
          "nums = [101, 110, 111, 1001, 1100]": 38,
          "nums = [123, 321, 231, 123, 132, 213]": 1
        },
        "first_failing_tests": {
          "nums = [101, 110, 111, 1001, 1100]": 38,
          "nums = [123, 321, 231, 123, 132, 213]": 1
        }
      },
      "feedback_impact": {
        "depths": {
          "1": {
            "attempts": 9,
            "improvements": 0,
            "solved": 0
          },
          "2": {
            "attempts": 27,
            "improvements": 0,
            "solved": 0
          }
        },
        "error_types": {
          "assertion_failure": {
            "attempts": 12,
            "improvements": 0
          }
        },
        "test_case_improvements": {},
        "error_transitions": {
          "assertion_failure->assertion_failure": 36
        }
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 2,
          "avg_depth": 1.6153846153846154,
          "solutions_per_depth": {
            "0": 3,
            "1": 9,
            "2": 27
          },
          "passing_solutions_per_depth": {
            "0": 0,
            "1": 0,
            "2": 0
          }
        },
        "pass_at_k": {
          "pass@1": 0.025000000000000022,
          "pass@3": 0.07499999999999996,
          "pass@5": 0.125,
          "pass@10": 0.25
        },
        "solutions_evaluated": 40
      },
      "summary": {
        "efficiency": {
          "solving_rate": 0.0,
          "branch_success_rate": 0.0
        },
        "error_recovery": {
          "total_attempts": 12,
          "total_improvements": 0,
          "recovery_rate": 0.0
        },
        "top_errors": [
          [
            "assertion_failure",
            12
          ]
        ],
        "hardest_test_cases": [
          [
            "nums = [101, 110, 111, 1001, 1100]",
            38
          ],
          [
            "nums = [123, 321, 231, 123, 132, 213]",
            1
          ]
        ],
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 1
        }
      }
    },
    "processing_time": 1164.547392129898,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.025000000000000022,
        "pass@3": 0.07499999999999996,
        "pass@5": 0.125,
        "pass@10": 0.25
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 5
            }
          ],
          [
            6,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 6
            }
          ],
          [
            7,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 7
            }
          ],
          [
            8,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 8
            }
          ],
          [
            9,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 9
            }
          ],
          [
            10,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 10
            }
          ],
          [
            11,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 11
            }
          ],
          [
            12,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 12
            }
          ],
          [
            13,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 13
            }
          ],
          [
            14,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 14
            }
          ],
          [
            15,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 15
            }
          ],
          [
            16,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 16
            }
          ],
          [
            17,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 17
            }
          ],
          [
            18,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 18
            }
          ],
          [
            19,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 19
            }
          ],
          [
            20,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 20
            }
          ],
          [
            21,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 21
            }
          ],
          [
            22,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 22
            }
          ],
          [
            23,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 23
            }
          ],
          [
            24,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 24
            }
          ],
          [
            25,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 25
            }
          ],
          [
            26,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 26
            }
          ],
          [
            27,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 27
            }
          ],
          [
            28,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 28
            }
          ],
          [
            29,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 29
            }
          ],
          [
            30,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 30
            }
          ],
          [
            31,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 31
            }
          ],
          [
            32,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 32
            }
          ],
          [
            33,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 33
            }
          ],
          [
            34,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 34
            }
          ],
          [
            35,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 35
            }
          ],
          [
            36,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 36
            }
          ],
          [
            37,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 37
            }
          ],
          [
            38,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 38
            }
          ],
          [
            39,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 39
            }
          ]
        ]
      },
      "solutions_evaluated": 40,
      "test_cases": 1
    }
  },
  {
    "problem_id": "hash-divided-string",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        result = []\n        for i in range(0, len(s), k):\n            substring = s[i:i+k]\n            hash_value = sum(ord(char) - ord('a') for char in substring)\n            hashed_char = chr(hash_value % 26 + ord('a'))\n            result.append(hashed_char)\n        return ''.join(result)",
    "passed_solutions": [
      "class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        result = []\n        for i in range(0, len(s), k):\n            substring = s[i:i+k]\n            hash_value = sum(ord(char) - ord('a') for char in substring)\n            hashed_char = chr(hash_value % 26 + ord('a'))\n            result.append(hashed_char)\n        return ''.join(result)"
    ],
    "all_solutions": [
      "class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        result = []\n        for i in range(0, len(s), k):\n            substring = s[i:i+k]\n            hash_value = sum(ord(char) - ord('a') for char in substring)\n            hashed_char = chr(hash_value % 26 + ord('a'))\n            result.append(hashed_char)\n        return ''.join(result)"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        result = []\n        for i in range(0, len(s), k):\n            substring = s[i:i+k]\n            hash_value = sum(ord(char) - ord('a') for char in substring)\n            hashed_char = chr(hash_value % 26 + ord('a'))\n            result.append(hashed_char)\n        return ''.join(result)",
        "solution_hash": "76f964d0600662324e3787c409d2e3579b4bd642627ec3b95d9ee66b8a932f6f",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.59395146369934,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.59395146369934
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 356,
          "max": 356,
          "avg": 356.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 46.41627550125122,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "k-th-nearest-obstacle-queries",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results",
    "passed_solutions": [
      "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results"
    ],
    "all_solutions": [
      "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        import heapq\n        \n        min_heap = []\n        results = []\n        \n        for x, y in queries:\n            distance = abs(x) + abs(y)\n            heapq.heappush(min_heap, -distance)  # Use negative to simulate max-heap behavior\n            \n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n            \n            if len(min_heap) < k:\n                results.append(-1)\n            else:\n                results.append(-min_heap[0])  # Convert back to positive\n        \n        return results",
        "solution_hash": "125231f8c4f1ecc5273fa4272118ca2459facf695688f6eef45c6d4a14d85ac9",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.908177375793457,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.908177375793457
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 626,
          "max": 626,
          "avg": 626.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 60.16914701461792,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "maximize-score-of-numbers-in-ranges",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        def canAchieve(min_diff):\n            prev = start[0]\n            for i in range(1, len(start)):\n                # Find the smallest number in the current interval that is at least min_diff away from prev\n                target = prev + min_diff\n                left, right = start[i], start[i] + d\n                if target > right:\n                    return False\n                if target >= left:\n                    prev = target\n                else:\n                    prev = left\n            return True\n        \n        start.sort()\n        low, high = 0, start[-1] + d - start[0]\n        best_score = 0\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if canAchieve(mid):\n                best_score = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return best_score",
    "passed_solutions": [
      "class Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        def canAchieve(min_diff):\n            prev = start[0]\n            for i in range(1, len(start)):\n                # Find the smallest number in the current interval that is at least min_diff away from prev\n                target = prev + min_diff\n                left, right = start[i], start[i] + d\n                if target > right:\n                    return False\n                if target >= left:\n                    prev = target\n                else:\n                    prev = left\n            return True\n        \n        start.sort()\n        low, high = 0, start[-1] + d - start[0]\n        best_score = 0\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if canAchieve(mid):\n                best_score = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return best_score"
    ],
    "all_solutions": [
      "class Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        def canAchieve(min_diff):\n            prev = start[0]\n            for i in range(1, len(start)):\n                # Find the smallest number in the current interval that is at least min_diff away from prev\n                target = prev + min_diff\n                left, right = start[i], start[i] + d\n                if target > right:\n                    return False\n                if target >= left:\n                    prev = target\n                else:\n                    prev = left\n            return True\n        \n        start.sort()\n        low, high = 0, start[-1] + d - start[0]\n        best_score = 0\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if canAchieve(mid):\n                best_score = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return best_score"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        def canAchieve(min_diff):\n            prev = start[0]\n            for i in range(1, len(start)):\n                # Find the smallest number in the current interval that is at least min_diff away from prev\n                target = prev + min_diff\n                left, right = start[i], start[i] + d\n                if target > right:\n                    return False\n                if target >= left:\n                    prev = target\n                else:\n                    prev = left\n            return True\n        \n        start.sort()\n        low, high = 0, start[-1] + d - start[0]\n        best_score = 0\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if canAchieve(mid):\n                best_score = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return best_score",
        "solution_hash": "211f399b471c2d26c12627c2307081b1082217fad57c9fa9b75b065b00efd257",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 14.045081853866577,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        14.045081853866577
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 954,
          "max": 954,
          "avg": 954.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 61.806612491607666,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "reach-end-of-array-with-max-score",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n        \n        return dp[-1]",
    "passed_solutions": [
      "class Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n        \n        return dp[-1]"
    ],
    "all_solutions": [
      "class Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n        \n        return dp[-1]"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n        \n        return dp[-1]",
        "solution_hash": "df25b2760f51333804a716536b414c08200ba24d32c939a786a8378734341627",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.644085168838501,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.644085168838501
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 299,
          "max": 299,
          "avg": 299.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 47.99676322937012,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "sum-of-consecutive-subarrays",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "unsolved",
    "best_solution": null,
    "passed_solutions": [],
    "all_solutions": [
      "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum += nums[start + j] * (j + 1) * (length - j)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_subarray_sum = 0\n                for k in range(j, i + 1):\n                    current_subarray_sum += nums[k]\n                    total_sum += current_subarray_sum\n                    total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                # Sum of subarray starting at start and ending at start + j\n                subarray_sum = (length - j) * (2 * nums[start] + j * diff) // 2\n                total_sum += subarray_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                # Sum of subarrays starting at index j\n                current_sum += nums[j] * (length - (j - start))\n            \n            total_sum += current_sum\n            total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                # Contribution of nums[start + j] to the total sum\n                total_sum += nums[start + j] * (j + 1) * (length - j)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            for j in range(start, i + 1):\n                subarray_sum = 0\n                for k in range(j, i + 1):\n                    subarray_sum += nums[k]\n                    total_sum += subarray_sum\n                    total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                # Sum of subarray starting at start and ending at start + j\n                subarray_sum = (length - j) * (2 * nums[start] + j * diff) // 2\n                total_sum += subarray_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum * (i - j + 1)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            # Sum of the first element of each subarray\n            first_element_sum = (length * (2 * nums[start] + (length - 1) * diff)) // 2\n            # Sum of all subarrays\n            subarray_sum = (length * (first_element_sum + (length - 1) * (nums[start] + (length - 1) * diff) // 2)) // 2\n            total_sum += subarray_sum\n            total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] to all subarrays ending at j\n                count_of_subarrays_ending_at_j = j - start + 1\n                total_sum += nums[j] * count_of_subarrays_ending_at_j\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] in all subarrays starting from start to j\n                total_sum += nums[j] * (j - start + 1) * (length - (j - start))\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] to all subarrays starting at or after j\n                total_sum += nums[j] * (length - (j - start))\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum += nums[start + j] * (j + 1) * (length - j)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                # Contribution of nums[j] to all subarrays starting at or before j\n                total_sum += nums[j] * (length - (j - start))\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                # Contribution of nums[j] to all subarrays ending at j\n                current_sum += nums[j]\n                total_sum += current_sum * (length - (j - start))\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum * (length - (j - start))\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(start, i + 1):\n                current_sum = 0\n                for k in range(j, i + 1):\n                    current_sum += nums[k]\n                    total_sum += current_sum\n                    total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            for j in range(start, i + 1):\n                subarray_sum = 0\n                for k in range(j, i + 1):\n                    subarray_sum += nums[k]\n                    total_sum += subarray_sum\n                    total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum * (i - j + 1)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            current_sum = 0\n            for j in range(start, i + 1):\n                current_sum += nums[j]\n                total_sum += current_sum * (i - j + 1)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                # Sum of subarray starting at start and ending at start + j\n                subarray_sum = (length - j) * (2 * nums[start] + j * diff) // 2\n                total_sum += subarray_sum\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
      "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            length = end - start\n            for i in range(start, end):\n                total_sum += nums[i] * (length - (i - start))\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            for i in range(start, end):\n                # Contribution of nums[i] to all subarrays ending at i\n                total_sum += nums[i] * (i - start + 1) * (end - i)\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        current_sum = nums[0]\n        length = 1\n        \n        for i in range(1, n):\n            if nums[i] - nums[i - 1] == 1 or nums[i] - nums[i - 1] == -1:\n                current_sum += nums[i]\n                length += 1\n            else:\n                # Add the sum of all subarrays in the current consecutive sequence\n                total_sum += (length * (length + 1) // 2) * current_sum\n                current_sum = nums[i]\n                length = 1\n        \n        # Add the sum of the last consecutive sequence\n        total_sum += (length * (length + 1) // 2) * current_sum\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        current_sum = 0\n        length = 0\n        \n        for i in range(n):\n            if i == 0 or nums[i] - nums[i - 1] in [1, -1]:\n                current_sum += nums[i]\n                length += 1\n            else:\n                # Calculate the sum of all subarrays in the previous segment\n                total_sum += (length * (length + 1) // 2) * current_sum\n                current_sum = nums[i]\n                length = 1\n            \n            # Handle the last segment\n            if i == n - 1:\n                total_sum += (length * (length + 1) // 2) * current_sum\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        current_sum = nums[0]\n        length = 1\n        \n        for i in range(1, n):\n            if nums[i] - nums[i - 1] == 1 or nums[i] - nums[i - 1] == -1:\n                current_sum += nums[i]\n                length += 1\n            else:\n                # Add the sum of all subarrays in the current consecutive segment\n                total_sum += (length * (length + 1) // 2) * current_sum\n                current_sum = nums[i]\n                length = 1\n        \n        # Add the sum of all subarrays for the last consecutive segment\n        total_sum += (length * (length + 1) // 2) * current_sum\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            length = end - start\n            for i in range(start, end):\n                # Contribution of nums[i] in all subarrays starting from index i\n                total_sum += nums[i] * (i - start + 1) * (length - i)\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            length = end - start\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                total_sum += current_sum * (length - i)\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            length = end - start\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                total_sum += current_sum\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            length = end - start\n            current_sum = 0\n            for i in range(start, end):\n                # Contribution of nums[i] in all subarrays starting from index i\n                current_sum += nums[i] * (i - start + 1) * (length - i)\n            \n            total_sum += current_sum\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            for i in range(start, end):\n                # Contribution of nums[i] to all subarrays ending at i\n                total_sum += nums[i] * (i - start + 1) * (end - i)\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            length = end - start\n            for i in range(start, end):\n                # Contribution of nums[i] to all subarrays ending at i\n                total_sum += nums[i] * (i - start + 1) * (length - (i - start))\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                # Number of subarrays ending at i\n                total_sum += current_sum\n            \n            start = end\n        \n        return total_sum % MOD",
      "from typing import List\n\nclass Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            direction = None\n            \n            # Determine the direction of the consecutive sequence\n            if end < n:\n                direction = nums[end] - nums[start]\n                if direction != 1 and direction != -1:\n                    total_sum += nums[start]\n                    start += 1\n                    continue\n            \n            # Extend the end of the consecutive sequence\n            while end < n and nums[end] - nums[end - 1] == direction:\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            current_sum = 0\n            for i in range(start, end):\n                current_sum += nums[i]\n                total_sum += current_sum\n            \n            start = end\n        \n        return total_sum % MOD"
    ],
    "total_candidates": 39,
    "nodes_explored": 39,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Expand the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and (diff == 1 or diff == -1)):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum += nums[start + j] * (j + 1) * (length - j)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
        "solution_hash": "13f1d66800d08473ac0e183d52effd40d215c912d623f00d2be8ee5e68408727",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpdsq_dl5i.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21926554/tmpdsq_dl5i.py\", line 121, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpdsq_dl5i.py` failed. (See above for error)\n",
          "execution_time": 13.961564302444458,
          "failed_tests": [
            {
              "input": "nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]",
              "expected": "224",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpdsq_dl5i.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21926554/tmpdsq_dl5i.py\", line 121, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpdsq_dl5i.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_1",
          "1_5",
          "1_9"
        ],
        "passed": false
      },
      {
        "node_id": "0_1",
        "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        total_sum = 0\n        \n        i = 0\n        while i < n:\n            start = i\n            # Determine the direction of the consecutive sequence\n            if i + 1 < n:\n                diff = nums[i + 1] - nums[i]\n            else:\n                diff = 0\n            \n            # Extend the window as long as the sequence is consecutive\n            while i + 1 < n and (nums[i + 1] - nums[i] == diff and abs(diff) == 1):\n                i += 1\n            \n            # Calculate the sum of all subarrays in the current window\n            length = i - start + 1\n            for j in range(length):\n                total_sum += nums[start + j] * (j + 1) * (length - j)\n                total_sum %= MOD\n            \n            i += 1\n        \n        return total_sum",
        "solution_hash": "56f8cd94f8d97fa7faf1b539cbd837acca7023b3859988d896cda21b51f674e2",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp6mtc10rd.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21926554/tmp6mtc10rd.py\", line 121, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp6mtc10rd.py` failed. (See above for error)\n",
          "execution_time": 13.637005090713501,
          "failed_tests": [
            {
              "input": "nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]",
              "expected": "224",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp6mtc10rd.py\", line 245, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21926554/tmp6mtc10rd.py\", line 121, in check\n    assert candidate(nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == 224\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp6mtc10rd.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_14",
          "1_18",
          "1_22"
        ],
        "passed": false
      },
      {
        "node_id": "0_2",
        "solution": "class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        total_sum = 0\n        start = 0\n        \n        while start < n:\n            end = start + 1\n            while end < n and (nums[end] - nums[end - 1] == 1 or nums[end] - nums[end - 1] == -1):\n                end += 1\n            \n            # Calculate the sum of all subarrays in the range [start, end-1]\n            length = end - start\n            for i in range(start, end):\n                total_sum += nums[i] * (length - (i - start))\n            \n            start = end\n        \n        return total_sum % MOD",
        "solution_hash": "3bdb9b3649a6d236fe39152829f9d18046244da7743bce67118821f7c1de805f",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpgkq22adn.py\", line 240, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21926554/tmpgkq22adn.py\", line 107, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpgkq22adn.py` failed. (See above for error)\n",
          "execution_time": 13.607920408248901,
          "failed_tests": [
            {
              "input": "nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]",
              "expected": "72",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpgkq22adn.py\", line 240, in <module>\n    check(Solution().getSum)\n  File \"/scratch/local/21926554/tmpgkq22adn.py\", line 107, in check\n    assert candidate(nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 72\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpgkq22adn.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_27",
          "1_31",
          "1_35"
        ],
        "passed": false
      }
    ],
    "stats": {
      "nodes_explored": 39,
      "candidates_generated": 39,
      "tests_passed": 0,
      "tests_failed": 38,
      "test_errors": 1,
      "execution_times": [
        13.961564302444458,
        14.027252912521362,
        13.875149965286255,
        13.637402772903442,
        13.588711261749268,
        13.623741149902344,
        13.875149965286255,
        13.57606291770935,
        13.585005044937134,
        13.598588943481445,
        13.877741575241089,
        13.62863302230835,
        13.600186824798584,
        13.637005090713501,
        13.925045013427734,
        13.925045013427734,
        13.917993307113647,
        13.925045013427734,
        13.925045013427734,
        13.584469079971313,
        13.584469079971313,
        13.617523670196533,
        13.61437463760376,
        13.576008319854736,
        13.576008319854736,
        13.585307836532593,
        13.607920408248901,
        13.622665643692017,
        13.629930973052979,
        13.616624593734741,
        13.629930973052979,
        13.599560499191284,
        13.898546695709229,
        13.728603601455688,
        10,
        13.622665643692017,
        13.868618488311768,
        13.637372255325317,
        13.646255016326904
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      },
      "solution_diversity": {
        "unique_solutions": 31,
        "unique_ratio": 0.7948717948717948,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 684,
          "max": 1154,
          "avg": 936.9230769230769
        }
      },
      "test_case_analysis": {
        "hardest_cases": {
          "nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]": 11,
          "nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]": 27
        },
        "first_failing_tests": {
          "nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]": 11,
          "nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]": 27
        }
      },
      "feedback_impact": {
        "depths": {
          "1": {
            "attempts": 9,
            "improvements": 0,
            "solved": 0
          },
          "2": {
            "attempts": 27,
            "improvements": 0,
            "solved": 0
          }
        },
        "error_types": {
          "assertion_failure": {
            "attempts": 12,
            "improvements": 0
          }
        },
        "test_case_improvements": {},
        "error_transitions": {
          "assertion_failure->assertion_failure": 35,
          "assertion_failure->other_error": 1
        }
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 2,
          "avg_depth": 1.6153846153846154,
          "solutions_per_depth": {
            "0": 3,
            "1": 9,
            "2": 27
          },
          "passing_solutions_per_depth": {
            "0": 0,
            "1": 0,
            "2": 0
          }
        },
        "pass_at_k": {
          "pass@1": 0.0,
          "pass@3": 0.0,
          "pass@5": 0.0,
          "pass@10": 0.0
        },
        "solutions_evaluated": 40
      },
      "summary": {
        "efficiency": {
          "solving_rate": 0.0,
          "branch_success_rate": 0.0
        },
        "error_recovery": {
          "total_attempts": 12,
          "total_improvements": 0,
          "recovery_rate": 0.0
        },
        "top_errors": [
          [
            "assertion_failure",
            12
          ]
        ],
        "hardest_test_cases": [
          [
            "nums = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]",
            27
          ],
          [
            "nums = [3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]",
            11
          ]
        ],
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 1
        }
      }
    },
    "processing_time": 1692.7032470703125,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.0,
        "pass@3": 0.0,
        "pass@5": 0.0,
        "pass@10": 0.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 5
            }
          ],
          [
            6,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 6
            }
          ],
          [
            7,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 7
            }
          ],
          [
            8,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 8
            }
          ],
          [
            9,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 9
            }
          ],
          [
            10,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 10
            }
          ],
          [
            11,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 11
            }
          ],
          [
            12,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 12
            }
          ],
          [
            13,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 13
            }
          ],
          [
            14,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 14
            }
          ],
          [
            15,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 15
            }
          ],
          [
            16,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 16
            }
          ],
          [
            17,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 17
            }
          ],
          [
            18,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 18
            }
          ],
          [
            19,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 19
            }
          ],
          [
            20,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 20
            }
          ],
          [
            21,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 21
            }
          ],
          [
            22,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 22
            }
          ],
          [
            23,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 23
            }
          ],
          [
            24,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 24
            }
          ],
          [
            25,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 25
            }
          ],
          [
            26,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 26
            }
          ],
          [
            27,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 27
            }
          ],
          [
            28,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 28
            }
          ],
          [
            29,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 29
            }
          ],
          [
            30,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 30
            }
          ],
          [
            31,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 31
            }
          ],
          [
            32,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 32
            }
          ],
          [
            33,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 33
            }
          ],
          [
            34,
            {
              "task_id": 0,
              "passed": false,
              "result": "timed out",
              "completion_id": 34
            }
          ],
          [
            35,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 35
            }
          ],
          [
            36,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 36
            }
          ],
          [
            37,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 37
            }
          ],
          [
            38,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 38
            }
          ],
          [
            39,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: name 'pairwise' is not defined",
              "completion_id": 39
            }
          ]
        ]
      },
      "solutions_evaluated": 40,
      "test_cases": 1
    }
  },
  {
    "problem_id": "find-a-safe-walk-through-a-grid",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "unsolved",
    "best_solution": "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        max_health_at_cell = [[0] * n for _ in range(m)]\n        max_health_at_cell[0][0] = health\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0 and new_health > max_health_at_cell[nx][ny]:\n                        max_health_at_cell[nx][ny] = new_health\n                        queue.append((nx, ny, new_health))\n        \n        return False",
    "passed_solutions": [
      "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        max_health_at_cell = [[0] * n for _ in range(m)]\n        max_health_at_cell[0][0] = health\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0 and new_health > max_health_at_cell[nx][ny]:\n                        max_health_at_cell[nx][ny] = new_health\n                        queue.append((nx, ny, new_health))\n        \n        return False"
    ],
    "all_solutions": [
      "class Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        from collections import deque\n        \n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        visited = set((0, 0))\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, new_health))\n        \n        return False",
      "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        min_health_needed = [[float('inf')] * n for _ in range(m)]\n        min_health_needed[0][0] = health\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0 and new_health > min_health_needed[nx][ny]:\n                        min_health_needed[nx][ny] = new_health\n                        queue.append((nx, ny, new_health))\n        \n        return False",
      "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        max_health_at_cell = [[0] * n for _ in range(m)]\n        max_health_at_cell[0][0] = health\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0 and new_health > max_health_at_cell[nx][ny]:\n                        max_health_at_cell[nx][ny] = new_health\n                        queue.append((nx, ny, new_health))\n        \n        return False",
      "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        visited = set((0, 0))\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, new_health))\n        \n        return False",
      "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        visited = [[False] * n for _ in range(m)]\n        visited[0][0] = True\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0:\n                        visited[nx][ny] = True\n                        queue.append((nx, ny, new_health))\n        \n        return False"
    ],
    "total_candidates": 5,
    "nodes_explored": 5,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        from collections import deque\n        \n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque([(0, 0, health)])\n        visited = set((0, 0))\n        \n        while queue:\n            x, y, h = queue.popleft()\n            \n            if x == m - 1 and y == n - 1 and h >= 1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    new_health = h - grid[nx][ny]\n                    if new_health > 0:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, new_health))\n        \n        return False",
        "solution_hash": "a70f9a4e753b865e61d8e6f8ccb44df9becb156579aa21c29e0cc08d8a0f8302",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp9p0u9k2p.py\", line 193, in <module>\n    check(Solution().findSafeWalk)\n  File \"/scratch/local/21926554/tmp9p0u9k2p.py\", line 144, in check\n    assert candidate(grid = [[0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1]],health = 5) == True\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp9p0u9k2p.py` failed. (See above for error)\n",
          "execution_time": 13.901297092437744,
          "failed_tests": [
            {
              "input": "grid = [[0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1]],health = 5",
              "expected": "True",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp9p0u9k2p.py\", line 193, in <module>\n    check(Solution().findSafeWalk)\n  File \"/scratch/local/21926554/tmp9p0u9k2p.py\", line 144, in check\n    assert candidate(grid = [[0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1]],health = 5) == True\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp9p0u9k2p.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_1"
        ],
        "passed": false
      }
    ],
    "stats": {
      "nodes_explored": 5,
      "candidates_generated": 5,
      "tests_passed": 1,
      "tests_failed": 4,
      "test_errors": 0,
      "execution_times": [
        13.901297092437744,
        13.885106563568115,
        14.024058103561401,
        13.687062978744507,
        13.597915887832642
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 1,
        "iteration_limit": 1
      },
      "solution_diversity": {
        "unique_solutions": 5,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 852,
          "max": 970,
          "avg": 910.2
        }
      },
      "test_case_analysis": {
        "hardest_cases": {
          "grid = [[0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1]],health = 5": 3,
          "grid = [[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0]],health = 1": 1
        },
        "first_failing_tests": {
          "grid = [[0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1]],health = 5": 3,
          "grid = [[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0]],health = 1": 1
        }
      },
      "feedback_impact": {
        "depths": {
          "1": {
            "attempts": 3,
            "improvements": 0,
            "solved": 0
          },
          "2": {
            "attempts": 3,
            "improvements": 0,
            "solved": 1
          }
        },
        "error_types": {
          "assertion_failure": {
            "attempts": 2,
            "improvements": 1
          }
        },
        "test_case_improvements": {},
        "error_transitions": {
          "assertion_failure->assertion_failure": 3,
          "assertion_failure->unknown": 1
        }
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 2,
          "avg_depth": 1.4,
          "solutions_per_depth": {
            "0": 1,
            "1": 1,
            "2": 3
          },
          "passing_solutions_per_depth": {
            "0": 0,
            "1": 0,
            "2": 1
          }
        },
        "pass_at_k": {
          "pass@1": 0.16666666666666663,
          "pass@3": 0.5,
          "pass@5": 0.8333333333333334
        },
        "solutions_evaluated": 6,
        "passing_solution_depths": {
          "min": 2,
          "max": 2,
          "avg": 2.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 0.2,
          "branch_success_rate": 0.2
        },
        "error_recovery": {
          "total_attempts": 2,
          "total_improvements": 1,
          "recovery_rate": 0.5
        },
        "top_errors": [
          [
            "assertion_failure",
            2
          ]
        ],
        "hardest_test_cases": [
          [
            "grid = [[0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1]],health = 5",
            3
          ],
          [
            "grid = [[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0]],health = 1",
            1
          ]
        ],
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 1,
          "iteration_limit": 1
        }
      }
    },
    "processing_time": 253.83003163337708,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.16666666666666663,
        "pass@3": 0.5,
        "pass@5": 0.8333333333333334
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: name 'pairwise' is not defined",
              "completion_id": 5
            }
          ]
        ]
      },
      "solutions_evaluated": 6,
      "test_cases": 1
    }
  },
  {
    "problem_id": "maximum-multiplication-score",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        n = len(b)\n        dp1, dp2, dp3, dp4 = [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n\n        \n        for i in range(n):\n            dp1[i] = max(dp1[i-1], a[0] * b[i])\n            if i > 0:\n                dp2[i] = max(dp2[i-1], dp1[i-1] + a[1] * b[i])\n            if i > 1:\n                dp3[i] = max(dp3[i-1], dp2[i-1] + a[2] * b[i])\n            if i > 2:\n                dp4[i] = max(dp4[i-1], dp3[i-1] + a[3] * b[i])\n        \n        return dp4[-1]",
    "passed_solutions": [
      "class Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        n = len(b)\n        dp1, dp2, dp3, dp4 = [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n\n        \n        for i in range(n):\n            dp1[i] = max(dp1[i-1], a[0] * b[i])\n            if i > 0:\n                dp2[i] = max(dp2[i-1], dp1[i-1] + a[1] * b[i])\n            if i > 1:\n                dp3[i] = max(dp3[i-1], dp2[i-1] + a[2] * b[i])\n            if i > 2:\n                dp4[i] = max(dp4[i-1], dp3[i-1] + a[3] * b[i])\n        \n        return dp4[-1]"
    ],
    "all_solutions": [
      "class Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        n = len(b)\n        dp1, dp2, dp3, dp4 = [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n\n        \n        for i in range(n):\n            dp1[i] = max(dp1[i-1], a[0] * b[i])\n            if i > 0:\n                dp2[i] = max(dp2[i-1], dp1[i-1] + a[1] * b[i])\n            if i > 1:\n                dp3[i] = max(dp3[i-1], dp2[i-1] + a[2] * b[i])\n            if i > 2:\n                dp4[i] = max(dp4[i-1], dp3[i-1] + a[3] * b[i])\n        \n        return dp4[-1]"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        n = len(b)\n        dp1, dp2, dp3, dp4 = [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n, [float('-inf')] * n\n        \n        for i in range(n):\n            dp1[i] = max(dp1[i-1], a[0] * b[i])\n            if i > 0:\n                dp2[i] = max(dp2[i-1], dp1[i-1] + a[1] * b[i])\n            if i > 1:\n                dp3[i] = max(dp3[i-1], dp2[i-1] + a[2] * b[i])\n            if i > 2:\n                dp4[i] = max(dp4[i-1], dp3[i-1] + a[3] * b[i])\n        \n        return dp4[-1]",
        "solution_hash": "5351318691de3a006f09d5130fc9d3995add16c7b14b16e13adf81528dd5f361",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.868942737579346,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.868942737579346
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 576,
          "max": 576,
          "avg": 576.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 64.78982520103455,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "minimum-number-of-valid-strings-to-form-target-i",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "unsolved",
    "best_solution": "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                for j in range(1, min(len(word), i) + 1):\n                    if target[i - j:i] == word[:j]:\n                        dp[i] = min(dp[i], dp[i - j] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1",
    "passed_solutions": [
      "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                for j in range(1, min(len(word), i) + 1):\n                    if target[i - j:i] == word[:j]:\n                        dp[i] = min(dp[i], dp[i - j] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1",
      "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                for j in range(1, min(len(word), i) + 1):\n                    if target[i - j:i] == word[:j]:\n                        dp[i] = min(dp[i], dp[i - j] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1"
    ],
    "all_solutions": [
      "class Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                m = len(word)\n                if m > i:\n                    continue\n                if target[i - m:i] == word[:m]:\n                    dp[i] = min(dp[i], dp[i - m] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1",
      "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                for j in range(1, min(len(word), n - i + 1) + 1):\n                    if target[i - j:i] == word[:j]:\n                        dp[i] = min(dp[i], dp[i - j] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1",
      "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                for j in range(1, min(len(word), i) + 1):\n                    if target[i - j:i] == word[:j]:\n                        dp[i] = min(dp[i], dp[i - j] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1",
      "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                for j in range(min(len(word), n - i + 1)):\n                    if target[i - j - 1:i] == word[:j + 1]:\n                        dp[i] = min(dp[i], dp[i - j - 1] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1",
      "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                for j in range(1, min(len(word), i) + 1):\n                    if target[i - j:i] == word[:j]:\n                        dp[i] = min(dp[i], dp[i - j] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1"
    ],
    "total_candidates": 5,
    "nodes_explored": 5,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        n = len(target)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in words:\n                m = len(word)\n                if m > i:\n                    continue\n                if target[i - m:i] == word[:m]:\n                    dp[i] = min(dp[i], dp[i - m] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1",
        "solution_hash": "e9bbb9cbbd5caca54657908405b964ed915217839bde359ec500881b7cab6c82",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmph3exxcz6.py\", line 252, in <module>\n    check(Solution().minValidStrings)\n  File \"/scratch/local/21926554/tmph3exxcz6.py\", line 104, in check\n    assert candidate(words = ['abababab', 'ab'],target = \"ababaababa\") == 2\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmph3exxcz6.py` failed. (See above for error)\n",
          "execution_time": 13.923770666122437,
          "failed_tests": [
            {
              "input": "words = ['abababab', 'ab'],target = \"ababaababa\"",
              "expected": "2",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmph3exxcz6.py\", line 252, in <module>\n    check(Solution().minValidStrings)\n  File \"/scratch/local/21926554/tmph3exxcz6.py\", line 104, in check\n    assert candidate(words = ['abababab', 'ab'],target = \"ababaababa\") == 2\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmph3exxcz6.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_1"
        ],
        "passed": false
      }
    ],
    "stats": {
      "nodes_explored": 5,
      "candidates_generated": 5,
      "tests_passed": 2,
      "tests_failed": 3,
      "test_errors": 0,
      "execution_times": [
        13.923770666122437,
        13.896016836166382,
        13.616324663162231,
        13.605070114135742,
        13.616324663162231
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 1,
        "iteration_limit": 1
      },
      "solution_diversity": {
        "unique_solutions": 4,
        "unique_ratio": 0.8,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 488,
          "max": 507,
          "avg": 497.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {
          "words = ['abababab', 'ab'],target = \"ababaababa\"": 1,
          "words = ['abc'],target = \"abcabc\"": 2
        },
        "first_failing_tests": {
          "words = ['abababab', 'ab'],target = \"ababaababa\"": 1,
          "words = ['abc'],target = \"abcabc\"": 2
        }
      },
      "feedback_impact": {
        "depths": {
          "1": {
            "attempts": 3,
            "improvements": 0,
            "solved": 0
          },
          "2": {
            "attempts": 3,
            "improvements": 0,
            "solved": 2
          }
        },
        "error_types": {
          "assertion_failure": {
            "attempts": 2,
            "improvements": 2
          }
        },
        "test_case_improvements": {},
        "error_transitions": {
          "assertion_failure->assertion_failure": 2,
          "assertion_failure->unknown": 2
        }
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 2,
          "avg_depth": 1.4,
          "solutions_per_depth": {
            "0": 1,
            "1": 1,
            "2": 3
          },
          "passing_solutions_per_depth": {
            "0": 0,
            "1": 0,
            "2": 2
          }
        },
        "pass_at_k": {
          "pass@1": 0.4999999999999999,
          "pass@3": 0.95,
          "pass@5": 1.0
        },
        "solutions_evaluated": 6,
        "passing_solution_depths": {
          "min": 2,
          "max": 2,
          "avg": 2.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 0.4,
          "branch_success_rate": 0.4
        },
        "error_recovery": {
          "total_attempts": 2,
          "total_improvements": 2,
          "recovery_rate": 1.0
        },
        "top_errors": [
          [
            "assertion_failure",
            2
          ]
        ],
        "hardest_test_cases": [
          [
            "words = ['abc'],target = \"abcabc\"",
            2
          ],
          [
            "words = ['abababab', 'ab'],target = \"ababaababa\"",
            1
          ]
        ],
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 1,
          "iteration_limit": 1
        }
      }
    },
    "processing_time": 217.98148012161255,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.4999999999999999,
        "pass@3": 0.95,
        "pass@5": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 5
            }
          ]
        ]
      },
      "solutions_evaluated": 6,
      "test_cases": 1
    }
  },
  {
    "problem_id": "report-spam-message",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        banned_set = set(bannedWords)\n        count = 0\n        for word in message:\n            if word in banned_set:\n                count += 1\n                if count >= 2:\n                    return True\n        return False",
    "passed_solutions": [
      "class Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        banned_set = set(bannedWords)\n        count = 0\n        for word in message:\n            if word in banned_set:\n                count += 1\n                if count >= 2:\n                    return True\n        return False"
    ],
    "all_solutions": [
      "class Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        banned_set = set(bannedWords)\n        count = 0\n        for word in message:\n            if word in banned_set:\n                count += 1\n                if count >= 2:\n                    return True\n        return False"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        banned_set = set(bannedWords)\n        count = 0\n        for word in message:\n            if word in banned_set:\n                count += 1\n                if count >= 2:\n                    return True\n        return False",
        "solution_hash": "f0310aaecbcc04f3e663f2a7baac1547a56d9e2f09e6f146e6356551b9ec1a09",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.624414205551147,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.624414205551147
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 324,
          "max": 324,
          "avg": 324.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 45.199711322784424,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "minimum-number-of-seconds-to-make-mountain-height-zero",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "unsolved",
    "best_solution": null,
    "passed_solutions": [],
    "all_solutions": [
      "class Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = max_time // time\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                # Solve for k in the equation: time * (1 + k) * k // 2 <= max_time\n                # This is equivalent to finding the largest k such that k * (k + 1) <= 2 * max_time / time\n                k = int((-1 + math.sqrt(1 + 8 * max_time // time)) / 2)\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Adjusted binary search bounds\n        left, right = 0, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height -= k\n                if total_height <= 0:\n                    return True\n            return False\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height -= k\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        left, right = 0, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height -= k\n            return total_height <= 0\n        \n        left, right = 0, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                # Solve for the maximum k such that time * (1 + 2 + ... + k) <= max_time\n                # Sum of first k natural numbers is k * (k + 1) / 2\n                # So, we need to solve time * k * (k + 1) / 2 <= max_time\n                # Rearranging gives k^2 + k - (2 * max_time / time) <= 0\n                # Using quadratic formula to solve for k: k = (-1 + sqrt(1 + 8 * max_time / time)) / 2\n                if time == 0:\n                    continue\n                k = (-1 + math.sqrt(1 + 8 * max_time / time)) / 2\n                k = int(k)\n                total_height -= k\n                if total_height <= 0:\n                    return True\n            return False\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum x such that time * (1 + x) * x // 2 <= max_time\n                # This is equivalent to solving the quadratic equation: time * x^2 + time * x - 2 * max_time <= 0\n                # Using the quadratic formula: x = (-b + sqrt(b^2 - 4ac)) / (2a)\n                a = time\n                b = time\n                c = -2 * max_time\n                discriminant = b**2 - 4*a*c\n                if discriminant < 0:\n                    x = 0\n                else:\n                    x = (-b + math.sqrt(discriminant)) / (2*a)\n                x = int(x)  # x must be an integer\n                # Sum of arithmetic series: time * (1 + x) * x // 2\n                reduction = time * x * (x + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum x such that time * (1 + x) * x // 2 <= max_time\n                # This is equivalent to solving the quadratic equation: time * x^2 + time * x - 2 * max_time <= 0\n                # Using the quadratic formula: x = (-b + sqrt(b^2 - 4ac)) / (2a)\n                a = time\n                b = time\n                c = -2 * max_time\n                discriminant = b**2 - 4*a*c\n                if discriminant < 0:\n                    x = 0\n                else:\n                    x = (-b + math.sqrt(discriminant)) / (2*a)\n                x = int(x)  # x must be an integer\n                # Sum of arithmetic series: time * (1 + x) * x // 2\n                reduction = time * x * (x + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        # Adjusting the initial range for binary search\n        left, right = 0, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Find the maximum x such that the total time taken does not exceed max_time\n                x = 0\n                current_time = 0\n                while current_time + time * (x + 1) <= max_time:\n                    x += 1\n                    current_time += time * x\n                # Sum of arithmetic series: time * (1 + x) * x // 2\n                reduction = time * x * (x + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum x such that time * (1 + x) * x // 2 <= max_time\n                x = 0\n                while time * (x + 1) * (x + 2) // 2 <= max_time:\n                    x += 1\n                # Sum of arithmetic series: time * (1 + x) * x // 2\n                reduction = time * x * (x + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "class Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = max_time // time\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Determine the maximum height reduction possible for this worker within max_time\n                k = 0\n                cumulative_time = 0\n                while cumulative_time + time * (k + 1) <= max_time:\n                    k += 1\n                    cumulative_time += time * k\n                total_height -= k\n                if total_height <= 0:\n                    return True\n            return False\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Sort worker times in ascending order\n        workerTimes.sort()\n        \n        # Initialize the total time required\n        total_time = 0\n        \n        # Calculate the maximum time taken by any worker\n        for i in range(len(workerTimes)):\n            # The i-th worker will handle the (i+1)-th largest reduction\n            # We need to find the maximum height reduction this worker can handle\n            # Let k be the number of units this worker reduces the height\n            # The time taken by this worker is workerTimes[i] * (1 + 2 + ... + k) = workerTimes[i] * k * (k + 1) / 2\n            # We need to find the maximum k such that the total reduction does not exceed mountainHeight\n            # We can use the formula for the sum of the first k natural numbers\n            # workerTimes[i] * k * (k + 1) / 2 <= remaining_height\n            remaining_height = mountainHeight - (len(workerTimes) - i - 1)\n            if remaining_height <= 0:\n                break\n            \n            # Solve for k using the quadratic formula\n            a = workerTimes[i] / 2\n            b = workerTimes[i] / 2\n            c = -remaining_height\n            discriminant = b**2 - 4*a*c\n            k = (-b + math.sqrt(discriminant)) / (2*a)\n            k = int(k)\n            \n            # Update the total time required\n            total_time = max(total_time, workerTimes[i] * k * (k + 1) // 2)\n        \n        return total_time",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Sort worker times in ascending order\n        workerTimes.sort()\n        \n        # Initialize the result to store the maximum time taken by any worker\n        result = 0\n        \n        # Assign the largest possible reductions to the fastest workers\n        for i in range(len(workerTimes)):\n            # Calculate the maximum height reduction possible for this worker\n            max_reduction = (mountainHeight + i) // (i + 1)\n            # Calculate the time taken by this worker to achieve the reduction\n            time_taken = workerTimes[i] * (1 + max_reduction) * max_reduction // 2\n            # Update the result with the maximum time taken by any worker\n            result = max(result, time_taken)\n            # Reduce the mountain height by the amount reduced by this worker\n            mountainHeight -= max_reduction\n        \n        return result",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Sort worker times in ascending order\n        workerTimes.sort()\n        \n        # Initialize the total time required\n        total_time = 0\n        \n        # Assign the largest possible reductions to the fastest workers\n        while mountainHeight > 0:\n            # Calculate the number of workers that can still work\n            num_workers = len(workerTimes)\n            \n            # Calculate the maximum height reduction possible with the current workers\n            max_reduction = mountainHeight // num_workers\n            \n            # If no reduction is possible, assign the remaining height to the fastest worker\n            if max_reduction == 0:\n                max_reduction = 1\n            \n            # Calculate the time taken by the fastest worker to reduce the height by max_reduction\n            time_taken = workerTimes[-1] * (1 + max_reduction) * max_reduction // 2\n            \n            # Update the total time required\n            total_time = max(total_time, time_taken)\n            \n            # Reduce the mountain height\n            mountainHeight -= max_reduction\n            \n            # Remove the fastest worker as they have completed their task\n            workerTimes.pop()\n        \n        return total_time",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                # We need to find the maximum x such that time * (1 + x) * x // 2 <= max_time\n                k = int((2 * max_time / time) ** 0.5)\n                while time * k * (k + 1) // 2 > max_time:\n                    k -= 1\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                while (k + 1) * time <= max_time:\n                    k += 1\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum k such that the sum of the series does not exceed max_time\n                k = 0\n                while (k + 1) * time * (k + 2) // 2 <= max_time:\n                    k += 1\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = 0\n                while (k + 1) * time <= max_time:\n                    k += 1\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum x such that the sum of the series does not exceed max_time\n                # The sum of the series is time * (1 + 2 + ... + x) = time * x * (x + 1) / 2\n                # We solve for x in the inequality: time * x * (x + 1) / 2 <= max_time\n                # This simplifies to x^2 + x - (2 * max_time / time) <= 0\n                # Using the quadratic formula: x = (-1 + sqrt(1 + 8 * max_time / time)) / 2\n                if time == 0:\n                    continue\n                x = int((-1 + (1 + 8 * max_time // time) ** 0.5) / 2)\n                # Sum of arithmetic series: time * x * (x + 1) // 2\n                reduction = time * x * (x + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    break\n            return total_height <= 0\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "class Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                k = max_time // time\n                total_height_reduced += k * (k + 1) // 2\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height_reduced += k\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        workerTimes.sort()\n        n = len(workerTimes)\n        left, right = 1, mountainHeight * workerTimes[-1]\n        \n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for i in range(n):\n                time = workerTimes[i]\n                # Calculate the maximum height this worker can reduce within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height_reduced += k\n            return total_height_reduced >= mountainHeight\n        \n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height_reduced += k\n            return total_height_reduced >= mountainHeight\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport heapq\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Create a max heap based on the worker times (negative for max heap behavior)\n        max_heap = [-time for time in workerTimes]\n        heapq.heapify(max_heap)\n        \n        # Total height to be reduced\n        remaining_height = mountainHeight\n        seconds = 0\n        \n        while remaining_height > 0:\n            # Get the fastest worker (smallest negative value)\n            fastest_worker_time = -heapq.heappop(max_heap)\n            \n            # Calculate how much height this worker can reduce in the next second\n            height_reduction = 1\n            while remaining_height > 0 and height_reduction * fastest_worker_time <= remaining_height:\n                remaining_height -= height_reduction * fastest_worker_time\n                seconds += fastest_worker_time\n                height_reduction += 1\n            \n            # Push the worker back into the heap with updated time\n            if height_reduction > 1:\n                heapq.heappush(max_heap, -(fastest_worker_time * height_reduction))\n        \n        return seconds",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height_reduced += k\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height_reduced += k\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport heapq\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Priority queue to store the time taken by workers to reduce height\n        pq = []\n        for time in workerTimes:\n            heapq.heappush(pq, (time, 1))  # (current_time, height_reduced)\n        \n        total_height_reduced = 0\n        max_time = 0\n        \n        while total_height_reduced < mountainHeight:\n            current_time, height_reduced = heapq.heappop(pq)\n            max_time = max(max_time, current_time)\n            total_height_reduced += 1\n            \n            # Push the next state of the worker into the priority queue\n            next_time = current_time + workerTimes[height_reduced - 1] * (height_reduced + 1)\n            heapq.heappush(pq, (next_time, height_reduced + 1))\n        \n        return max_time",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                k = 0\n                current_time = 0\n                while current_time + time * (k + 1) <= max_time:\n                    k += 1\n                    current_time += time * k\n                total_height_reduced += k\n            return total_height_reduced >= mountainHeight\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                height = 0\n                current_time = 0\n                increment = time\n                while current_time + increment <= max_time:\n                    height += 1\n                    current_time += increment\n                    increment += time\n                total_height_reduced += height\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                # Using the formula for the sum of an arithmetic series: n/2 * (2a + (n-1)d)\n                # Here, a = time, d = time, and we need to find n such that sum <= max_time\n                n = (math.sqrt(1 + 8 * max_time // time) - 1) / 2\n                n = int(n)\n                total_height_reduced += n\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\nimport math\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def time_to_reduce(height, time):\n            # Sum of arithmetic series: time * (1 + 2 + ... + height) = time * height * (height + 1) / 2\n            return time * height * (height + 1) // 2\n        \n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                max_height = 0\n                while time_to_reduce(max_height + 1, time) <= max_time:\n                    max_height += 1\n                total_height_reduced += max_height\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
      "from typing import List\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                height = 0\n                current_time = 0\n                increment = time\n                while current_time + increment <= max_time:\n                    height += 1\n                    current_time += increment\n                    increment += time\n                total_height_reduced += height\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        # Sort worker times to assign larger reductions to faster workers\n        workerTimes.sort()\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
    ],
    "total_candidates": 39,
    "nodes_explored": 39,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = max_time // time\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        left, right = 0, mountainHeight * max(workerTimes) * 2\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
        "solution_hash": "3084a2b6234c0c47cffaec1f3c4fb82d4c77548a79ac279b956677b7b2ba7b62",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpzt61l7j0.py\", line 226, in <module>\n    check(Solution().minNumberOfSeconds)\n  File \"/scratch/local/21926554/tmpzt61l7j0.py\", line 106, in check\n    assert candidate(mountainHeight = 15,workerTimes = [5, 5, 5]) == 75\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpzt61l7j0.py` failed. (See above for error)\n",
          "execution_time": 13.60651707649231,
          "failed_tests": [
            {
              "input": "mountainHeight = 15,workerTimes = [5, 5, 5]",
              "expected": "75",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpzt61l7j0.py\", line 226, in <module>\n    check(Solution().minNumberOfSeconds)\n  File \"/scratch/local/21926554/tmpzt61l7j0.py\", line 106, in check\n    assert candidate(mountainHeight = 15,workerTimes = [5, 5, 5]) == 75\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpzt61l7j0.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_1",
          "1_5",
          "1_9"
        ],
        "passed": false
      },
      {
        "node_id": "0_1",
        "solution": "class Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height = mountainHeight\n            for time in workerTimes:\n                # Calculate the maximum height reduction possible for this worker within max_time\n                k = max_time // time\n                # Sum of arithmetic series: time * (1 + k) * k // 2\n                reduction = time * k * (k + 1) // 2\n                total_height -= reduction\n                if total_height <= 0:\n                    return True\n            return False\n        \n        # Binary search for the minimum time\n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
        "solution_hash": "88e92ab8da1cd330c7454e7ef7a974e477d73abc5a79e8078edb84d09f73bddd",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpv129a2fb.py\", line 227, in <module>\n    check(Solution().minNumberOfSeconds)\n  File \"/scratch/local/21926554/tmpv129a2fb.py\", line 107, in check\n    assert candidate(mountainHeight = 15,workerTimes = [5, 5, 5]) == 75\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpv129a2fb.py` failed. (See above for error)\n",
          "execution_time": 13.611422061920166,
          "failed_tests": [
            {
              "input": "mountainHeight = 15,workerTimes = [5, 5, 5]",
              "expected": "75",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmpv129a2fb.py\", line 227, in <module>\n    check(Solution().minNumberOfSeconds)\n  File \"/scratch/local/21926554/tmpv129a2fb.py\", line 107, in check\n    assert candidate(mountainHeight = 15,workerTimes = [5, 5, 5]) == 75\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmpv129a2fb.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_14",
          "1_18",
          "1_22"
        ],
        "passed": false
      },
      {
        "node_id": "0_2",
        "solution": "class Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def can_reduce_in_time(max_time):\n            total_height_reduced = 0\n            for time in workerTimes:\n                # Calculate the maximum height this worker can reduce within max_time\n                k = max_time // time\n                total_height_reduced += k * (k + 1) // 2\n                if total_height_reduced >= mountainHeight:\n                    return True\n            return False\n        \n        left, right = 1, mountainHeight * max(workerTimes)\n        while left < right:\n            mid = (left + right) // 2\n            if can_reduce_in_time(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
        "solution_hash": "f33d3ec2ea826fc81b01def69bc1e39aab457a8948a197b34e663e6962607c32",
        "test_result": {
          "status": "fail",
          "stdout": "",
          "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp27svbg2j.py\", line 224, in <module>\n    check(Solution().minNumberOfSeconds)\n  File \"/scratch/local/21926554/tmp27svbg2j.py\", line 104, in check\n    assert candidate(mountainHeight = 15,workerTimes = [5, 5, 5]) == 75\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp27svbg2j.py` failed. (See above for error)\n",
          "execution_time": 13.576062440872192,
          "failed_tests": [
            {
              "input": "mountainHeight = 15,workerTimes = [5, 5, 5]",
              "expected": "75",
              "actual": "unknown"
            }
          ],
          "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926554/tmp27svbg2j.py\", line 224, in <module>\n    check(Solution().minNumberOfSeconds)\n  File \"/scratch/local/21926554/tmp27svbg2j.py\", line 104, in check\n    assert candidate(mountainHeight = 15,workerTimes = [5, 5, 5]) == 75\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926554/tmp27svbg2j.py` failed. (See above for error)"
        },
        "depth": 0,
        "parent_id": null,
        "children": [
          "1_27",
          "1_31",
          "1_35"
        ],
        "passed": false
      }
    ],
    "stats": {
      "nodes_explored": 39,
      "candidates_generated": 39,
      "tests_passed": 0,
      "tests_failed": 39,
      "test_errors": 0,
      "execution_times": [
        13.60651707649231,
        13.596283197402954,
        13.596283197402954,
        13.55174708366394,
        13.597290277481079,
        13.601014614105225,
        13.573788166046143,
        13.60713505744934,
        13.611870765686035,
        13.604016304016113,
        13.590160608291626,
        13.583567380905151,
        13.612957239151001,
        13.611422061920166,
        13.60070013999939,
        13.60265302658081,
        13.600879430770874,
        13.606991291046143,
        13.590739488601685,
        13.590739488601685,
        13.606339693069458,
        13.590739488601685,
        13.581259727478027,
        13.565244197845459,
        13.581259727478027,
        13.567568063735962,
        13.576062440872192,
        13.583736896514893,
        13.569490194320679,
        13.575472593307495,
        13.558457851409912,
        13.583736896514893,
        13.583736896514893,
        13.585573434829712,
        13.575472593307495,
        13.567862033843994,
        13.56052303314209,
        13.597274541854858,
        13.596640348434448
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      },
      "solution_diversity": {
        "unique_solutions": 32,
        "unique_ratio": 0.8205128205128205,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 784,
          "max": 1588,
          "avg": 1078.2564102564102
        }
      },
      "test_case_analysis": {
        "hardest_cases": {
          "mountainHeight = 15,workerTimes = [5, 5, 5]": 23,
          "mountainHeight = 100,workerTimes = [10, 10, 10, 10]": 2,
          "mountainHeight = 30,workerTimes = [3, 3, 3]": 13,
          "mountainHeight = 15,workerTimes = [1, 2, 3]": 1
        },
        "first_failing_tests": {
          "mountainHeight = 15,workerTimes = [5, 5, 5]": 23,
          "mountainHeight = 100,workerTimes = [10, 10, 10, 10]": 2,
          "mountainHeight = 30,workerTimes = [3, 3, 3]": 13,
          "mountainHeight = 15,workerTimes = [1, 2, 3]": 1
        }
      },
      "feedback_impact": {
        "depths": {
          "1": {
            "attempts": 9,
            "improvements": 0,
            "solved": 0
          },
          "2": {
            "attempts": 27,
            "improvements": 0,
            "solved": 0
          }
        },
        "error_types": {
          "assertion_failure": {
            "attempts": 12,
            "improvements": 0
          }
        },
        "test_case_improvements": {},
        "error_transitions": {
          "assertion_failure->assertion_failure": 35,
          "assertion_failure->index_error": 1
        }
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 2,
          "avg_depth": 1.6153846153846154,
          "solutions_per_depth": {
            "0": 3,
            "1": 9,
            "2": 27
          },
          "passing_solutions_per_depth": {
            "0": 0,
            "1": 0,
            "2": 0
          }
        },
        "pass_at_k": {
          "pass@1": 0.0,
          "pass@3": 0.0,
          "pass@5": 0.0,
          "pass@10": 0.0
        },
        "solutions_evaluated": 40
      },
      "summary": {
        "efficiency": {
          "solving_rate": 0.0,
          "branch_success_rate": 0.0
        },
        "error_recovery": {
          "total_attempts": 12,
          "total_improvements": 0,
          "recovery_rate": 0.0
        },
        "top_errors": [
          [
            "assertion_failure",
            12
          ]
        ],
        "hardest_test_cases": [
          [
            "mountainHeight = 15,workerTimes = [5, 5, 5]",
            23
          ],
          [
            "mountainHeight = 30,workerTimes = [3, 3, 3]",
            13
          ],
          [
            "mountainHeight = 100,workerTimes = [10, 10, 10, 10]",
            2
          ],
          [
            "mountainHeight = 15,workerTimes = [1, 2, 3]",
            1
          ]
        ],
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 1
        }
      }
    },
    "processing_time": 1323.2811532020569,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.0,
        "pass@3": 0.0,
        "pass@5": 0.0,
        "pass@10": 0.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 5
            }
          ],
          [
            6,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 6
            }
          ],
          [
            7,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 7
            }
          ],
          [
            8,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 8
            }
          ],
          [
            9,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 9
            }
          ],
          [
            10,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 10
            }
          ],
          [
            11,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 11
            }
          ],
          [
            12,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 12
            }
          ],
          [
            13,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 13
            }
          ],
          [
            14,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 14
            }
          ],
          [
            15,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 15
            }
          ],
          [
            16,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 16
            }
          ],
          [
            17,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 17
            }
          ],
          [
            18,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 18
            }
          ],
          [
            19,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 19
            }
          ],
          [
            20,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 20
            }
          ],
          [
            21,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 21
            }
          ],
          [
            22,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 22
            }
          ],
          [
            23,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 23
            }
          ],
          [
            24,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 24
            }
          ],
          [
            25,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 25
            }
          ],
          [
            26,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 26
            }
          ],
          [
            27,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 27
            }
          ],
          [
            28,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 28
            }
          ],
          [
            29,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 29
            }
          ],
          [
            30,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 30
            }
          ],
          [
            31,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 31
            }
          ],
          [
            32,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 32
            }
          ],
          [
            33,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: list index out of range",
              "completion_id": 33
            }
          ],
          [
            34,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 34
            }
          ],
          [
            35,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 35
            }
          ],
          [
            36,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 36
            }
          ],
          [
            37,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 37
            }
          ],
          [
            38,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 38
            }
          ],
          [
            39,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: 'key' is an invalid keyword argument for bisect_left()",
              "completion_id": 39
            }
          ]
        ]
      },
      "solutions_evaluated": 40,
      "test_cases": 1
    }
  },
  {
    "problem_id": "count-substrings-that-can-be-rearranged-to-contain-a-string-i",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        from collections import Counter\n        \n        # Count the frequency of each character in word2\n        word2_count = Counter(word2)\n        required_chars = len(word2_count)\n        formed_chars = 0\n        \n        # Initialize the sliding window\n        left = 0\n        right = 0\n        window_count = Counter()\n        valid_substrings = 0\n        n = len(word1)\n        \n        while right < n:\n            # Add the current character to the window\n            char = word1[right]\n            window_count[char] += 1\n            \n            # Check if the current character's frequency matches the required frequency in word2\n            if char in word2_count and window_count[char] == word2_count[char]:\n                formed_chars += 1\n            \n            # Try to contract the window until it ceases to be 'desirable'\n            while left <= right and formed_chars == required_chars:\n                # Every substring starting from left to right is valid\n                valid_substrings += n - right\n                \n                # Remove the leftmost character\n                char = word1[left]\n                window_count[char] -= 1\n                if char in word2_count and window_count[char] < word2_count[char]:\n                    formed_chars -= 1\n                left += 1\n            \n            # Keep expanding the window\n            right += 1\n        \n        return valid_substrings",
    "passed_solutions": [
      "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        from collections import Counter\n        \n        # Count the frequency of each character in word2\n        word2_count = Counter(word2)\n        required_chars = len(word2_count)\n        formed_chars = 0\n        \n        # Initialize the sliding window\n        left = 0\n        right = 0\n        window_count = Counter()\n        valid_substrings = 0\n        n = len(word1)\n        \n        while right < n:\n            # Add the current character to the window\n            char = word1[right]\n            window_count[char] += 1\n            \n            # Check if the current character's frequency matches the required frequency in word2\n            if char in word2_count and window_count[char] == word2_count[char]:\n                formed_chars += 1\n            \n            # Try to contract the window until it ceases to be 'desirable'\n            while left <= right and formed_chars == required_chars:\n                # Every substring starting from left to right is valid\n                valid_substrings += n - right\n                \n                # Remove the leftmost character\n                char = word1[left]\n                window_count[char] -= 1\n                if char in word2_count and window_count[char] < word2_count[char]:\n                    formed_chars -= 1\n                left += 1\n            \n            # Keep expanding the window\n            right += 1\n        \n        return valid_substrings"
    ],
    "all_solutions": [
      "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        from collections import Counter\n        \n        # Count the frequency of each character in word2\n        word2_count = Counter(word2)\n        required_chars = len(word2_count)\n        formed_chars = 0\n        \n        # Initialize the sliding window\n        left = 0\n        right = 0\n        window_count = Counter()\n        valid_substrings = 0\n        n = len(word1)\n        \n        while right < n:\n            # Add the current character to the window\n            char = word1[right]\n            window_count[char] += 1\n            \n            # Check if the current character's frequency matches the required frequency in word2\n            if char in word2_count and window_count[char] == word2_count[char]:\n                formed_chars += 1\n            \n            # Try to contract the window until it ceases to be 'desirable'\n            while left <= right and formed_chars == required_chars:\n                # Every substring starting from left to right is valid\n                valid_substrings += n - right\n                \n                # Remove the leftmost character\n                char = word1[left]\n                window_count[char] -= 1\n                if char in word2_count and window_count[char] < word2_count[char]:\n                    formed_chars -= 1\n                left += 1\n            \n            # Keep expanding the window\n            right += 1\n        \n        return valid_substrings"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        from collections import Counter\n        \n        # Count the frequency of each character in word2\n        word2_count = Counter(word2)\n        required_chars = len(word2_count)\n        formed_chars = 0\n        \n        # Initialize the sliding window\n        left = 0\n        right = 0\n        window_count = Counter()\n        valid_substrings = 0\n        n = len(word1)\n        \n        while right < n:\n            # Add the current character to the window\n            char = word1[right]\n            window_count[char] += 1\n            \n            # Check if the current character's frequency matches the required frequency in word2\n            if char in word2_count and window_count[char] == word2_count[char]:\n                formed_chars += 1\n            \n            # Try to contract the window until it ceases to be 'desirable'\n            while left <= right and formed_chars == required_chars:\n                # Every substring starting from left to right is valid\n                valid_substrings += n - right\n                \n                # Remove the leftmost character\n                char = word1[left]\n                window_count[char] -= 1\n                if char in word2_count and window_count[char] < word2_count[char]:\n                    formed_chars -= 1\n                left += 1\n            \n            # Keep expanding the window\n            right += 1\n        \n        return valid_substrings",
        "solution_hash": "d43ba753f78cd48adb4e450812eb134abecd1189651a99b31dcd7735509e396f",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.572667837142944,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.572667837142944
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 1517,
          "max": 1517,
          "avg": 1517.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 75.01795506477356,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  },
  {
    "problem_id": "maximize-the-total-height-of-unique-towers",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        # Sort the maximum heights in descending order\n        maximumHeight.sort(reverse=True)\n        \n        # Set to keep track of used heights\n        used_heights = set()\n        total_sum = 0\n        \n        for max_height in maximumHeight:\n            # Find the largest possible unique height for the current tower\n            while max_height in used_heights:\n                max_height -= 1\n            \n            # If we can't find a valid height, return -1\n            if max_height <= 0:\n                return -1\n            \n            # Assign the height and add to the total sum\n            used_heights.add(max_height)\n            total_sum += max_height\n        \n        return total_sum",
    "passed_solutions": [
      "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        # Sort the maximum heights in descending order\n        maximumHeight.sort(reverse=True)\n        \n        # Set to keep track of used heights\n        used_heights = set()\n        total_sum = 0\n        \n        for max_height in maximumHeight:\n            # Find the largest possible unique height for the current tower\n            while max_height in used_heights:\n                max_height -= 1\n            \n            # If we can't find a valid height, return -1\n            if max_height <= 0:\n                return -1\n            \n            # Assign the height and add to the total sum\n            used_heights.add(max_height)\n            total_sum += max_height\n        \n        return total_sum"
    ],
    "all_solutions": [
      "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        # Sort the maximum heights in descending order\n        maximumHeight.sort(reverse=True)\n        \n        # Set to keep track of used heights\n        used_heights = set()\n        total_sum = 0\n        \n        for max_height in maximumHeight:\n            # Find the largest possible unique height for the current tower\n            while max_height in used_heights:\n                max_height -= 1\n            \n            # If we can't find a valid height, return -1\n            if max_height <= 0:\n                return -1\n            \n            # Assign the height and add to the total sum\n            used_heights.add(max_height)\n            total_sum += max_height\n        \n        return total_sum"
    ],
    "total_candidates": 1,
    "nodes_explored": 1,
    "tree_depth": 0,
    "solution_tree": [
      {
        "node_id": "0_0",
        "solution": "class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        # Sort the maximum heights in descending order\n        maximumHeight.sort(reverse=True)\n        \n        # Set to keep track of used heights\n        used_heights = set()\n        total_sum = 0\n        \n        for max_height in maximumHeight:\n            # Find the largest possible unique height for the current tower\n            while max_height in used_heights:\n                max_height -= 1\n            \n            # If we can't find a valid height, return -1\n            if max_height <= 0:\n                return -1\n            \n            # Assign the height and add to the total sum\n            used_heights.add(max_height)\n            total_sum += max_height\n        \n        return total_sum",
        "solution_hash": "d4e807d941547a5172a71089f2ec631f634983026581cee56e4260518bf8fc67",
        "test_result": {
          "status": "pass",
          "stdout": "",
          "stderr": "",
          "execution_time": 13.57224440574646,
          "failed_tests": [],
          "error_message": ""
        },
        "depth": 0,
        "parent_id": null,
        "children": [],
        "passed": true
      }
    ],
    "stats": {
      "nodes_explored": 1,
      "candidates_generated": 1,
      "tests_passed": 1,
      "tests_failed": 0,
      "test_errors": 0,
      "execution_times": [
        13.57224440574646
      ],
      "tree_depth": 0,
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 0
      },
      "solution_diversity": {
        "unique_solutions": 1,
        "unique_ratio": 1.0,
        "similarity_score": 0.0,
        "solution_lengths": {
          "min": 792,
          "max": 792,
          "avg": 792.0
        }
      },
      "test_case_analysis": {
        "hardest_cases": {},
        "first_failing_tests": {}
      },
      "code_eval_metrics": {
        "depth_statistics": {
          "min_depth": 0,
          "max_depth": 0,
          "avg_depth": 0.0,
          "solutions_per_depth": {
            "0": 1
          },
          "passing_solutions_per_depth": {
            "0": 1
          }
        },
        "pass_at_k": {
          "pass@1": 1.0
        },
        "solutions_evaluated": 2,
        "passing_solution_depths": {
          "min": 0,
          "max": 0,
          "avg": 0.0
        }
      },
      "summary": {
        "efficiency": {
          "solving_rate": 1.0,
          "branch_success_rate": 1.0
        },
        "termination_reasons": {
          "depth_limit": 0,
          "adaptive_threshold": 0,
          "import_failures": 0,
          "early_stopping": 0,
          "iteration_limit": 0
        }
      }
    },
    "processing_time": 56.97526431083679,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ]
        ]
      },
      "solutions_evaluated": 2,
      "test_cases": 1
    }
  }
]