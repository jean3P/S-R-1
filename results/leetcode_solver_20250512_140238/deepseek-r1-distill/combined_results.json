[
  {
    "problem_id": "shortest-distance-after-road-addition-queries-i",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        for u, v in queries:\n            adj[u].append(v)\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
    "passed_solutions": [
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        for u, v in queries:\n            adj[u].append(v)\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        # Precompute initial distances\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Check if the new edge can improve the distance\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                # Update all nodes reachable from v\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        for u, v in queries:\n            adj[u].append(v)\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result"
    ],
    "all_solutions": [
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the adjacency list with the initial roads\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Perform BFS to find the shortest path from 0 to n-1\n            dist = [inf] * n\n            dist[0] = 0\n            q = deque([0])\n            while q:\n                current = q.popleft()\n                if current == n-1:\n                    break\n                for neighbor in adj[current]:\n                    if dist[neighbor] > dist[current] + 1:\n                        dist[neighbor] = dist[current] + 1\n                        q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the adjacency list with the initial roads\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Perform BFS to find the shortest path from 0 to n-1\n            dist = [inf] * n\n            dist[0] = 0\n            q = deque([0])\n            while q:\n                current = q.popleft()\n                if current == n-1:\n                    break\n                for neighbor in adj[current]:\n                    if dist[neighbor] > dist[current] + 1:\n                        dist[neighbor] = dist[current] + 1\n                        q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the adjacency list with the initial roads\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Perform BFS from 0 to find the shortest path to n-1\n            dist = [inf] * n\n            dist[0] = 0\n            q = deque([0])\n            while q:\n                current = q.popleft()\n                if current == n-1:\n                    break\n                for neighbor in adj[current]:\n                    if dist[neighbor] > dist[current] + 1:\n                        dist[neighbor] = dist[current] + 1\n                        q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        for u, v in queries:\n            adj[u].append(v)\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        # Precompute initial distances\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Check if the new edge can improve the distance\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                # Update all nodes reachable from v\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Precompute distances from 0\n        forward = [float('inf')] * n\n        forward[0] = 0\n        q = deque([0])\n        while q:\n            u = q.popleft()\n            if u == n-1:\n                break\n            if u + 1 < n:\n                if forward[u+1] > forward[u] + 1:\n                    forward[u+1] = forward[u] + 1\n                    q.append(u+1)\n        \n        # Precompute distances to n-1\n        backward = [float('inf')] * n\n        backward[n-1] = 0\n        q = deque([n-1])\n        while q:\n            u = q.popleft()\n            if u == 0:\n                break\n            if u - 1 >= 0:\n                if backward[u-1] > backward[u] + 1:\n                    backward[u-1] = backward[u] + 1\n                    q.append(u-1)\n        \n        result = []\n        current_min = forward[n-1]\n        result.append(current_min)\n        for u, v in queries:\n            # Check if adding this edge provides a shorter path\n            if forward[u] + 1 + backward[v] < current_min:\n                current_min = forward[u] + 1 + backward[v]\n            result.append(current_min)\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Precompute forward distances from 0\n        forward = [float('inf')] * n\n        forward[0] = 0\n        q = deque([0])\n        while q:\n            u = q.popleft()\n            if u == n-1:\n                break\n            if u + 1 < n and forward[u+1] > forward[u] + 1:\n                forward[u+1] = forward[u] + 1\n                q.append(u+1)\n        \n        # Precompute backward distances to n-1\n        backward = [float('inf')] * n\n        backward[n-1] = 0\n        q = deque([n-1])\n        while q:\n            u = q.popleft()\n            if u == 0:\n                break\n            if u - 1 >= 0 and backward[u-1] > backward[u] + 1:\n                backward[u-1] = backward[u] + 1\n                q.append(u-1)\n        \n        result = []\n        current_min = forward[n-1]\n        result.append(current_min)\n        \n        for u, v in queries:\n            # Check if the new edge u->v provides a shorter path\n            if forward[u] + 1 + backward[v] < current_min:\n                current_min = forward[u] + 1 + backward[v]\n            result.append(current_min)\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        for u, v in queries:\n            adj[u].append(v)\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
      "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Precompute forward distances from 0\n        forward = [float('inf')] * n\n        forward[0] = 0\n        q = deque([0])\n        while q:\n            u = q.popleft()\n            if u == n-1:\n                break\n            if u + 1 < n and forward[u+1] > forward[u] + 1:\n                forward[u+1] = forward[u] + 1\n                q.append(u+1)\n        \n        # Precompute backward distances to n-1\n        backward = [float('inf')] * n\n        backward[n-1] = 0\n        q = deque([n-1])\n        while q:\n            u = q.popleft()\n            if u == 0:\n                break\n            if u - 1 >= 0 and backward[u-1] > backward[u] + 1:\n                backward[u-1] = backward[u] + 1\n                q.append(u-1)\n        \n        result = []\n        current_min = forward[n-1]\n        result.append(current_min)\n        \n        for u, v in queries:\n            # Check if the new edge u->v provides a shorter path\n            if forward[u] + 1 + backward[v] < current_min:\n                current_min = forward[u] + 1 + backward[v]\n            result.append(current_min)\n        \n        return result"
    ],
    "total_candidates": 9,
    "rounds": 3,
    "reflection_logs": [
      {
        "round": 1,
        "phase": "Initial Generation",
        "candidates": [
          {
            "candidate_id": "1_1",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the adjacency list with the initial roads\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Perform BFS to find the shortest path from 0 to n-1\n            dist = [inf] * n\n            dist[0] = 0\n            q = deque([0])\n            while q:\n                current = q.popleft()\n                if current == n-1:\n                    break\n                for neighbor in adj[current]:\n                    if dist[neighbor] > dist[current] + 1:\n                        dist[neighbor] = dist[current] + 1\n                        q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
            "solution_hash": "2bd781e6987ffbb97d8d49e0b49804c3f6e79522c66fc1b3713c0f5efdace0d0",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06367039680480957
            },
            "passed": true
          },
          {
            "candidate_id": "1_2",
            "solution": "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the adjacency list with the initial roads\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Perform BFS to find the shortest path from 0 to n-1\n            dist = [inf] * n\n            dist[0] = 0\n            q = deque([0])\n            while q:\n                current = q.popleft()\n                if current == n-1:\n                    break\n                for neighbor in adj[current]:\n                    if dist[neighbor] > dist[current] + 1:\n                        dist[neighbor] = dist[current] + 1\n                        q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
            "solution_hash": "ae818ec867d15eec78b80f088c00d6b36d34492b9486eb0de9c53b2f9dc8a35b",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06481766700744629
            },
            "passed": true
          },
          {
            "candidate_id": "1_3",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the adjacency list with the initial roads\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Perform BFS from 0 to find the shortest path to n-1\n            dist = [inf] * n\n            dist[0] = 0\n            q = deque([0])\n            while q:\n                current = q.popleft()\n                if current == n-1:\n                    break\n                for neighbor in adj[current]:\n                    if dist[neighbor] > dist[current] + 1:\n                        dist[neighbor] = dist[current] + 1\n                        q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
            "solution_hash": "2bd781e6987ffbb97d8d49e0b49804c3f6e79522c66fc1b3713c0f5efdace0d0",
            "test_result": {
              "status": "pass",
              "execution_time": 0.0645914077758789
            },
            "passed": true
          }
        ],
        "execution_time": 120.30816268920898
      },
      {
        "round": 2,
        "phase": "Reflection Round 1",
        "candidates": [
          {
            "candidate_id": "2_1",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        for u, v in queries:\n            adj[u].append(v)\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
            "solution_hash": "14977996f8611a22afc539ba90160abeaf6020d8e417e79a202bf2c11e4a1b10",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06344127655029297
            },
            "passed": true
          },
          {
            "candidate_id": "2_2",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        # Precompute initial distances\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        result = []\n        for u, v in queries:\n            adj[u].append(v)\n            # Check if the new edge can improve the distance\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                # Update all nodes reachable from v\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
            "solution_hash": "f858c746f49a26adc43fb82a1706300fce8e3b86c02aa877f0f0bd9200901d83",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06481051445007324
            },
            "passed": true
          },
          {
            "candidate_id": "2_3",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Precompute distances from 0\n        forward = [float('inf')] * n\n        forward[0] = 0\n        q = deque([0])\n        while q:\n            u = q.popleft()\n            if u == n-1:\n                break\n            if u + 1 < n:\n                if forward[u+1] > forward[u] + 1:\n                    forward[u+1] = forward[u] + 1\n                    q.append(u+1)\n        \n        # Precompute distances to n-1\n        backward = [float('inf')] * n\n        backward[n-1] = 0\n        q = deque([n-1])\n        while q:\n            u = q.popleft()\n            if u == 0:\n                break\n            if u - 1 >= 0:\n                if backward[u-1] > backward[u] + 1:\n                    backward[u-1] = backward[u] + 1\n                    q.append(u-1)\n        \n        result = []\n        current_min = forward[n-1]\n        result.append(current_min)\n        for u, v in queries:\n            # Check if adding this edge provides a shorter path\n            if forward[u] + 1 + backward[v] < current_min:\n                current_min = forward[u] + 1 + backward[v]\n            result.append(current_min)\n        \n        return result",
            "solution_hash": "6b840ea09534a255d95f5a604c2e1f004d7dd9b01857268bdfa05128ac7a2266",
            "test_result": {
              "status": "fail",
              "error_message": "Test execution failed with return code 1",
              "stdout": "",
              "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21285593/tmp38qkgwvp.py\", line 198, in <module>\n    check(Solution().shortestDistanceAfterQueries)\n  File \"/scratch/local/21285593/tmp38qkgwvp.py\", line 124, in check\n    assert candidate(n = 7,queries = [[0, 5], [1, 6], [2, 4]]) == [2, 2, 2]\nAssertionError\n",
              "execution_time": 0.06465291976928711
            },
            "passed": false
          }
        ],
        "execution_time": 151.48742055892944
      },
      {
        "round": 3,
        "phase": "Reflection Round 2",
        "candidates": [
          {
            "candidate_id": "3_1",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Precompute forward distances from 0\n        forward = [float('inf')] * n\n        forward[0] = 0\n        q = deque([0])\n        while q:\n            u = q.popleft()\n            if u == n-1:\n                break\n            if u + 1 < n and forward[u+1] > forward[u] + 1:\n                forward[u+1] = forward[u] + 1\n                q.append(u+1)\n        \n        # Precompute backward distances to n-1\n        backward = [float('inf')] * n\n        backward[n-1] = 0\n        q = deque([n-1])\n        while q:\n            u = q.popleft()\n            if u == 0:\n                break\n            if u - 1 >= 0 and backward[u-1] > backward[u] + 1:\n                backward[u-1] = backward[u] + 1\n                q.append(u-1)\n        \n        result = []\n        current_min = forward[n-1]\n        result.append(current_min)\n        \n        for u, v in queries:\n            # Check if the new edge u->v provides a shorter path\n            if forward[u] + 1 + backward[v] < current_min:\n                current_min = forward[u] + 1 + backward[v]\n            result.append(current_min)\n        \n        return result",
            "solution_hash": "2d13c5f92467597c00cdbecfd17eeb452d0ab0794d609962dd6d519b10afd842",
            "test_result": {
              "status": "fail",
              "error_message": "Test execution failed with return code 1",
              "stdout": "",
              "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21285593/tmpqdmc17a9.py\", line 197, in <module>\n    check(Solution().shortestDistanceAfterQueries)\n  File \"/scratch/local/21285593/tmpqdmc17a9.py\", line 123, in check\n    assert candidate(n = 7,queries = [[0, 5], [1, 6], [2, 4]]) == [2, 2, 2]\nAssertionError\n",
              "execution_time": 0.06259679794311523
            },
            "passed": false
          },
          {
            "candidate_id": "3_2",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        adj = [[] for _ in range(n)]\n        for i in range(n-1):\n            adj[i].append(i+1)\n        \n        result = []\n        dist = [float('inf')] * n\n        dist[0] = 0\n        q = deque([0])\n        while q:\n            current = q.popleft()\n            for neighbor in adj[current]:\n                if dist[neighbor] > dist[current] + 1:\n                    dist[neighbor] = dist[current] + 1\n                    q.append(neighbor)\n        \n        for u, v in queries:\n            adj[u].append(v)\n            if dist[u] + 1 < dist[v]:\n                dist[v] = dist[u] + 1\n                q = deque([v])\n                while q:\n                    current = q.popleft()\n                    for neighbor in adj[current]:\n                        if dist[neighbor] > dist[current] + 1:\n                            dist[neighbor] = dist[current] + 1\n                            q.append(neighbor)\n            result.append(dist[n-1])\n        \n        return result",
            "solution_hash": "14977996f8611a22afc539ba90160abeaf6020d8e417e79a202bf2c11e4a1b10",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06344127655029297
            },
            "passed": true
          },
          {
            "candidate_id": "3_3",
            "solution": "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Precompute forward distances from 0\n        forward = [float('inf')] * n\n        forward[0] = 0\n        q = deque([0])\n        while q:\n            u = q.popleft()\n            if u == n-1:\n                break\n            if u + 1 < n and forward[u+1] > forward[u] + 1:\n                forward[u+1] = forward[u] + 1\n                q.append(u+1)\n        \n        # Precompute backward distances to n-1\n        backward = [float('inf')] * n\n        backward[n-1] = 0\n        q = deque([n-1])\n        while q:\n            u = q.popleft()\n            if u == 0:\n                break\n            if u - 1 >= 0 and backward[u-1] > backward[u] + 1:\n                backward[u-1] = backward[u] + 1\n                q.append(u-1)\n        \n        result = []\n        current_min = forward[n-1]\n        result.append(current_min)\n        \n        for u, v in queries:\n            # Check if the new edge u->v provides a shorter path\n            if forward[u] + 1 + backward[v] < current_min:\n                current_min = forward[u] + 1 + backward[v]\n            result.append(current_min)\n        \n        return result",
            "solution_hash": "2d13c5f92467597c00cdbecfd17eeb452d0ab0794d609962dd6d519b10afd842",
            "test_result": {
              "status": "fail",
              "error_message": "Test execution failed with return code 1",
              "stdout": "",
              "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21285593/tmpqdmc17a9.py\", line 197, in <module>\n    check(Solution().shortestDistanceAfterQueries)\n  File \"/scratch/local/21285593/tmpqdmc17a9.py\", line 123, in check\n    assert candidate(n = 7,queries = [[0, 5], [1, 6], [2, 4]]) == [2, 2, 2]\nAssertionError\n",
              "execution_time": 0.06259679794311523
            },
            "passed": false
          }
        ],
        "execution_time": 69.22699403762817
      }
    ],
    "stats": {
      "rounds_completed": 3,
      "candidates_generated": 9,
      "tests_passed": 6,
      "tests_failed": 3,
      "test_errors": 0,
      "execution_times": []
    },
    "processing_time": 343.1990010738373,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.7,
        "pass@3": 0.9916666666666667,
        "pass@5": 1.0,
        "pass@10": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 5
            }
          ],
          [
            6,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 6
            }
          ],
          [
            7,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 7
            }
          ],
          [
            8,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 8
            }
          ],
          [
            9,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 9
            }
          ]
        ]
      },
      "solutions_evaluated": 10,
      "test_cases": 1
    },
    "code_eval_round_results": {
      "round_evaluations": [
        {
          "round": 1,
          "solutions_count": 3,
          "pass_at_k": {
            "pass@1": 1.0,
            "pass@3": 1.0
          },
          "error": null
        },
        {
          "round": 2,
          "solutions_count": 6,
          "pass_at_k": {
            "pass@1": 0.8333333333333333,
            "pass@3": 1.0,
            "pass@5": 1.0
          },
          "error": null
        },
        {
          "round": 3,
          "solutions_count": 9,
          "pass_at_k": {
            "pass@1": 0.6666666666666665,
            "pass@3": 0.9880952380952381,
            "pass@5": 1.0
          },
          "error": null
        }
      ],
      "final_pass_at_k": {
        "pass@1": 0.6666666666666665,
        "pass@3": 0.9880952380952381,
        "pass@5": 1.0
      }
    }
  }
]