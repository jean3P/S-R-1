[
  {
    "problem_id": "shortest-distance-after-road-addition-queries-i",
    "problem_title": "",
    "difficulty": "Medium",
    "status": "solved",
    "best_solution": "from collections import defaultdict, deque\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(start: int) -> List[int]:\n            distances = [float('inf')] * n\n            distances[start] = 0\n            priority_queue = [(0, start)]\n            \n            while priority_queue:\n                current_distance, current_city = heapq.heappop(priority_queue)\n                \n                if current_distance > distances[current_city]:\n                    continue\n                \n                for neighbor in graph[current_city]:\n                    distance = current_distance + 1\n                    \n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        heapq.heappush(priority_queue, (distance, neighbor))\n            \n            return distances\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        distances = dijkstra(0)\n        result = []\n        \n        for u, v in queries:\n            graph[u].append(v)\n            if distances[v] > distances[u] + 1:\n                distances[v] = distances[u] + 1\n                # Update distances for affected nodes\n                priority_queue = [(distances[v], v)]\n                while priority_queue:\n                    current_distance, current_city = heapq.heappop(priority_queue)\n                    \n                    if current_distance > distances[current_city]:\n                        continue\n                    \n                    for neighbor in graph[current_city]:\n                        distance = current_distance + 1\n                        \n                        if distance < distances[neighbor]:\n                            distances[neighbor] = distance\n                            heapq.heappush(priority_queue, (distance, neighbor))\n            \n            result.append(distances[n - 1])\n        \n        return result",
    "passed_solutions": [
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
      "from collections import defaultdict, deque\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(start: int) -> List[int]:\n            distances = [float('inf')] * n\n            distances[start] = 0\n            priority_queue = [(0, start)]\n            \n            while priority_queue:\n                current_distance, current_city = heapq.heappop(priority_queue)\n                \n                if current_distance > distances[current_city]:\n                    continue\n                \n                for neighbor in graph[current_city]:\n                    distance = current_distance + 1\n                    \n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        heapq.heappush(priority_queue, (distance, neighbor))\n            \n            return distances\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        distances = dijkstra(0)\n        result = []\n        \n        for u, v in queries:\n            graph[u].append(v)\n            if distances[v] > distances[u] + 1:\n                distances[v] = distances[u] + 1\n                # Update distances for affected nodes\n                priority_queue = [(distances[v], v)]\n                while priority_queue:\n                    current_distance, current_city = heapq.heappop(priority_queue)\n                    \n                    if current_distance > distances[current_city]:\n                        continue\n                    \n                    for neighbor in graph[current_city]:\n                        distance = current_distance + 1\n                        \n                        if distance < distances[neighbor]:\n                            distances[neighbor] = distance\n                            heapq.heappush(priority_queue, (distance, neighbor))\n            \n            result.append(distances[n - 1])\n        \n        return result",
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result"
    ],
    "all_solutions": [
      "from collections import defaultdict, deque\nfrom typing import List\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def bfs() -> int:\n            queue = deque([(0, 0)])  # (current_city, distance)\n            visited = set([0])\n            while queue:\n                current_city, distance = queue.popleft()\n                if current_city == n - 1:\n                    return distance\n                for neighbor in graph[current_city]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, distance + 1))\n            return inf\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(bfs())\n        \n        return result",
      "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        from heapq import heappop, heappush\n        \n        def dijkstra(graph, start, end):\n            distances = [float('inf')] * n\n            distances[start] = 0\n            priority_queue = [(0, start)]\n            \n            while priority_queue:\n                current_distance, current_node = heappop(priority_queue)\n                \n                if current_distance > distances[current_node]:\n                    continue\n                \n                for neighbor, weight in graph[current_node]:\n                    distance = current_distance + weight\n                    \n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        heappush(priority_queue, (distance, neighbor))\n            \n            return distances[end]\n        \n        # Initialize the graph with initial edges\n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append((i + 1, 1))\n        \n        results = []\n        for u, v in queries:\n            graph[u].append((v, 1))  # Add the new road\n            shortest_path_length = dijkstra(graph, 0, n - 1)\n            results.append(shortest_path_length)\n        \n        return results",
      "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        from collections import defaultdict, deque\n        \n        # Initialize the graph with the default roads\n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        def bfs():\n            queue = deque([(0, 0)])  # (current_city, distance)\n            visited = set([0])\n            while queue:\n                current, dist = queue.popleft()\n                if current == n - 1:\n                    return dist\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, dist + 1))\n            return inf  # If no path found\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(bfs())\n        \n        return result",
      "from collections import defaultdict, deque\nfrom typing import List\nimport math\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(start: int) -> List[int]:\n            distances = [math.inf] * n\n            distances[start] = 0\n            queue = deque([(0, start)])\n            while queue:\n                dist, current = queue.popleft()\n                if dist > distances[current]:\n                    continue\n                for neighbor in graph[current]:\n                    new_dist = dist + 1\n                    if new_dist < distances[neighbor]:\n                        distances[neighbor] = new_dist\n                        queue.append((new_dist, neighbor))\n            return distances\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        distances = dijkstra(0)\n        result = []\n        \n        for u, v in queries:\n            graph[u].append(v)\n            if distances[v] + 1 < distances[n - 1]:\n                queue = deque([(distances[v] + 1, v)])\n                while queue:\n                    dist, current = queue.popleft()\n                    if dist >= distances[current]:\n                        continue\n                    distances[current] = dist\n                    if current == n - 1:\n                        break\n                    for neighbor in graph[current]:\n                        new_dist = dist + 1\n                        if new_dist < distances[neighbor]:\n                            distances[neighbor] = new_dist\n                            queue.append((new_dist, neighbor))\n            \n            result.append(distances[n - 1] if distances[n - 1] != math.inf else -1)\n        \n        return result",
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
      "from collections import defaultdict, deque\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(start: int) -> List[int]:\n            distances = [float('inf')] * n\n            distances[start] = 0\n            priority_queue = [(0, start)]\n            \n            while priority_queue:\n                current_distance, current_city = heapq.heappop(priority_queue)\n                \n                if current_distance > distances[current_city]:\n                    continue\n                \n                for neighbor in graph[current_city]:\n                    distance = current_distance + 1\n                    \n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        heapq.heappush(priority_queue, (distance, neighbor))\n            \n            return distances\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        distances = dijkstra(0)\n        result = []\n        \n        for u, v in queries:\n            graph[u].append(v)\n            if distances[v] > distances[u] + 1:\n                distances[v] = distances[u] + 1\n                # Update distances for affected nodes\n                priority_queue = [(distances[v], v)]\n                while priority_queue:\n                    current_distance, current_city = heapq.heappop(priority_queue)\n                    \n                    if current_distance > distances[current_city]:\n                        continue\n                    \n                    for neighbor in graph[current_city]:\n                        distance = current_distance + 1\n                        \n                        if distance < distances[neighbor]:\n                            distances[neighbor] = distance\n                            heapq.heappush(priority_queue, (distance, neighbor))\n            \n            result.append(distances[n - 1])\n        \n        return result",
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
      "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result"
    ],
    "total_candidates": 9,
    "rounds": 3,
    "reflection_logs": [
      {
        "round": 1,
        "phase": "Initial Generation",
        "candidates": [
          {
            "candidate_id": "1_1",
            "solution": "from collections import defaultdict, deque\nfrom typing import List\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def bfs() -> int:\n            queue = deque([(0, 0)])  # (current_city, distance)\n            visited = set([0])\n            while queue:\n                current_city, distance = queue.popleft()\n                if current_city == n - 1:\n                    return distance\n                for neighbor in graph[current_city]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, distance + 1))\n            return inf\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(bfs())\n        \n        return result",
            "solution_hash": "52a52bb9c2c8b9370ba2347cdaeccae35155a48cd01a75791ee9dbfbb6f34707",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06696939468383789
            },
            "passed": true
          },
          {
            "candidate_id": "1_2",
            "solution": "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        from heapq import heappop, heappush\n        \n        def dijkstra(graph, start, end):\n            distances = [float('inf')] * n\n            distances[start] = 0\n            priority_queue = [(0, start)]\n            \n            while priority_queue:\n                current_distance, current_node = heappop(priority_queue)\n                \n                if current_distance > distances[current_node]:\n                    continue\n                \n                for neighbor, weight in graph[current_node]:\n                    distance = current_distance + weight\n                    \n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        heappush(priority_queue, (distance, neighbor))\n            \n            return distances[end]\n        \n        # Initialize the graph with initial edges\n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append((i + 1, 1))\n        \n        results = []\n        for u, v in queries:\n            graph[u].append((v, 1))  # Add the new road\n            shortest_path_length = dijkstra(graph, 0, n - 1)\n            results.append(shortest_path_length)\n        \n        return results",
            "solution_hash": "b418d01f12694aaa14f928f1d8a5ad43a17e31605d7679f962ce912bbeee6ef5",
            "test_result": {
              "status": "pass",
              "execution_time": 0.07334065437316895
            },
            "passed": true
          },
          {
            "candidate_id": "1_3",
            "solution": "class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        from collections import defaultdict, deque\n        \n        # Initialize the graph with the default roads\n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        def bfs():\n            queue = deque([(0, 0)])  # (current_city, distance)\n            visited = set([0])\n            while queue:\n                current, dist = queue.popleft()\n                if current == n - 1:\n                    return dist\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, dist + 1))\n            return inf  # If no path found\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(bfs())\n        \n        return result",
            "solution_hash": "893cc158a4915c7451f20cb73704295350179dcfbeec8d2177269fe9e76a7e4a",
            "test_result": {
              "status": "pass",
              "execution_time": 0.07031416893005371
            },
            "passed": true
          }
        ],
        "execution_time": 115.62681245803833
      },
      {
        "round": 2,
        "phase": "Reflection Round 1",
        "candidates": [
          {
            "candidate_id": "2_1",
            "solution": "from collections import defaultdict, deque\nfrom typing import List\nimport math\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(start: int) -> List[int]:\n            distances = [math.inf] * n\n            distances[start] = 0\n            queue = deque([(0, start)])\n            while queue:\n                dist, current = queue.popleft()\n                if dist > distances[current]:\n                    continue\n                for neighbor in graph[current]:\n                    new_dist = dist + 1\n                    if new_dist < distances[neighbor]:\n                        distances[neighbor] = new_dist\n                        queue.append((new_dist, neighbor))\n            return distances\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        distances = dijkstra(0)\n        result = []\n        \n        for u, v in queries:\n            graph[u].append(v)\n            if distances[v] + 1 < distances[n - 1]:\n                queue = deque([(distances[v] + 1, v)])\n                while queue:\n                    dist, current = queue.popleft()\n                    if dist >= distances[current]:\n                        continue\n                    distances[current] = dist\n                    if current == n - 1:\n                        break\n                    for neighbor in graph[current]:\n                        new_dist = dist + 1\n                        if new_dist < distances[neighbor]:\n                            distances[neighbor] = new_dist\n                            queue.append((new_dist, neighbor))\n            \n            result.append(distances[n - 1] if distances[n - 1] != math.inf else -1)\n        \n        return result",
            "solution_hash": "7b2162647a56fec5d03c24fdfa609ea08831ba03fd617ea2d260a72a41277d7a",
            "test_result": {
              "status": "fail",
              "error_message": "Test execution failed with return code 1",
              "stdout": "",
              "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21285593/tmpb435t00g.py\", line 206, in <module>\n    check(Solution().shortestDistanceAfterQueries)\n  File \"/scratch/local/21285593/tmpb435t00g.py\", line 132, in check\n    assert candidate(n = 7,queries = [[0, 5], [1, 6], [2, 4]]) == [2, 2, 2]\nAssertionError\n",
              "execution_time": 0.0639944076538086
            },
            "passed": false
          },
          {
            "candidate_id": "2_2",
            "solution": "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
            "solution_hash": "f5ee7dd82c44a6ae42eb7c42897857e575a32d48ef1d431fedc970b17e42a522",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06889772415161133
            },
            "passed": true
          },
          {
            "candidate_id": "2_3",
            "solution": "from collections import defaultdict, deque\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra(start: int) -> List[int]:\n            distances = [float('inf')] * n\n            distances[start] = 0\n            priority_queue = [(0, start)]\n            \n            while priority_queue:\n                current_distance, current_city = heapq.heappop(priority_queue)\n                \n                if current_distance > distances[current_city]:\n                    continue\n                \n                for neighbor in graph[current_city]:\n                    distance = current_distance + 1\n                    \n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        heapq.heappush(priority_queue, (distance, neighbor))\n            \n            return distances\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        distances = dijkstra(0)\n        result = []\n        \n        for u, v in queries:\n            graph[u].append(v)\n            if distances[v] > distances[u] + 1:\n                distances[v] = distances[u] + 1\n                # Update distances for affected nodes\n                priority_queue = [(distances[v], v)]\n                while priority_queue:\n                    current_distance, current_city = heapq.heappop(priority_queue)\n                    \n                    if current_distance > distances[current_city]:\n                        continue\n                    \n                    for neighbor in graph[current_city]:\n                        distance = current_distance + 1\n                        \n                        if distance < distances[neighbor]:\n                            distances[neighbor] = distance\n                            heapq.heappush(priority_queue, (distance, neighbor))\n            \n            result.append(distances[n - 1])\n        \n        return result",
            "solution_hash": "0e6683718d9bd7be0348198e074935cf2e123f5904fedec2015ae0d09ed5b507",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06612157821655273
            },
            "passed": true
          }
        ],
        "execution_time": 65.58873987197876
      },
      {
        "round": 3,
        "phase": "Reflection Round 2",
        "candidates": [
          {
            "candidate_id": "3_1",
            "solution": "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
            "solution_hash": "f5ee7dd82c44a6ae42eb7c42897857e575a32d48ef1d431fedc970b17e42a522",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06889772415161133
            },
            "passed": true
          },
          {
            "candidate_id": "3_2",
            "solution": "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
            "solution_hash": "f5ee7dd82c44a6ae42eb7c42897857e575a32d48ef1d431fedc970b17e42a522",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06889772415161133
            },
            "passed": true
          },
          {
            "candidate_id": "3_3",
            "solution": "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dijkstra():\n            dist = [inf] * n\n            dist[0] = 0\n            heap = [(0, 0)]  # (distance, city)\n            while heap:\n                d, city = heappop(heap)\n                if d > dist[city]:\n                    continue\n                for neighbor in graph[city]:\n                    if dist[neighbor] > dist[city] + 1:\n                        dist[neighbor] = dist[city] + 1\n                        heappush(heap, (dist[neighbor], neighbor))\n            return dist[n - 1]\n        \n        graph = defaultdict(list)\n        for i in range(n - 1):\n            graph[i].append(i + 1)\n        \n        result = []\n        for u, v in queries:\n            graph[u].append(v)\n            result.append(dijkstra())\n        \n        return result",
            "solution_hash": "f5ee7dd82c44a6ae42eb7c42897857e575a32d48ef1d431fedc970b17e42a522",
            "test_result": {
              "status": "pass",
              "execution_time": 0.06889772415161133
            },
            "passed": true
          }
        ],
        "execution_time": 53.19739007949829
      }
    ],
    "stats": {
      "rounds_completed": 3,
      "candidates_generated": 9,
      "tests_passed": 8,
      "tests_failed": 1,
      "test_errors": 0,
      "execution_times": []
    },
    "processing_time": 236.5585765838623,
    "code_eval_results": {
      "pass_at_k": {
        "pass@1": 0.9,
        "pass@3": 1.0,
        "pass@5": 1.0,
        "pass@10": 1.0
      },
      "detailed_results": {
        "0": [
          [
            0,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 0
            }
          ],
          [
            1,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 1
            }
          ],
          [
            2,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 2
            }
          ],
          [
            3,
            {
              "task_id": 0,
              "passed": false,
              "result": "failed: ",
              "completion_id": 3
            }
          ],
          [
            4,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 4
            }
          ],
          [
            5,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 5
            }
          ],
          [
            6,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 6
            }
          ],
          [
            7,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 7
            }
          ],
          [
            8,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 8
            }
          ],
          [
            9,
            {
              "task_id": 0,
              "passed": true,
              "result": "passed",
              "completion_id": 9
            }
          ]
        ]
      },
      "solutions_evaluated": 10,
      "test_cases": 1
    },
    "code_eval_round_results": {
      "round_evaluations": [
        {
          "round": 1,
          "solutions_count": 3,
          "pass_at_k": {
            "pass@1": 1.0,
            "pass@3": 1.0
          },
          "error": null
        },
        {
          "round": 2,
          "solutions_count": 6,
          "pass_at_k": {
            "pass@1": 0.8333333333333333,
            "pass@3": 1.0,
            "pass@5": 1.0
          },
          "error": null
        },
        {
          "round": 3,
          "solutions_count": 9,
          "pass_at_k": {
            "pass@1": 0.8888888888888888,
            "pass@3": 1.0,
            "pass@5": 1.0
          },
          "error": null
        }
      ],
      "final_pass_at_k": {
        "pass@1": 0.8888888888888888,
        "pass@3": 1.0,
        "pass@5": 1.0
      }
    }
  }
]