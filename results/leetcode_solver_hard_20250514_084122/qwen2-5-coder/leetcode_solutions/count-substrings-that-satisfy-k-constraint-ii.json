{
  "problem_id": "count-substrings-that-satisfy-k-constraint-ii",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = start\n            \n            for right in range(start, end + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
  "passed_solutions": [
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = start\n            \n            for right in range(start, end + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = start\n            \n            for right in range(start, end + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l, r, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = l\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l: int, r: int, k: int) -> int:\n            count = 0\n            zero_count = 0\n            one_count = 0\n            start = l\n            \n            for end in range(l, r + 1):\n                if s[end] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[start] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    start += 1\n                \n                count += (end - start + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        def count_valid_substrings(l: int, r: int) -> int:\n            count_zeros = 0\n            count_ones = 0\n            left = l\n            valid_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    count_zeros += 1\n                else:\n                    count_ones += 1\n                \n                while count_zeros > k and count_ones > k:\n                    if s[left] == '0':\n                        count_zeros -= 1\n                    else:\n                        count_ones -= 1\n                    left += 1\n                \n                if count_zeros <= k or count_ones <= k:\n                    valid_count += (right - left + 1)\n            \n            return valid_count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l: int, r: int) -> int:\n            count_zeros = 0\n            count_ones = 0\n            left = l\n            valid_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    count_zeros += 1\n                else:\n                    count_ones += 1\n                \n                while count_zeros > k and count_ones > k:\n                    if s[left] == '0':\n                        count_zeros -= 1\n                    else:\n                        count_ones -= 1\n                    left += 1\n                \n                if count_zeros <= k or count_ones <= k:\n                    valid_count += (right - left + 1)\n            \n            return valid_count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        def count_valid_substrings(s, k, l, r):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = l\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(s, k, l, r))\n        \n        return result"
  ],
  "all_solutions": [
    "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros and at most k ones\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Use inclusion-exclusion principle to avoid double-counting substrings with at most k zeros and k ones\n            count_both = count_valid_substrings(l, r, k, prefix_zeros) + count_valid_substrings(l, r, k, prefix_ones) - count_valid_substrings(l, r, k, prefix_zeros) - count_valid_substrings(l, r, k, prefix_ones) + count_valid_substrings(l, r, k, prefix_zeros)\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
    "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            # Count substrings with at most k ones\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Count substrings with at most k zeros and at most k ones (double-counted)\n            count_both = count_valid_substrings(l, r, k, prefix_zeros) + count_valid_substrings(l, r, k, prefix_ones) - count_valid_substrings(l, r, k, [x + y for x, y in zip(prefix_zeros, prefix_ones)])\n            # Use inclusion-exclusion principle\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
    "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is more than k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1)\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Total number of substrings in s[l:r+1]\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            \n            # Count substrings with more than k zeros\n            invalid_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with more than k ones\n            invalid_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with more than k zeros and more than k ones\n            invalid_both = count_invalid_substrings(l, r, k, [x + y for x, y in zip(prefix_zeros, prefix_ones)])\n            \n            # Valid substrings = Total substrings - Invalid substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
    "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_valid_substrings_combined(start, end, k):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros and ones in s[i:j+1] is at most k each\n                j = start - 1\n                zero_count = prefix_zeros[i] - prefix_zeros[start]\n                one_count = prefix_ones[i] - prefix_ones[start]\n                while j < end:\n                    next_j = bisect_right(prefix_zeros, prefix_zeros[i] + k - zero_count, lo=j + 1, hi=end + 1) - 1\n                    next_j = min(next_j, bisect_right(prefix_ones, prefix_ones[i] + k - one_count, lo=j + 1, hi=end + 1) - 1)\n                    if next_j < start:\n                        break\n                    count += next_j - i + 1\n                    j = next_j\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            # Count substrings with at most k ones\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Count substrings with at most k zeros and at most k ones (double-counted)\n            count_both = count_valid_substrings_combined(l, r, k)\n            # Use inclusion-exclusion principle\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
    "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is more than k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1)\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Total substrings in the range\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            \n            # Count substrings with more than k zeros\n            invalid_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with more than k ones\n            invalid_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with more than k zeros and more than k ones\n            invalid_both = count_invalid_substrings(l, r, k, [x + y for x, y in zip(prefix_zeros, prefix_ones)])\n            \n            # Valid substrings = Total substrings - Invalid substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
    "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is more than k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1)\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros and at most k ones\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Count substrings with more than k zeros and more than k ones\n            count_more_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            count_more_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            # Total substrings in the range\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            # Apply inclusion-exclusion principle\n            count_both_invalid = count_more_zeros + count_more_ones - (total_substrings - count_zeros - count_ones + count_both_invalid)\n            result.append(total_substrings - count_both_invalid)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k, target_char):\n            count = 0\n            left = start\n            current_count = 0\n            \n            for right in range(start, end + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            count_zeros = count_valid_substrings(l, r, k, '0')\n            # Count substrings with at most k ones\n            count_ones = count_valid_substrings(l, r, k, '1')\n            # Use inclusion-exclusion principle to avoid double counting substrings with at most k zeros and k ones\n            count_both = count_valid_substrings(l, r, k, '0') + count_valid_substrings(l, r, k, '1') - count_valid_substrings(l, r, k, '01')\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = start\n            \n            for right in range(start, end + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = start\n            \n            for right in range(start, end + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] exceeds k\n                j = start\n                while j <= end and prefix_sum[j + 1] - prefix_sum[i] <= k:\n                    j += 1\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Total number of substrings in s[l:r+1]\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            \n            # Count substrings with more than k zeros\n            invalid_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with more than k ones\n            invalid_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with more than k zeros and more than k ones\n            invalid_both = count_invalid_substrings(l, r, k, prefix_zeros) + count_invalid_substrings(l, r, k, prefix_ones) - count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Valid substrings = Total substrings - Invalid substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            left = start\n            for right in range(start, end + 1):\n                while left <= right and prefix_sum[right + 1] - prefix_sum[left] > k:\n                    left += 1\n                count += right - left + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            valid_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with at most k ones\n            valid_ones = count_valid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with at most k zeros and at most k ones (total valid substrings)\n            valid_substrings = valid_zeros + valid_ones - count_valid_substrings(l, r, k, prefix_zeros) - count_valid_substrings(l, r, k, prefix_ones) + count_valid_substrings(l, r, k, prefix_zeros)\n            \n            result.append(valid_substrings)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            left = start\n            for right in range(start, end + 1):\n                # Move left pointer to ensure the number of zeros/ones is at most k\n                while prefix_sum[right + 1] - prefix_sum[left] > k:\n                    left += 1\n                count += right - left + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            valid_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with at most k ones\n            valid_ones = count_valid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with at most k zeros and at most k ones (which is the same as valid_zeros or valid_ones)\n            valid_both = count_valid_substrings(l, r, k, prefix_zeros)  # or prefix_ones, since they are the same\n            \n            # Valid substrings = Substrings with at most k zeros + Substrings with at most k ones - Substrings with at most k zeros and at most k ones\n            valid_substrings = valid_zeros + valid_ones - valid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            left = start\n            for right in range(start, end + 1):\n                while left <= right and prefix_sum[right + 1] - prefix_sum[left] > k:\n                    left += 1\n                count += right - left + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            valid_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with at most k ones\n            valid_ones = count_valid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with at most k zeros and at most k ones (total valid substrings)\n            total_valid_substrings = valid_zeros + valid_ones - count_valid_substrings(l, r, k, prefix_zeros) - count_valid_substrings(l, r, k, prefix_ones) + count_valid_substrings(l, r, k, prefix_zeros)\n            \n            result.append(total_valid_substrings)\n        \n        return result",
    "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(prefix, k, l, r):\n            count = 0\n            for i in range(l, r + 1):\n                zeros_or_ones = prefix[r + 1] - prefix[i]\n                if zeros_or_ones <= k:\n                    count += (r - i + 1)\n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(prefix_zeros, k, l, r)\n            count_ones = count_valid_substrings(prefix_ones, k, l, r)\n            count_both = count_valid_substrings(prefix_zeros, k, l, r) + count_valid_substrings(prefix_ones, k, l, r) - count_valid_substrings(prefix_zeros, k, l, r)\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l, r, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = l\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l: int, r: int, k: int) -> int:\n            count = 0\n            zero_count = 0\n            one_count = 0\n            start = l\n            \n            for end in range(l, r + 1):\n                if s[end] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[start] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    start += 1\n                \n                count += (end - start + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        def count_valid_substrings(l: int, r: int) -> int:\n            count_zeros = 0\n            count_ones = 0\n            left = l\n            valid_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    count_zeros += 1\n                else:\n                    count_ones += 1\n                \n                while count_zeros > k and count_ones > k:\n                    if s[left] == '0':\n                        count_zeros -= 1\n                    else:\n                        count_ones -= 1\n                    left += 1\n                \n                if count_zeros <= k or count_ones <= k:\n                    valid_count += (right - left + 1)\n            \n            return valid_count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r))\n        \n        return result",
    "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(prefix, k, l, r):\n            count = 0\n            for i in range(l, r + 1):\n                zeros_or_ones = prefix[r + 1] - prefix[i]\n                if zeros_or_ones <= k:\n                    count += (r - i + 1)\n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(prefix_zeros, k, l, r)\n            count_ones = count_valid_substrings(prefix_ones, k, l, r)\n            total_count = count_zeros + count_ones - (prefix_zeros[r + 1] - prefix_zeros[l]) - (prefix_ones[r + 1] - prefix_ones[l])\n            result.append(total_count)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l: int, r: int) -> int:\n            count_zeros = 0\n            count_ones = 0\n            left = l\n            valid_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    count_zeros += 1\n                else:\n                    count_ones += 1\n                \n                while count_zeros > k and count_ones > k:\n                    if s[left] == '0':\n                        count_zeros -= 1\n                    else:\n                        count_ones -= 1\n                    left += 1\n                \n                if count_zeros <= k or count_ones <= k:\n                    valid_count += (right - left + 1)\n            \n            return valid_count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r))\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(l, r, k, '0')\n            count_ones = count_valid_substrings(l, r, k, '1')\n            total_count = count_zeros + count_ones - (r - l + 1)\n            result.append(total_count)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_invalid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            invalid_zeros = count_invalid_substrings(l, r, k, '0')\n            invalid_ones = count_invalid_substrings(l, r, k, '1')\n            invalid_both = count_invalid_substrings(l, r, k, '0') + count_invalid_substrings(l, r, k, '1') - total_substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            result.append(valid_substrings)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(l, r, k, '0')\n            count_ones = count_valid_substrings(l, r, k, '1')\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            valid_count = count_zeros + count_ones - total_substrings\n            result.append(total_substrings - valid_count)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_invalid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            invalid_zeros = count_invalid_substrings(l, r, k, '0')\n            invalid_ones = count_invalid_substrings(l, r, k, '1')\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones\n            result.append(valid_substrings)\n        \n        return result",
    "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        def count_valid_substrings(s, k, l, r):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = l\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(s, k, l, r))\n        \n        return result"
  ],
  "total_candidates": 24,
  "nodes_explored": 24,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros and at most k ones\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Use inclusion-exclusion principle to avoid double-counting substrings with at most k zeros and k ones\n            count_both = count_valid_substrings(l, r, k, prefix_zeros) + count_valid_substrings(l, r, k, prefix_ones) - count_valid_substrings(l, r, k, prefix_zeros) - count_valid_substrings(l, r, k, prefix_ones) + count_valid_substrings(l, r, k, prefix_zeros)\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
      "solution_hash": "a9d54e333e093a22924e47910bd58adaf7c8bde3ed90e1099fc4c735d029c49f",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp773zw7kl.py\", line 189, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp773zw7kl.py\", line 113, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
        "execution_time": 0.06403589248657227
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_1",
          "solution": "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            # Count substrings with at most k ones\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Count substrings with at most k zeros and at most k ones (double-counted)\n            count_both = count_valid_substrings(l, r, k, prefix_zeros) + count_valid_substrings(l, r, k, prefix_ones) - count_valid_substrings(l, r, k, [x + y for x, y in zip(prefix_zeros, prefix_ones)])\n            # Use inclusion-exclusion principle\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
          "solution_hash": "1a746c0aebdc4fd9155d611e154b935d700b1160467a281c476480812685949b",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpiqnnmtx0.py\", line 194, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpiqnnmtx0.py\", line 118, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
            "execution_time": 0.06257390975952148
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_2",
              "solution": "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is more than k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1)\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Total number of substrings in s[l:r+1]\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            \n            # Count substrings with more than k zeros\n            invalid_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with more than k ones\n            invalid_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with more than k zeros and more than k ones\n            invalid_both = count_invalid_substrings(l, r, k, [x + y for x, y in zip(prefix_zeros, prefix_ones)])\n            \n            # Valid substrings = Total substrings - Invalid substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
              "solution_hash": "ee47335f5d3d3dba86b71ccc59f3dd6376e6e22877fdb603a84d5d2dd2aef786",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpkew2zsyp.py\", line 210, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpkew2zsyp.py\", line 134, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.06277227401733398
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_3",
              "solution": "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_valid_substrings_combined(start, end, k):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros and ones in s[i:j+1] is at most k each\n                j = start - 1\n                zero_count = prefix_zeros[i] - prefix_zeros[start]\n                one_count = prefix_ones[i] - prefix_ones[start]\n                while j < end:\n                    next_j = bisect_right(prefix_zeros, prefix_zeros[i] + k - zero_count, lo=j + 1, hi=end + 1) - 1\n                    next_j = min(next_j, bisect_right(prefix_ones, prefix_ones[i] + k - one_count, lo=j + 1, hi=end + 1) - 1)\n                    if next_j < start:\n                        break\n                    count += next_j - i + 1\n                    j = next_j\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            # Count substrings with at most k ones\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Count substrings with at most k zeros and at most k ones (double-counted)\n            count_both = count_valid_substrings_combined(l, r, k)\n            # Use inclusion-exclusion principle\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
              "solution_hash": "f7632f00e85d7e40b3e6c9244443ad6f3d8bacb79c134755d2c009fb63374f73",
              "test_result": {
                "status": "timeout",
                "error_message": "Test execution timed out after 10 seconds"
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_4",
              "solution": "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is more than k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1)\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Total substrings in the range\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            \n            # Count substrings with more than k zeros\n            invalid_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with more than k ones\n            invalid_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with more than k zeros and more than k ones\n            invalid_both = count_invalid_substrings(l, r, k, [x + y for x, y in zip(prefix_zeros, prefix_ones)])\n            \n            # Valid substrings = Total substrings - Invalid substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
              "solution_hash": "ee47335f5d3d3dba86b71ccc59f3dd6376e6e22877fdb603a84d5d2dd2aef786",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpkew2zsyp.py\", line 210, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpkew2zsyp.py\", line 134, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.06277227401733398
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_5",
          "solution": "from typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is at most k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1) - 1\n                count += j - i + 1\n            return count\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] is more than k\n                j = bisect_right(prefix_sum, prefix_sum[i] + k, lo=i, hi=end + 1)\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros and at most k ones\n            count_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            count_ones = count_valid_substrings(l, r, k, prefix_ones)\n            # Count substrings with more than k zeros and more than k ones\n            count_more_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            count_more_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            # Total substrings in the range\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            # Apply inclusion-exclusion principle\n            count_both_invalid = count_more_zeros + count_more_ones - (total_substrings - count_zeros - count_ones + count_both_invalid)\n            result.append(total_substrings - count_both_invalid)\n        \n        return result",
          "solution_hash": "7cf8c368d72f7c6f396276550ebdfe00cf44d4461801b635ba9fa28cd31cd747",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp072_u_sx.py\", line 205, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp072_u_sx.py\", line 129, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\n  File \"/scratch/local/21419950/tmp072_u_sx.py\", line 122, in countKConstraintSubstrings\n    count_both_invalid = count_more_zeros + count_more_ones - (total_substrings - count_zeros - count_ones + count_both_invalid)\nUnboundLocalError: local variable 'count_both_invalid' referenced before assignment\n",
            "execution_time": 0.06259465217590332
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_6",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k, target_char):\n            count = 0\n            left = start\n            current_count = 0\n            \n            for right in range(start, end + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            count_zeros = count_valid_substrings(l, r, k, '0')\n            # Count substrings with at most k ones\n            count_ones = count_valid_substrings(l, r, k, '1')\n            # Use inclusion-exclusion principle to avoid double counting substrings with at most k zeros and k ones\n            count_both = count_valid_substrings(l, r, k, '0') + count_valid_substrings(l, r, k, '1') - count_valid_substrings(l, r, k, '01')\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
              "solution_hash": "b7207bd5c4f15e76eab7ab536ec23486edaa25bfb39b510ac069f766eb8d637a",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpeqltnwqh.py\", line 195, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpeqltnwqh.py\", line 119, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.06289863586425781
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_7",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = start\n            \n            for right in range(start, end + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
              "solution_hash": "a313be1cfb14fa6c6b2424e7ab4df49aefbedfa7a36ae39f500483324a0e7655",
              "test_result": {
                "status": "pass",
                "execution_time": 0.0631251335144043
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": true
            },
            {
              "node_id": "2_8",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(start, end, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = start\n            \n            for right in range(start, end + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += right - left + 1\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
              "solution_hash": "a313be1cfb14fa6c6b2424e7ab4df49aefbedfa7a36ae39f500483324a0e7655",
              "test_result": {
                "status": "pass",
                "execution_time": 0.0631251335144043
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": true
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_9",
          "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_invalid_substrings(start, end, k, prefix_sum):\n            count = 0\n            for i in range(start, end + 1):\n                # Find the farthest index j such that the number of zeros/ones in s[i:j+1] exceeds k\n                j = start\n                while j <= end and prefix_sum[j + 1] - prefix_sum[i] <= k:\n                    j += 1\n                count += end - j + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Total number of substrings in s[l:r+1]\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            \n            # Count substrings with more than k zeros\n            invalid_zeros = count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with more than k ones\n            invalid_ones = count_invalid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with more than k zeros and more than k ones\n            invalid_both = count_invalid_substrings(l, r, k, prefix_zeros) + count_invalid_substrings(l, r, k, prefix_ones) - count_invalid_substrings(l, r, k, prefix_zeros)\n            \n            # Valid substrings = Total substrings - Invalid substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
          "solution_hash": "e25f2983cc4b560bfcee4e4321e87cc18a8943c9e6f3cb9edb68c7338c67b441",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpuyfasp5s.py\", line 203, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpuyfasp5s.py\", line 127, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
            "execution_time": 0.0651392936706543
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_10",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            left = start\n            for right in range(start, end + 1):\n                while left <= right and prefix_sum[right + 1] - prefix_sum[left] > k:\n                    left += 1\n                count += right - left + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            valid_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with at most k ones\n            valid_ones = count_valid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with at most k zeros and at most k ones (total valid substrings)\n            valid_substrings = valid_zeros + valid_ones - count_valid_substrings(l, r, k, prefix_zeros) - count_valid_substrings(l, r, k, prefix_ones) + count_valid_substrings(l, r, k, prefix_zeros)\n            \n            result.append(valid_substrings)\n        \n        return result",
              "solution_hash": "50ca0a8857ee8785877ca5302c8da8bcd002bd58ec1d8e412deda9661fcc2238",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp9xt9p_mi.py\", line 196, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp9xt9p_mi.py\", line 120, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.062464237213134766
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_11",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            left = start\n            for right in range(start, end + 1):\n                # Move left pointer to ensure the number of zeros/ones is at most k\n                while prefix_sum[right + 1] - prefix_sum[left] > k:\n                    left += 1\n                count += right - left + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            valid_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with at most k ones\n            valid_ones = count_valid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with at most k zeros and at most k ones (which is the same as valid_zeros or valid_ones)\n            valid_both = count_valid_substrings(l, r, k, prefix_zeros)  # or prefix_ones, since they are the same\n            \n            # Valid substrings = Substrings with at most k zeros + Substrings with at most k ones - Substrings with at most k zeros and at most k ones\n            valid_substrings = valid_zeros + valid_ones - valid_both\n            \n            result.append(valid_substrings)\n        \n        return result",
              "solution_hash": "4f53f16238b250a8dbe31d03ba5515cca492ee625aae428f20e35d1eb4aacbe1",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpt9up1rqo.py\", line 200, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpt9up1rqo.py\", line 124, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.061493873596191406
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_12",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        # Compute prefix sums for zeros and ones\n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(start, end, k, prefix_sum):\n            count = 0\n            left = start\n            for right in range(start, end + 1):\n                while left <= right and prefix_sum[right + 1] - prefix_sum[left] > k:\n                    left += 1\n                count += right - left + 1\n            return count\n        \n        result = []\n        for l, r in queries:\n            # Count substrings with at most k zeros\n            valid_zeros = count_valid_substrings(l, r, k, prefix_zeros)\n            \n            # Count substrings with at most k ones\n            valid_ones = count_valid_substrings(l, r, k, prefix_ones)\n            \n            # Count substrings with at most k zeros and at most k ones (total valid substrings)\n            total_valid_substrings = valid_zeros + valid_ones - count_valid_substrings(l, r, k, prefix_zeros) - count_valid_substrings(l, r, k, prefix_ones) + count_valid_substrings(l, r, k, prefix_zeros)\n            \n            result.append(total_valid_substrings)\n        \n        return result",
              "solution_hash": "e4aa004eb21ee464654f41daa67aa319548871a06605f463efd3ddec2f2c7c00",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpep8gc_2i.py\", line 196, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpep8gc_2i.py\", line 120, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.06268882751464844
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(prefix, k, l, r):\n            count = 0\n            for i in range(l, r + 1):\n                zeros_or_ones = prefix[r + 1] - prefix[i]\n                if zeros_or_ones <= k:\n                    count += (r - i + 1)\n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(prefix_zeros, k, l, r)\n            count_ones = count_valid_substrings(prefix_ones, k, l, r)\n            count_both = count_valid_substrings(prefix_zeros, k, l, r) + count_valid_substrings(prefix_ones, k, l, r) - count_valid_substrings(prefix_zeros, k, l, r)\n            result.append(count_zeros + count_ones - count_both)\n        \n        return result",
      "solution_hash": "e263b0c8df7eb337e90873e9bc700d83b9b1e733a641938a128610b1b4579294",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp4ahsx8hc.py\", line 186, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp4ahsx8hc.py\", line 110, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
        "execution_time": 0.06254911422729492
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_14",
          "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l, r, k):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = l\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
          "solution_hash": "17581de9045a17c5e36d732235df253ae742220649a32442ad366a14a8277d9d",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06335759162902832
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_15",
          "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l: int, r: int, k: int) -> int:\n            count = 0\n            zero_count = 0\n            one_count = 0\n            start = l\n            \n            for end in range(l, r + 1):\n                if s[end] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[start] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    start += 1\n                \n                count += (end - start + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r, k))\n        \n        return result",
          "solution_hash": "b9b0a82ff23b78a12769eabd59a7b0378884bb9e6174c24164aa2e95a72afddb",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06433296203613281
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_16",
          "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        def count_valid_substrings(l: int, r: int) -> int:\n            count_zeros = 0\n            count_ones = 0\n            left = l\n            valid_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    count_zeros += 1\n                else:\n                    count_ones += 1\n                \n                while count_zeros > k and count_ones > k:\n                    if s[left] == '0':\n                        count_zeros -= 1\n                    else:\n                        count_ones -= 1\n                    left += 1\n                \n                if count_zeros <= k or count_ones <= k:\n                    valid_count += (right - left + 1)\n            \n            return valid_count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r))\n        \n        return result",
          "solution_hash": "a68eb44322b8152cc51905ba0ab83d3dfb5cb6d51a463bd791bdb86dc0efffe2",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06603336334228516
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [],
          "passed": true
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        prefix_zeros = [0] * (n + 1)\n        prefix_ones = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')\n            prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')\n        \n        def count_valid_substrings(prefix, k, l, r):\n            count = 0\n            for i in range(l, r + 1):\n                zeros_or_ones = prefix[r + 1] - prefix[i]\n                if zeros_or_ones <= k:\n                    count += (r - i + 1)\n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(prefix_zeros, k, l, r)\n            count_ones = count_valid_substrings(prefix_ones, k, l, r)\n            total_count = count_zeros + count_ones - (prefix_zeros[r + 1] - prefix_zeros[l]) - (prefix_ones[r + 1] - prefix_ones[l])\n            result.append(total_count)\n        \n        return result",
      "solution_hash": "d191c3c47089524a8e3b9356404a1d19bb3d5bffca5e4b318e2d8e0c3d3223e0",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp_g1o721f.py\", line 186, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp_g1o721f.py\", line 110, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
        "execution_time": 0.06307387351989746
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_18",
          "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l: int, r: int) -> int:\n            count_zeros = 0\n            count_ones = 0\n            left = l\n            valid_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    count_zeros += 1\n                else:\n                    count_ones += 1\n                \n                while count_zeros > k and count_ones > k:\n                    if s[left] == '0':\n                        count_zeros -= 1\n                    else:\n                        count_ones -= 1\n                    left += 1\n                \n                if count_zeros <= k or count_ones <= k:\n                    valid_count += (right - left + 1)\n            \n            return valid_count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(l, r))\n        \n        return result",
          "solution_hash": "4d340ad3abb43590b3e1b3c1072bdacd8094faadea239ebb0f7bfd6cfd042217",
          "test_result": {
            "status": "pass",
            "execution_time": 0.06328248977661133
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [],
          "passed": true
        },
        {
          "node_id": "1_19",
          "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(l, r, k, '0')\n            count_ones = count_valid_substrings(l, r, k, '1')\n            total_count = count_zeros + count_ones - (r - l + 1)\n            result.append(total_count)\n        \n        return result",
          "solution_hash": "52a482fa11e60bc8a0bf43d79218a88c4fcb08b41eaa474b7c9be8498c3169b2",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpl2vszz_n.py\", line 192, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmpl2vszz_n.py\", line 116, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
            "execution_time": 0.06593513488769531
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_20",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_invalid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            invalid_zeros = count_invalid_substrings(l, r, k, '0')\n            invalid_ones = count_invalid_substrings(l, r, k, '1')\n            invalid_both = count_invalid_substrings(l, r, k, '0') + count_invalid_substrings(l, r, k, '1') - total_substrings\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones + invalid_both\n            result.append(valid_substrings)\n        \n        return result",
              "solution_hash": "822852ab6504eaddb0ade42d9f6461d7d5c7de960dd6eaff77191af411600e8c",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp6ybvuiq9.py\", line 194, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp6ybvuiq9.py\", line 118, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.06249260902404785
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_21",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_valid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            count_zeros = count_valid_substrings(l, r, k, '0')\n            count_ones = count_valid_substrings(l, r, k, '1')\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            valid_count = count_zeros + count_ones - total_substrings\n            result.append(total_substrings - valid_count)\n        \n        return result",
              "solution_hash": "40ae9f38f3a2b06f084af2369642cce767b85d0c29b36d07ceeb13bc4ca363ca",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp96x9fklg.py\", line 193, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp96x9fklg.py\", line 117, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.06642341613769531
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_22",
              "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        \n        def count_invalid_substrings(l, r, k, target_char):\n            count = 0\n            left = l\n            current_count = 0\n            \n            for right in range(l, r + 1):\n                if s[right] == target_char:\n                    current_count += 1\n                \n                while current_count > k:\n                    if s[left] == target_char:\n                        current_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            total_substrings = (r - l + 1) * (r - l + 2) // 2\n            invalid_zeros = count_invalid_substrings(l, r, k, '0')\n            invalid_ones = count_invalid_substrings(l, r, k, '1')\n            valid_substrings = total_substrings - invalid_zeros - invalid_ones\n            result.append(valid_substrings)\n        \n        return result",
              "solution_hash": "058cdbdb522f0921f03e90135aa56c4d72b6923cef9da1f869775d685aee8edb",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp4auqy6yo.py\", line 193, in <module>\n    check(Solution().countKConstraintSubstrings)\n  File \"/scratch/local/21419950/tmp4auqy6yo.py\", line 117, in check\n    assert candidate(s = \"010101\",k = 1,queries = [[0, 5], [1, 4], [2, 3]]) == [15, 9, 3]\nAssertionError\n",
                "execution_time": 0.06325125694274902
              },
              "depth": 2,
              "parent_id": "1_19",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_23",
          "solution": "from typing import List\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n        def count_valid_substrings(s, k, l, r):\n            count = 0\n            zero_count = 0\n            one_count = 0\n            left = l\n            \n            for right in range(l, r + 1):\n                if s[right] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                \n                while zero_count > k and one_count > k:\n                    if s[left] == '0':\n                        zero_count -= 1\n                    else:\n                        one_count -= 1\n                    left += 1\n                \n                count += (right - left + 1)\n            \n            return count\n        \n        result = []\n        for l, r in queries:\n            result.append(count_valid_substrings(s, k, l, r))\n        \n        return result",
          "solution_hash": "cb9c1397722a7d232f6079bc98014e7442eed8dac355313d5988f71c9984705d",
          "test_result": {
            "status": "pass",
            "execution_time": 0.0634913444519043
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [],
          "passed": true
        }
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 24,
    "candidates_generated": 24,
    "tests_passed": 7,
    "tests_failed": 16,
    "test_errors": 1,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 729.3234117031097,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.32000000000000006,
      "pass@3": 0.7043478260869565,
      "pass@5": 0.8835309617918313,
      "pass@10": 0.9940503432494279
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "timed out",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: local variable 'count_both_invalid' referenced before assignment",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 24
          }
        ]
      ]
    },
    "solutions_evaluated": 25,
    "test_cases": 1
  }
}