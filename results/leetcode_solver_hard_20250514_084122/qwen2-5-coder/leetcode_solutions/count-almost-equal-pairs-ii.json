{
  "problem_id": "count-almost-equal-pairs-ii",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "from collections import Counter\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        digit_count_map = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            current_count = get_digit_count(num)\n            for i in range(10):\n                for j in range(i + 1, 10):\n                    # Try removing one occurrence of digit i and adding one of digit j\n                    modified_count = list(current_count)\n                    modified_count = [list(x) for x in modified_count]\n                    \n                    # Remove one occurrence of digit i if present\n                    found_i = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(i) and cnt > 0:\n                            modified_count[k][1] -= 1\n                            if modified_count[k][1] == 0:\n                                del modified_count[k]\n                            found_i = True\n                            break\n                    \n                    # Add one occurrence of digit j\n                    found_j = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(j):\n                            modified_count[k][1] += 1\n                            found_j = True\n                            break\n                    else:\n                        modified_count.append([str(j), 1])\n                        found_j = True\n                    \n                    if found_i and found_j:\n                        modified_count = tuple(tuple(x) for x in sorted(modified_count))\n                        count += digit_count_map[modified_count]\n                    \n                    # Try removing one occurrence of digit j and adding one of digit i\n                    modified_count = list(current_count)\n                    modified_count = [list(x) for x in modified_count]\n                    \n                    # Remove one occurrence of digit j if present\n                    found_j = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(j) and cnt > 0:\n                            modified_count[k][1] -= 1\n                            if modified_count[k][1] == 0:\n                                del modified_count[k]\n                            found_j = True\n                            break\n                    \n                    # Add one occurrence of digit i\n                    found_i = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(i):\n                            modified_count[k][1] += 1\n                            found_i = True\n                            break\n                    else:\n                        modified_count.append([str(i), 1])\n                        found_i = True\n                    \n                    if found_i and found_j:\n                        modified_count = tuple(tuple(x) for x in sorted(modified_count))\n                        count += digit_count_map[modified_count]\n            \n            # Check for the same digit count\n            count += digit_count_map[current_count] * (digit_count_map[current_count] - 1) // 2\n            \n            # Update the map with the current digit count\n            digit_count_map[current_count] += 1\n        \n        return count",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            # Convert to dictionaries for easier comparison\n            dict1 = dict(count1)\n            dict2 = dict(count2)\n            \n            # Calculate the differences in digit counts\n            diff = Counter()\n            for digit in set(dict1.keys()).union(set(dict2.keys())):\n                diff[digit] = abs(dict1.get(digit, 0) - dict2.get(digit, 0))\n            \n            # Count the total number of mismatches\n            mismatch_count = sum(diff.values())\n            \n            # Check if the mismatch can be resolved with at most 2 swaps\n            return mismatch_count <= 4 and max(diff.values()) <= 2\n        \n        digit_count_list = [get_digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(digit_count_list[i], digit_count_list[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_digit_list = [sort_digits(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                # Count the number of differing positions\n                diff_count = sum(1 for a, b in zip(sorted_digit_list[i], sorted_digit_list[j]) if a != b)\n                # Check if the numbers can be made almost equal with at most 2 swaps\n                if diff_count <= 2:\n                    count += 1\n        \n        return count",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            # Convert to dictionaries for easier comparison\n            dict1 = dict(count1)\n            dict2 = dict(count2)\n            \n            # Calculate the differences in digit counts\n            diff = Counter()\n            for digit in set(dict1.keys()).union(set(dict2.keys())):\n                diff[digit] = abs(dict1.get(digit, 0) - dict2.get(digit, 0))\n            \n            # Count the total number of mismatches\n            mismatch_count = sum(diff.values())\n            \n            # Count the number of odd mismatches\n            odd_mismatches = sum(1 for count in diff.values() if count % 2 != 0)\n            \n            # Check if the mismatch can be resolved with at most 2 swaps\n            # We need at most 2 swaps, so the number of odd mismatches should be at most 2\n            # and the total mismatch count should allow for pairing\n            return mismatch_count <= 4 and odd_mismatches <= 2\n        \n        digit_count_list = [get_digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(digit_count_list[i], digit_count_list[j]):\n                    count += 1\n        \n        return count",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            # Convert to dictionaries for easier comparison\n            dict1 = dict(count1)\n            dict2 = dict(count2)\n            \n            # Calculate the differences in digit counts\n            diff = Counter()\n            for digit in set(dict1.keys()).union(set(dict2.keys())):\n                diff[digit] = abs(dict1.get(digit, 0) - dict2.get(digit, 0))\n            \n            # Count the total number of mismatches and the maximum difference\n            mismatch_count = sum(diff.values())\n            max_diff = max(diff.values())\n            \n            # Check if the mismatch can be resolved with at most 2 swaps\n            # We need to ensure that we can balance the differences with at most 2 swaps\n            # For example, if one number has 3 '1's and the other has 1 '1', we need 2 swaps to balance\n            # If there are more than 2 digits with non-zero differences, it's impossible with 2 swaps\n            non_zero_diffs = sum(1 for d in diff.values() if d > 0)\n            return non_zero_diffs <= 4 and max_diff <= 2\n        \n        digit_count_list = [get_digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(digit_count_list[i], digit_count_list[j]):\n                    count += 1\n        \n        return count",
    "from collections import defaultdict\nfrom itertools import permutations\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_permutations(num):\n            num_str = str(num)\n            perm_set = set()\n            for perm in permutations(num_str):\n                perm_set.add(''.join(perm))\n            return perm_set\n        \n        perm_map = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            current_perms = get_permutations(num)\n            for perm in current_perms:\n                count += perm_map[perm]\n            \n            for perm in current_perms:\n                perm_map[perm] += 1\n        \n        return count",
    "from collections import Counter, defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        digit_count_map = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            current_count = get_digit_count(num)\n            for existing_count, existing_count_value in digit_count_map.items():\n                diff = sum(abs(a - b) for (a_digit, a), (b_digit, b) in zip(current_count, existing_count)) + abs(len(current_count) - len(existing_count))\n                if diff <= 4:  # Maximum difference in digit counts considering up to 2 swaps\n                    count += existing_count_value\n            \n            digit_count_map[current_count] += 1\n        \n        return count",
    "from collections import Counter, defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count_map = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            digit_count = get_digit_count(num)\n            for key in count_map:\n                if self.can_be_almost_equal(digit_count, key):\n                    result += count_map[key]\n            count_map[digit_count] += 1\n        \n        return result\n    \n    def can_be_almost_equal(self, count1, count2):\n        diff = 0\n        i, j = 0, 0\n        while i < len(count1) and j < len(count2):\n            if count1[i][0] == count2[j][0]:\n                if abs(count1[i][1] - count2[j][1]) > 2:\n                    return False\n                diff += abs(count1[i][1] - count2[j][1])\n                i += 1\n                j += 1\n            elif count1[i][0] < count2[j][0]:\n                if count1[i][1] > 2:\n                    return False\n                diff += count1[i][1]\n                i += 1\n            else:\n                if count2[j][1] > 2:\n                    return False\n                diff += count2[j][1]\n                j += 1\n        \n        while i < len(count1):\n            if count1[i][1] > 2:\n                return False\n            diff += count1[i][1]\n            i += 1\n        \n        while j < len(count2):\n            if count2[j][1] > 2:\n                return False\n            diff += count2[j][1]\n            j += 1\n        \n        return diff <= 4",
    "from collections import Counter, defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count_map = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            digit_count = get_digit_count(num)\n            for key in count_map:\n                if self.can_be_almost_equal(digit_count, key):\n                    result += count_map[key]\n            count_map[digit_count] += 1\n        \n        return result\n    \n    def can_be_almost_equal(self, count1, count2):\n        diff = 0\n        i, j = 0, 0\n        while i < len(count1) and j < len(count2):\n            if count1[i][0] == count2[j][0]:\n                if abs(count1[i][1] - count2[j][1]) > 2:\n                    return False\n                diff += abs(count1[i][1] - count2[j][1])\n                i += 1\n                j += 1\n            elif count1[i][0] < count2[j][0]:\n                if count1[i][1] > 2:\n                    return False\n                diff += count1[i][1]\n                i += 1\n            else:\n                if count2[j][1] > 2:\n                    return False\n                diff += count2[j][1]\n                j += 1\n        \n        while i < len(count1):\n            if count1[i][1] > 2:\n                return False\n            diff += count1[i][1]\n            i += 1\n        \n        while j < len(count2):\n            if count2[j][1] > 2:\n                return False\n            diff += count2[j][1]\n            j += 1\n        \n        return diff <= 4",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        digit_count_map = Counter()\n        count = 0\n        \n        for num in nums:\n            current_digits = get_sorted_digits(num)\n            current_count = digit_count_map[current_digits]\n            \n            # Check against all previously seen digit sequences\n            for seen_digits, seen_count in digit_count_map.items():\n                diff_count = sum((Counter(current_digits) | Counter(seen_digits)) - (Counter(current_digits) & Counter(seen_digits)))\n                if diff_count <= 2:\n                    count += seen_count\n            \n            # Update the map with the current digit sequence\n            digit_count_map[current_digits] += 1\n        \n        return count",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_counts(num):\n            counts = [0] * 10\n            for digit in str(num):\n                counts[int(digit)] += 1\n            return tuple(counts)\n        \n        digit_count_map = Counter()\n        count = 0\n        \n        for num in nums:\n            current_counts = get_digit_counts(num)\n            \n            # Check against all previously seen digit sequences\n            for seen_counts, seen_count in digit_count_map.items():\n                diff_count = sum(abs(a - b) for a, b in zip(current_counts, seen_counts))\n                if diff_count // 2 <= 2:\n                    count += seen_count\n            \n            # Update the map with the current digit sequence\n            digit_count_map[current_counts] += 1\n        \n        return count",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(counter1, counter2):\n            diff = 0\n            all_digits = set(counter1.keys()).union(set(counter2.keys()))\n            for digit in all_digits:\n                if abs(counter1.get(digit, 0) - counter2.get(digit, 0)) > 1:\n                    diff += 1\n                if diff > 2:\n                    return False\n            return True\n        \n        digit_count_map = []\n        count = 0\n        \n        for num in nums:\n            current_counter = Counter(str(num))\n            for seen_counter in digit_count_map:\n                if can_be_almost_equal(current_counter, seen_counter):\n                    count += 1\n            digit_count_map.append(current_counter)\n        \n        return count",
    "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(num_str):\n            variations = {num_str}\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            return variations\n        \n        count = 0\n        num_variations = defaultdict(int)\n        \n        for num in nums:\n            num_str = str(num)\n            variations = generate_variations(num_str)\n            for variation in variations:\n                count += num_variations[variation]\n            for variation in variations:\n                num_variations[variation] += 1\n        \n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variations(num_str):\n            variations = set([num_str])\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n                    for k in range(j + 1, n):\n                        swapped2 = list(swapped)\n                        swapped2[j], swapped2[k] = swapped2[k], swapped2[j]\n                        variations.add(''.join(swapped2))\n            return variations\n        \n        num_map = defaultdict(int)\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                num_map[tuple(sorted(variation))] += 1\n        \n        count = 0\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                count += num_map[tuple(sorted(variation))]\n            num_map[tuple(sorted(num_str))] -= 1\n        \n        return count // 2",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_pattern(num):\n            # Convert number to string, sort the digits, and count occurrences\n            digit_count = [0] * 10\n            for digit in str(num):\n                digit_count[int(digit)] += 1\n            return tuple(digit_count)\n        \n        # Count the frequency of each digit pattern\n        pattern_count = Counter(get_digit_pattern(num) for num in nums)\n        \n        count = 0\n        for pattern in pattern_count:\n            freq = pattern_count[pattern]\n            # Choose 2 out of freq numbers to form a pair\n            count += freq * (freq - 1) // 2\n        \n        return count",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_pattern(num):\n            # Convert number to string and count occurrences of each digit\n            return Counter(str(num))\n        \n        def can_be_almost_equal(pattern1, pattern2):\n            # Calculate the difference in digit counts\n            diff = Counter()\n            for digit in set(pattern1.keys()).union(set(pattern2.keys())):\n                diff[digit] = abs(pattern1[digit] - pattern2[digit])\n            \n            # Sum of differences should be 4 or less for at most 2 swaps\n            return sum(diff.values()) <= 4\n        \n        patterns = [get_digit_pattern(num) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        # Compare each pair of numbers\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(patterns[i], patterns[j]):\n                    count += 1\n        \n        return count",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(num1, num2):\n            count1 = Counter(str(num1))\n            count2 = Counter(str(num2))\n            \n            diff_count = 0\n            for digit in set(count1.keys()).union(set(count2.keys())):\n                diff = abs(count1[digit] - count2[digit])\n                if diff > 2:\n                    return False\n                diff_count += diff\n            \n            # We can fix at most 4 mismatches with 2 swaps\n            return diff_count <= 4\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_sorted_digits(num):\n            # Convert number to string, sort the digits, and return as a tuple\n            return tuple(sorted(str(num)))\n        \n        # Dictionary to count occurrences of each sorted digit sequence\n        sorted_digit_count = {}\n        \n        for num in nums:\n            sorted_digits = get_sorted_digits(num)\n            if sorted_digits in sorted_digit_count:\n                sorted_digit_count[sorted_digits] += 1\n            else:\n                sorted_digit_count[sorted_digits] = 1\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                # Compare sorted digit sequences of nums[i] and nums[j]\n                sorted_i = get_sorted_digits(nums[i])\n                sorted_j = get_sorted_digits(nums[j])\n                \n                # Count the number of differing positions\n                diff_count = sum(1 for a, b in zip(sorted_i, sorted_j) if a != b)\n                \n                # Check if they can be made equal with at most two swaps\n                if diff_count <= 2:\n                    count += 1\n        \n        return count",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            num_tuple = digit_count(num)\n            for i in range(10):\n                for j in range(i, 10):\n                    # Try changing the count of digit i by -1 and digit j by +1\n                    new_tuple = list(num_tuple)\n                    new_tuple = [(d, c - (1 if d == i else 0) + (1 if d == j else 0)) for d, c in new_tuple]\n                    new_tuple = [(d, c) for d, c in new_tuple if c > 0]\n                    count += seen[tuple(sorted(new_tuple))]\n                    \n                    # If i != j, also try changing the count of digit i by +1 and digit j by -1\n                    if i != j:\n                        new_tuple = list(num_tuple)\n                        new_tuple = [(d, c + (1 if d == i else 0) - (1 if d == j else 0)) for d, c in new_tuple]\n                        new_tuple = [(d, c) for d, c in new_tuple if c > 0]\n                        count += seen[tuple(sorted(new_tuple))]\n            \n            # Also consider the original number itself\n            count += seen[num_tuple]\n            seen[num_tuple] += 1\n        \n        return count",
    "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_tuple(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            num_tuple = digit_tuple(num)\n            # Check all possible tuples that can be formed by up to 2 swaps\n            for i in range(len(num_tuple)):\n                for j in range(i + 1, len(num_tuple)):\n                    # Swap i and j\n                    swapped_tuple = list(num_tuple)\n                    swapped_tuple[i], swapped_tuple[j] = swapped_tuple[j], swapped_tuple[i]\n                    swapped_tuple = tuple(swapped_tuple)\n                    count += seen[swapped_tuple]\n                    \n                    # Perform a second swap\n                    for k in range(len(num_tuple)):\n                        for l in range(k + 1, len(num_tuple)):\n                            if k != i and k != j and l != i and l != j:\n                                double_swapped_tuple = list(swapped_tuple)\n                                double_swapped_tuple[k], double_swapped_tuple[l] = double_swapped_tuple[l], double_swapped_tuple[k]\n                                double_swapped_tuple = tuple(double_swapped_tuple)\n                                count += seen[double_swapped_tuple]\n            \n            # Count the original number itself\n            count += seen[num_tuple]\n            seen[num_tuple] += 1\n        \n        return count",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def generate_variations(count):\n            variations = set([count])\n            digits = sorted(count.keys())\n            n = len(digits)\n            \n            # Single swap variations\n            for i in range(n):\n                for j in range(i, n):\n                    if count[digits[i]] > 0 and count[digits[j]] > 0:\n                        new_count = dict(count)\n                        new_count[digits[i]] -= 1\n                        new_count[digits[j]] += 1\n                        variations.add(tuple(sorted(new_count.items())))\n            \n            # Double swap variations\n            for i in range(n):\n                for j in range(i, n):\n                    if count[digits[i]] > 0 and count[digits[j]] > 0:\n                        for k in range(n):\n                            for l in range(k, n):\n                                if count[digits[k]] > 0 and count[digits[l]] > 0:\n                                    new_count = dict(count)\n                                    new_count[digits[i]] -= 1\n                                    new_count[digits[j]] += 1\n                                    new_count[digits[k]] -= 1\n                                    new_count[digits[l]] += 1\n                                    variations.add(tuple(sorted(new_count.items())))\n            \n            return variations\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            num_tuple = digit_count(num)\n            variations = generate_variations(num_tuple)\n            for variation in variations:\n                count += seen[variation]\n            seen[num_tuple] += 1\n        \n        return count",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            diff = defaultdict(int)\n            for d, c in count1:\n                diff[d] += c\n            for d, c in count2:\n                diff[d] -= c\n            \n            changes = 0\n            for c in diff.values():\n                changes += abs(c)\n            \n            # We can make up to 4 changes (2 swaps) to match the counts\n            return changes // 2 <= 2\n        \n        count = 0\n        n = len(nums)\n        digit_counts = [digit_count(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(digit_counts[i], digit_counts[j]):\n                    count += 1\n        \n        return count",
    "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        num_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            sorted_num = sort_digits(num)\n            count += num_count[sorted_num]\n            num_count[sorted_num] += 1\n        \n        return count",
    "from typing import List\nfrom itertools import combinations\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(num_str):\n            variations = {num_str}\n            n = len(num_str)\n            for i, j in combinations(range(n), 2):\n                swapped = list(num_str)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                variations.add(''.join(swapped))\n                for k, l in combinations(range(n), 2):\n                    if k != i and k != j and l != i and l != j:\n                        double_swapped = list(swapped)\n                        double_swapped[k], double_swapped[l] = double_swapped[l], double_swapped[k]\n                        variations.add(''.join(double_swapped))\n            return variations\n        \n        num_variations = [generate_variations(str(num)) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if num_variations[i].intersection(num_variations[j]):\n                    count += 1\n        \n        return count",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return Counter(str(num))\n        \n        def can_be_almost_equal(count1, count2):\n            diff = 0\n            all_digits = set(count1.keys()).union(set(count2.keys()))\n            for digit in all_digits:\n                diff += abs(count1[digit] - count2[digit])\n            return diff <= 4\n        \n        num_counts = [digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(num_counts[i], num_counts[j]):\n                    count += 1\n        \n        return count",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(num_str):\n            n = len(num_str)\n            variations = set()\n            # No swap\n            variations.add(num_str)\n            # One swap\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            # Two swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    for k in range(n):\n                        if k != i and k != j:\n                            for l in range(k + 1, n):\n                                if l != i and l != j:\n                                    swapped = list(num_str)\n                                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                                    swapped[k], swapped[l] = swapped[l], swapped[k]\n                                    variations.add(''.join(swapped))\n            return variations\n        \n        num_variations = defaultdict(set)\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                num_variations[variation].add(num_str)\n        \n        count = 0\n        seen = set()\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                for other_num_str in num_variations[variation]:\n                    if other_num_str != num_str and (num_str, other_num_str) not in seen and (other_num_str, num_str) not in seen:\n                        seen.add((num_str, other_num_str))\n                        count += 1\n        \n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Function to create a canonical form of a number by sorting its digits\n        def canonical_form(num):\n            return tuple(sorted(str(num)))\n        \n        # Dictionary to count occurrences of each canonical form\n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = canonical_form(num)\n            # Check all possible forms that can be obtained by changing up to 2 digits\n            for i in range(10):\n                for j in range(10):\n                    for k in range(len(form)):\n                        new_form = list(form)\n                        new_form[k] = str(i)\n                        new_form = tuple(sorted(new_form))\n                        result += count[new_form]\n                        if i != j:\n                            for l in range(k + 1, len(form)):\n                                new_form2 = list(new_form)\n                                new_form2[l] = str(j)\n                                new_form2 = tuple(sorted(new_form2))\n                                result += count[new_form2]\n            count[form] += 1\n        \n        return result",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for key in count:\n                if self.almost_equal(form, key):\n                    result += count[key]\n            count[form] += 1\n        \n        return result\n    \n    def almost_equal(self, counter1, counter2):\n        if len(counter1) != len(counter2):\n            return False\n        diff = 0\n        for (d1, c1), (d2, c2) in zip(counter1, counter2):\n            if d1 != d2:\n                return False\n            diff += abs(c1 - c2)\n            if diff > 2:\n                return False\n        return True",
    "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = {}\n        result = 0\n        \n        for num in nums:\n            form = sorted_digits(num)\n            for key in count:\n                if self.almost_equal(form, key):\n                    result += count[key]\n            if form in count:\n                count[form] += 1\n            else:\n                count[form] = 1\n        \n        return result\n    \n    def almost_equal(self, sorted1, sorted2):\n        if len(sorted1) != len(sorted2):\n            return False\n        diff = 0\n        for d1, d2 in zip(sorted1, sorted2):\n            if d1 != d2:\n                diff += 1\n            if diff > 2:\n                return False\n        return True",
    "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = sorted_digits(num)\n            for existing_form in count:\n                if self.almost_equal(form, existing_form):\n                    result += count[existing_form]\n            count[form] += 1\n        \n        return result\n    \n    def almost_equal(self, form1, form2):\n        if len(form1) != len(form2):\n            return False\n        diff = sum(f1 != f2 for f1, f2 in zip(form1, form2))\n        return diff <= 2",
    "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = sorted_digits(num)\n            for key in count:\n                if self.almost_equal(form, key):\n                    result += count[key]\n            count[form] += 1\n        \n        return result\n    \n    def almost_equal(self, sorted1, sorted2):\n        if len(sorted1) != len(sorted2):\n            return False\n        diff = 0\n        for d1, d2 in zip(sorted1, sorted2):\n            if d1 != d2:\n                diff += 1\n                if diff > 2:\n                    return False\n        return True",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for i in range(10):\n                for j in range(i, 10):\n                    # Create a new form by adding or removing one occurrence of digit i and j\n                    new_form = list(form)\n                    new_form.append((str(i), 1))\n                    new_form.append((str(j), 1))\n                    new_form.sort()\n                    result += count[tuple(new_form)]\n                    \n                    if i != j:\n                        new_form2 = list(form)\n                        new_form2.append((str(i), 1))\n                        new_form2.append((str(j), -1))\n                        new_form2.sort()\n                        result += count[tuple(new_form2)]\n                        \n                        new_form3 = list(form)\n                        new_form3.append((str(i), -1))\n                        new_form3.append((str(j), 1))\n                        new_form3.sort()\n                        result += count[tuple(new_form3)]\n                        \n                        new_form4 = list(form)\n                        new_form4.append((str(i), -1))\n                        new_form4.append((str(j), -1))\n                        new_form4.sort()\n                        result += count[tuple(new_form4)]\n            \n            count[form] += 1\n        \n        return result",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for i in range(len(form)):\n                for j in range(i, len(form)):\n                    # Create a new form by reducing the count of the i-th and j-th digits\n                    new_form = list(form)\n                    new_form[i] = (new_form[i][0], new_form[i][1] - 1)\n                    if new_form[i][1] == 0:\n                        new_form.pop(i)\n                    else:\n                        new_form = tuple(new_form)\n                    \n                    if i != j:\n                        new_form_j = list(new_form)\n                        new_form_j[j] = (new_form_j[j][0], new_form_j[j][1] - 1)\n                        if new_form_j[j][1] == 0:\n                            new_form_j.pop(j)\n                        new_form_j = tuple(new_form_j)\n                        result += count[new_form_j]\n                    \n                    result += count[new_form]\n            \n            count[form] += 1\n        \n        return result",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for i in range(len(form)):\n                for j in range(i, len(form)):\n                    # Create a new form by reducing the count of digit i and j by 1\n                    new_form = list(form)\n                    new_form[i] = (new_form[i][0], new_form[i][1] - 1)\n                    if new_form[i][1] == 0:\n                        new_form.pop(i)\n                    else:\n                        new_form = tuple(new_form)\n                    \n                    if i != j:\n                        new_form2 = list(new_form)\n                        if j > i:\n                            j -= 1\n                        new_form2[j] = (new_form2[j][0], new_form2[j][1] - 1)\n                        if new_form2[j][1] == 0:\n                            new_form2.pop(j)\n                        new_form2 = tuple(new_form2)\n                    else:\n                        new_form2 = new_form\n                    \n                    result += count[new_form]\n                    if i != j:\n                        result += count[new_form2]\n            \n            count[form] += 1\n        \n        return result",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            str_num = str(num)\n            n = len(str_num)\n            \n            # Check all pairs of indices for swapping\n            for i in range(n):\n                for j in range(i + 1, n):\n                    # Swap digits at positions i and j\n                    swapped_str = str_num[:i] + str_num[j] + str_num[i+1:j] + str_num[i] + str_num[j+1:]\n                    swapped_form = digit_count(swapped_str)\n                    result += count[swapped_form]\n                    \n                    # Perform a second swap if possible\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if k != i and k != j and l != i and l != j:\n                                second_swapped_str = swapped_str[:k] + swapped_str[l] + swapped_str[k+1:l] + swapped_str[k] + swapped_str[l+1:]\n                                second_swapped_form = digit_count(second_swapped_str)\n                                result += count[second_swapped_form]\n            \n            count[form] += 1\n        \n        return result",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            # Check all possible forms that can be obtained by changing up to 2 digits\n            for i in range(10):\n                for j in range(10):\n                    # Create a new form by adding or removing one digit\n                    new_form = list(form)\n                    new_form.append((str(i), 1))\n                    new_form.sort()\n                    new_form = tuple(new_form)\n                    result += count[new_form]\n                    \n                    if i != j:\n                        # Create another new form by adding or removing two different digits\n                        new_form2 = list(new_form)\n                        new_form2.append((str(j), 1))\n                        new_form2.sort()\n                        new_form2 = tuple(new_form2)\n                        result += count[new_form2]\n            \n            # Update the count of the current form\n            count[form] += 1\n        \n        return result",
    "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(form1, form2):\n            if len(form1) != len(form2):\n                return False\n            \n            diff_count = 0\n            i, j = 0, 0\n            \n            while i < len(form1) and j < len(form2):\n                if form1[i] == form2[j]:\n                    i += 1\n                    j += 1\n                else:\n                    if form1[i][1] > form2[j][1]:\n                        diff_count += form1[i][1] - form2[j][1]\n                        i += 1\n                    elif form1[i][1] < form2[j][1]:\n                        diff_count += form2[j][1] - form1[i][1]\n                        j += 1\n                    else:\n                        i += 1\n                        j += 1\n                    \n                    if diff_count > 2:\n                        return False\n            \n            diff_count += abs(len(form1) - i) + abs(len(form2) - j)\n            return diff_count <= 2\n        \n        counts = [digit_count(num) for num in nums]\n        result = 0\n        \n        for i in range(len(counts)):\n            for j in range(i + 1, len(counts)):\n                if can_be_almost_equal(counts[i], counts[j]):\n                    result += 1\n        \n        return result",
    "from collections import Counter, defaultdict\nfrom typing import List\nfrom itertools import permutations\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            digits = str(num)\n            variants = set()\n            # Generate all permutations of the digits\n            for perm in permutations(digits):\n                # Join the tuple of characters into a string and convert to integer\n                variant = int(''.join(perm))\n                variants.add(variant)\n            # Include up to 2 swaps by considering subsets of permutations\n            for i in range(len(digits)):\n                for j in range(i + 1, len(digits)):\n                    swapped_digits = list(digits)\n                    swapped_digits[i], swapped_digits[j] = swapped_digits[j], swapped_digits[i]\n                    swapped_num = int(''.join(swapped_digits))\n                    variants.add(swapped_num)\n                    for k in range(len(digits)):\n                        for l in range(k + 1, len(digits)):\n                            if k != i and k != j and l != i and l != j:\n                                double_swapped_digits = list(swapped_digits)\n                                double_swapped_digits[k], double_swapped_digits[l] = double_swapped_digits[l], double_swapped_digits[k]\n                                double_swapped_num = int(''.join(double_swapped_digits))\n                                variants.add(double_swapped_num)\n            return variants\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            variants = generate_variants(num)\n            for variant in variants:\n                result += count[variant]\n            count[num] += 1\n        \n        return result",
    "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            # Check all possible forms that can be obtained by changing up to 2 digits\n            for i in range(len(form)):\n                for j in range(i, len(form)):\n                    # Remove one digit\n                    new_form1 = form[:i] + form[i+1:]\n                    result += count[new_form1]\n                    \n                    # Remove two digits\n                    for k in range(j+1, len(form)):\n                        new_form2 = form[:i] + form[i+1:j] + form[j+1:k] + form[k+1:]\n                        result += count[new_form2]\n            \n            # Check if the form itself has been seen before\n            result += count[form]\n            \n            # Update the count of the current form\n            count[form] += 1\n        \n        # Each pair is counted twice, so we divide by 2\n        return result // 2"
  ],
  "total_candidates": 39,
  "nodes_explored": 39,
  "tree_depth": 2,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "from collections import Counter\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        digit_count_map = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            current_count = get_digit_count(num)\n            for i in range(10):\n                for j in range(i + 1, 10):\n                    # Try removing one occurrence of digit i and adding one of digit j\n                    modified_count = list(current_count)\n                    modified_count = [list(x) for x in modified_count]\n                    \n                    # Remove one occurrence of digit i if present\n                    found_i = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(i) and cnt > 0:\n                            modified_count[k][1] -= 1\n                            if modified_count[k][1] == 0:\n                                del modified_count[k]\n                            found_i = True\n                            break\n                    \n                    # Add one occurrence of digit j\n                    found_j = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(j):\n                            modified_count[k][1] += 1\n                            found_j = True\n                            break\n                    else:\n                        modified_count.append([str(j), 1])\n                        found_j = True\n                    \n                    if found_i and found_j:\n                        modified_count = tuple(tuple(x) for x in sorted(modified_count))\n                        count += digit_count_map[modified_count]\n                    \n                    # Try removing one occurrence of digit j and adding one of digit i\n                    modified_count = list(current_count)\n                    modified_count = [list(x) for x in modified_count]\n                    \n                    # Remove one occurrence of digit j if present\n                    found_j = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(j) and cnt > 0:\n                            modified_count[k][1] -= 1\n                            if modified_count[k][1] == 0:\n                                del modified_count[k]\n                            found_j = True\n                            break\n                    \n                    # Add one occurrence of digit i\n                    found_i = False\n                    for k, (digit, cnt) in enumerate(modified_count):\n                        if digit == str(i):\n                            modified_count[k][1] += 1\n                            found_i = True\n                            break\n                    else:\n                        modified_count.append([str(i), 1])\n                        found_i = True\n                    \n                    if found_i and found_j:\n                        modified_count = tuple(tuple(x) for x in sorted(modified_count))\n                        count += digit_count_map[modified_count]\n            \n            # Check for the same digit count\n            count += digit_count_map[current_count] * (digit_count_map[current_count] - 1) // 2\n            \n            # Update the map with the current digit count\n            digit_count_map[current_count] += 1\n        \n        return count",
      "solution_hash": "d585e0fcca47056a31ed060d7b652060ebd796a48b8eb67dc1f1a55e355045e5",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmptsakuhft.py\", line 299, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmptsakuhft.py\", line 163, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
        "execution_time": 0.06322503089904785
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_1",
          "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            # Convert to dictionaries for easier comparison\n            dict1 = dict(count1)\n            dict2 = dict(count2)\n            \n            # Calculate the differences in digit counts\n            diff = Counter()\n            for digit in set(dict1.keys()).union(set(dict2.keys())):\n                diff[digit] = abs(dict1.get(digit, 0) - dict2.get(digit, 0))\n            \n            # Count the total number of mismatches\n            mismatch_count = sum(diff.values())\n            \n            # Check if the mismatch can be resolved with at most 2 swaps\n            return mismatch_count <= 4 and max(diff.values()) <= 2\n        \n        digit_count_list = [get_digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(digit_count_list[i], digit_count_list[j]):\n                    count += 1\n        \n        return count",
          "solution_hash": "e1dd9c311d4dd278b85c8e8b4a1a77078bf3c6739e6e153937b9d1e27a9b1a83",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpd6g9zk2k.py\", line 253, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpd6g9zk2k.py\", line 119, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
            "execution_time": 0.06194329261779785
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_2",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        sorted_digit_list = [sort_digits(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                # Count the number of differing positions\n                diff_count = sum(1 for a, b in zip(sorted_digit_list[i], sorted_digit_list[j]) if a != b)\n                # Check if the numbers can be made almost equal with at most 2 swaps\n                if diff_count <= 2:\n                    count += 1\n        \n        return count",
              "solution_hash": "a74b068372626036cc8938c8fc7c39ecb698f716c44e236019a44b7a9ddd4f37",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpw1y7j0o7.py\", line 239, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpw1y7j0o7.py\", line 105, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06210637092590332
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_3",
              "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            # Convert to dictionaries for easier comparison\n            dict1 = dict(count1)\n            dict2 = dict(count2)\n            \n            # Calculate the differences in digit counts\n            diff = Counter()\n            for digit in set(dict1.keys()).union(set(dict2.keys())):\n                diff[digit] = abs(dict1.get(digit, 0) - dict2.get(digit, 0))\n            \n            # Count the total number of mismatches\n            mismatch_count = sum(diff.values())\n            \n            # Count the number of odd mismatches\n            odd_mismatches = sum(1 for count in diff.values() if count % 2 != 0)\n            \n            # Check if the mismatch can be resolved with at most 2 swaps\n            # We need at most 2 swaps, so the number of odd mismatches should be at most 2\n            # and the total mismatch count should allow for pairing\n            return mismatch_count <= 4 and odd_mismatches <= 2\n        \n        digit_count_list = [get_digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(digit_count_list[i], digit_count_list[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "4ab008d9bc9bbf48f0a32f27956232667110bf36a7eae584e204aed1593dc038",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpj7dv3jq0.py\", line 258, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpj7dv3jq0.py\", line 124, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06125140190124512
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_4",
              "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            # Convert to dictionaries for easier comparison\n            dict1 = dict(count1)\n            dict2 = dict(count2)\n            \n            # Calculate the differences in digit counts\n            diff = Counter()\n            for digit in set(dict1.keys()).union(set(dict2.keys())):\n                diff[digit] = abs(dict1.get(digit, 0) - dict2.get(digit, 0))\n            \n            # Count the total number of mismatches and the maximum difference\n            mismatch_count = sum(diff.values())\n            max_diff = max(diff.values())\n            \n            # Check if the mismatch can be resolved with at most 2 swaps\n            # We need to ensure that we can balance the differences with at most 2 swaps\n            # For example, if one number has 3 '1's and the other has 1 '1', we need 2 swaps to balance\n            # If there are more than 2 digits with non-zero differences, it's impossible with 2 swaps\n            non_zero_diffs = sum(1 for d in diff.values() if d > 0)\n            return non_zero_diffs <= 4 and max_diff <= 2\n        \n        digit_count_list = [get_digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(digit_count_list[i], digit_count_list[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "db29ef8d1c9dfef3f208d6804210794d46be8732ff331adc4e393414a3107103",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp2gi4q07g.py\", line 258, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp2gi4q07g.py\", line 124, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06300210952758789
              },
              "depth": 2,
              "parent_id": "1_1",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_5",
          "solution": "from collections import defaultdict\nfrom itertools import permutations\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_permutations(num):\n            num_str = str(num)\n            perm_set = set()\n            for perm in permutations(num_str):\n                perm_set.add(''.join(perm))\n            return perm_set\n        \n        perm_map = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            current_perms = get_permutations(num)\n            for perm in current_perms:\n                count += perm_map[perm]\n            \n            for perm in current_perms:\n                perm_map[perm] += 1\n        \n        return count",
          "solution_hash": "55270fc958d2b51561a7f17b8e2e45dd6f9c2f32b4b716611b63319053670784",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpyi6s7s38.py\", line 244, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpyi6s7s38.py\", line 108, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
            "execution_time": 0.0648353099822998
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_6",
              "solution": "from collections import Counter, defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        digit_count_map = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            current_count = get_digit_count(num)\n            for existing_count, existing_count_value in digit_count_map.items():\n                diff = sum(abs(a - b) for (a_digit, a), (b_digit, b) in zip(current_count, existing_count)) + abs(len(current_count) - len(existing_count))\n                if diff <= 4:  # Maximum difference in digit counts considering up to 2 swaps\n                    count += existing_count_value\n            \n            digit_count_map[current_count] += 1\n        \n        return count",
              "solution_hash": "8a4b82c67c692d6f928853335f1a5c0fdef4c7d504fbab3a6aef26acda2a8787",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp1l1z6yc0.py\", line 240, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp1l1z6yc0.py\", line 105, in check\n    assert candidate(nums = [1111, 2222, 3333, 4444]) == 0\nAssertionError\n",
                "execution_time": 0.06166267395019531
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_7",
              "solution": "from collections import Counter, defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count_map = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            digit_count = get_digit_count(num)\n            for key in count_map:\n                if self.can_be_almost_equal(digit_count, key):\n                    result += count_map[key]\n            count_map[digit_count] += 1\n        \n        return result\n    \n    def can_be_almost_equal(self, count1, count2):\n        diff = 0\n        i, j = 0, 0\n        while i < len(count1) and j < len(count2):\n            if count1[i][0] == count2[j][0]:\n                if abs(count1[i][1] - count2[j][1]) > 2:\n                    return False\n                diff += abs(count1[i][1] - count2[j][1])\n                i += 1\n                j += 1\n            elif count1[i][0] < count2[j][0]:\n                if count1[i][1] > 2:\n                    return False\n                diff += count1[i][1]\n                i += 1\n            else:\n                if count2[j][1] > 2:\n                    return False\n                diff += count2[j][1]\n                j += 1\n        \n        while i < len(count1):\n            if count1[i][1] > 2:\n                return False\n            diff += count1[i][1]\n            i += 1\n        \n        while j < len(count2):\n            if count2[j][1] > 2:\n                return False\n            diff += count2[j][1]\n            j += 1\n        \n        return diff <= 4",
              "solution_hash": "e0a4a2d69be3bdb4516fd52c25b65ec88ad5f89cdf3ac821f1d1e321cb03121d",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmprek9a_jv.py\", line 273, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmprek9a_jv.py\", line 139, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.05958247184753418
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_8",
              "solution": "from collections import Counter, defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count_map = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            digit_count = get_digit_count(num)\n            for key in count_map:\n                if self.can_be_almost_equal(digit_count, key):\n                    result += count_map[key]\n            count_map[digit_count] += 1\n        \n        return result\n    \n    def can_be_almost_equal(self, count1, count2):\n        diff = 0\n        i, j = 0, 0\n        while i < len(count1) and j < len(count2):\n            if count1[i][0] == count2[j][0]:\n                if abs(count1[i][1] - count2[j][1]) > 2:\n                    return False\n                diff += abs(count1[i][1] - count2[j][1])\n                i += 1\n                j += 1\n            elif count1[i][0] < count2[j][0]:\n                if count1[i][1] > 2:\n                    return False\n                diff += count1[i][1]\n                i += 1\n            else:\n                if count2[j][1] > 2:\n                    return False\n                diff += count2[j][1]\n                j += 1\n        \n        while i < len(count1):\n            if count1[i][1] > 2:\n                return False\n            diff += count1[i][1]\n            i += 1\n        \n        while j < len(count2):\n            if count2[j][1] > 2:\n                return False\n            diff += count2[j][1]\n            j += 1\n        \n        return diff <= 4",
              "solution_hash": "e0a4a2d69be3bdb4516fd52c25b65ec88ad5f89cdf3ac821f1d1e321cb03121d",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmprek9a_jv.py\", line 273, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmprek9a_jv.py\", line 139, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.05958247184753418
              },
              "depth": 2,
              "parent_id": "1_5",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_9",
          "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        digit_count_map = Counter()\n        count = 0\n        \n        for num in nums:\n            current_digits = get_sorted_digits(num)\n            current_count = digit_count_map[current_digits]\n            \n            # Check against all previously seen digit sequences\n            for seen_digits, seen_count in digit_count_map.items():\n                diff_count = sum((Counter(current_digits) | Counter(seen_digits)) - (Counter(current_digits) & Counter(seen_digits)))\n                if diff_count <= 2:\n                    count += seen_count\n            \n            # Update the map with the current digit sequence\n            digit_count_map[current_digits] += 1\n        \n        return count",
          "solution_hash": "36c34d552dbc18e5730ea87d86886b0ff8962a933fb2b43f3a3aa8434d6b2d04",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpnppgyene.py\", line 245, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpnppgyene.py\", line 110, in check\n    assert candidate(nums = [1111, 2222, 3333, 4444]) == 0\n  File \"/scratch/local/21419950/tmpnppgyene.py\", line 98, in countPairs\n    diff_count = sum((Counter(current_digits) | Counter(seen_digits)) - (Counter(current_digits) & Counter(seen_digits)))\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n",
            "execution_time": 0.060791969299316406
          },
          "depth": 1,
          "parent_id": "0_0",
          "children": [
            {
              "node_id": "2_10",
              "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_counts(num):\n            counts = [0] * 10\n            for digit in str(num):\n                counts[int(digit)] += 1\n            return tuple(counts)\n        \n        digit_count_map = Counter()\n        count = 0\n        \n        for num in nums:\n            current_counts = get_digit_counts(num)\n            \n            # Check against all previously seen digit sequences\n            for seen_counts, seen_count in digit_count_map.items():\n                diff_count = sum(abs(a - b) for a, b in zip(current_counts, seen_counts))\n                if diff_count // 2 <= 2:\n                    count += seen_count\n            \n            # Update the map with the current digit sequence\n            digit_count_map[current_counts] += 1\n        \n        return count",
              "solution_hash": "713497ad9a8a9d3e737188dccc3db67f5df2b5d5e1a0033c9d5b7b32e11fb9e8",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpxry3kked.py\", line 247, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpxry3kked.py\", line 113, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06207561492919922
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_11",
              "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(counter1, counter2):\n            diff = 0\n            all_digits = set(counter1.keys()).union(set(counter2.keys()))\n            for digit in all_digits:\n                if abs(counter1.get(digit, 0) - counter2.get(digit, 0)) > 1:\n                    diff += 1\n                if diff > 2:\n                    return False\n            return True\n        \n        digit_count_map = []\n        count = 0\n        \n        for num in nums:\n            current_counter = Counter(str(num))\n            for seen_counter in digit_count_map:\n                if can_be_almost_equal(current_counter, seen_counter):\n                    count += 1\n            digit_count_map.append(current_counter)\n        \n        return count",
              "solution_hash": "b318a80175cf99b34a40be80132c60a52726404b715b952ff7526e65873063ed",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpcl2tgr8d.py\", line 246, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpcl2tgr8d.py\", line 111, in check\n    assert candidate(nums = [1111, 2222, 3333, 4444]) == 0\nAssertionError\n",
                "execution_time": 0.06206822395324707
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_12",
              "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(num_str):\n            variations = {num_str}\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            return variations\n        \n        count = 0\n        num_variations = defaultdict(int)\n        \n        for num in nums:\n            num_str = str(num)\n            variations = generate_variations(num_str)\n            for variation in variations:\n                count += num_variations[variation]\n            for variation in variations:\n                num_variations[variation] += 1\n        \n        return count",
              "solution_hash": "49915555db426ca3a1beb993906884f1de05ed7369f69e807392165fefa70e17",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpzfeo7bwh.py\", line 247, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpzfeo7bwh.py\", line 111, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
                "execution_time": 0.0645744800567627
              },
              "depth": 2,
              "parent_id": "1_9",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variations(num_str):\n            variations = set([num_str])\n            n = len(num_str)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n                    for k in range(j + 1, n):\n                        swapped2 = list(swapped)\n                        swapped2[j], swapped2[k] = swapped2[k], swapped2[j]\n                        variations.add(''.join(swapped2))\n            return variations\n        \n        num_map = defaultdict(int)\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                num_map[tuple(sorted(variation))] += 1\n        \n        count = 0\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                count += num_map[tuple(sorted(variation))]\n            num_map[tuple(sorted(num_str))] -= 1\n        \n        return count // 2",
      "solution_hash": "ad09319673bbad823502b8aaa4a75d8e65cd12e164791bd606fb68e6a710ee0f",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpck94k5ao.py\", line 252, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpck94k5ao.py\", line 116, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
        "execution_time": 0.060903310775756836
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_14",
          "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_pattern(num):\n            # Convert number to string, sort the digits, and count occurrences\n            digit_count = [0] * 10\n            for digit in str(num):\n                digit_count[int(digit)] += 1\n            return tuple(digit_count)\n        \n        # Count the frequency of each digit pattern\n        pattern_count = Counter(get_digit_pattern(num) for num in nums)\n        \n        count = 0\n        for pattern in pattern_count:\n            freq = pattern_count[pattern]\n            # Choose 2 out of freq numbers to form a pair\n            count += freq * (freq - 1) // 2\n        \n        return count",
          "solution_hash": "30ace85bcc608b6b79f922014fb2684c84aa05f639e691eaaa7062f5f1fb01d5",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp9ulcn1v9.py\", line 242, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp9ulcn1v9.py\", line 110, in check\n    assert candidate(nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]) == 4\nAssertionError\n",
            "execution_time": 0.06234097480773926
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_15",
              "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_digit_pattern(num):\n            # Convert number to string and count occurrences of each digit\n            return Counter(str(num))\n        \n        def can_be_almost_equal(pattern1, pattern2):\n            # Calculate the difference in digit counts\n            diff = Counter()\n            for digit in set(pattern1.keys()).union(set(pattern2.keys())):\n                diff[digit] = abs(pattern1[digit] - pattern2[digit])\n            \n            # Sum of differences should be 4 or less for at most 2 swaps\n            return sum(diff.values()) <= 4\n        \n        patterns = [get_digit_pattern(num) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        # Compare each pair of numbers\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(patterns[i], patterns[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "6842e584a6147ae06d5ac67162c92dc44cca63b6df43ca1f1906fb93ca5b1225",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp4cod_dh2.py\", line 249, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp4cod_dh2.py\", line 115, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06323695182800293
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_16",
              "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_almost_equal(num1, num2):\n            count1 = Counter(str(num1))\n            count2 = Counter(str(num2))\n            \n            diff_count = 0\n            for digit in set(count1.keys()).union(set(count2.keys())):\n                diff = abs(count1[digit] - count2[digit])\n                if diff > 2:\n                    return False\n                diff_count += diff\n            \n            # We can fix at most 4 mismatches with 2 swaps\n            return diff_count <= 4\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(nums[i], nums[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "1d0a320925cd9d7d0f7ba1376aaa2725e3a51df178795b165b062a42b146bdbb",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpqcvdihxh.py\", line 247, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpqcvdihxh.py\", line 113, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.061576128005981445
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_17",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_sorted_digits(num):\n            # Convert number to string, sort the digits, and return as a tuple\n            return tuple(sorted(str(num)))\n        \n        # Dictionary to count occurrences of each sorted digit sequence\n        sorted_digit_count = {}\n        \n        for num in nums:\n            sorted_digits = get_sorted_digits(num)\n            if sorted_digits in sorted_digit_count:\n                sorted_digit_count[sorted_digits] += 1\n            else:\n                sorted_digit_count[sorted_digits] = 1\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                # Compare sorted digit sequences of nums[i] and nums[j]\n                sorted_i = get_sorted_digits(nums[i])\n                sorted_j = get_sorted_digits(nums[j])\n                \n                # Count the number of differing positions\n                diff_count = sum(1 for a, b in zip(sorted_i, sorted_j) if a != b)\n                \n                # Check if they can be made equal with at most two swaps\n                if diff_count <= 2:\n                    count += 1\n        \n        return count",
              "solution_hash": "70069e28151643a8669c94341594b3b943b2f9de82fdb1d45e8b83e0c8277ad4",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpuhr2k2vs.py\", line 255, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpuhr2k2vs.py\", line 121, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06505179405212402
              },
              "depth": 2,
              "parent_id": "1_14",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_18",
          "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            num_tuple = digit_count(num)\n            for i in range(10):\n                for j in range(i, 10):\n                    # Try changing the count of digit i by -1 and digit j by +1\n                    new_tuple = list(num_tuple)\n                    new_tuple = [(d, c - (1 if d == i else 0) + (1 if d == j else 0)) for d, c in new_tuple]\n                    new_tuple = [(d, c) for d, c in new_tuple if c > 0]\n                    count += seen[tuple(sorted(new_tuple))]\n                    \n                    # If i != j, also try changing the count of digit i by +1 and digit j by -1\n                    if i != j:\n                        new_tuple = list(num_tuple)\n                        new_tuple = [(d, c + (1 if d == i else 0) - (1 if d == j else 0)) for d, c in new_tuple]\n                        new_tuple = [(d, c) for d, c in new_tuple if c > 0]\n                        count += seen[tuple(sorted(new_tuple))]\n            \n            # Also consider the original number itself\n            count += seen[num_tuple]\n            seen[num_tuple] += 1\n        \n        return count",
          "solution_hash": "3e0442abcb11b721f590013961e20e41cc799a6138a1dbbeac1309d75adc4507",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmphkmyupq3.py\", line 253, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmphkmyupq3.py\", line 117, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
            "execution_time": 0.06137704849243164
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_19",
              "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_tuple(num):\n            return tuple(sorted(str(num)))\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            num_tuple = digit_tuple(num)\n            # Check all possible tuples that can be formed by up to 2 swaps\n            for i in range(len(num_tuple)):\n                for j in range(i + 1, len(num_tuple)):\n                    # Swap i and j\n                    swapped_tuple = list(num_tuple)\n                    swapped_tuple[i], swapped_tuple[j] = swapped_tuple[j], swapped_tuple[i]\n                    swapped_tuple = tuple(swapped_tuple)\n                    count += seen[swapped_tuple]\n                    \n                    # Perform a second swap\n                    for k in range(len(num_tuple)):\n                        for l in range(k + 1, len(num_tuple)):\n                            if k != i and k != j and l != i and l != j:\n                                double_swapped_tuple = list(swapped_tuple)\n                                double_swapped_tuple[k], double_swapped_tuple[l] = double_swapped_tuple[l], double_swapped_tuple[k]\n                                double_swapped_tuple = tuple(double_swapped_tuple)\n                                count += seen[double_swapped_tuple]\n            \n            # Count the original number itself\n            count += seen[num_tuple]\n            seen[num_tuple] += 1\n        \n        return count",
              "solution_hash": "70126f81c9fe0ea87481cdded35f98c85461601041d632135fdd37c4247e2cb5",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpm8s0so_1.py\", line 256, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpm8s0so_1.py\", line 124, in check\n    assert candidate(nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]) == 4\nAssertionError\n",
                "execution_time": 0.06257009506225586
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_20",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def generate_variations(count):\n            variations = set([count])\n            digits = sorted(count.keys())\n            n = len(digits)\n            \n            # Single swap variations\n            for i in range(n):\n                for j in range(i, n):\n                    if count[digits[i]] > 0 and count[digits[j]] > 0:\n                        new_count = dict(count)\n                        new_count[digits[i]] -= 1\n                        new_count[digits[j]] += 1\n                        variations.add(tuple(sorted(new_count.items())))\n            \n            # Double swap variations\n            for i in range(n):\n                for j in range(i, n):\n                    if count[digits[i]] > 0 and count[digits[j]] > 0:\n                        for k in range(n):\n                            for l in range(k, n):\n                                if count[digits[k]] > 0 and count[digits[l]] > 0:\n                                    new_count = dict(count)\n                                    new_count[digits[i]] -= 1\n                                    new_count[digits[j]] += 1\n                                    new_count[digits[k]] -= 1\n                                    new_count[digits[l]] += 1\n                                    variations.add(tuple(sorted(new_count.items())))\n            \n            return variations\n        \n        count = 0\n        seen = defaultdict(int)\n        \n        for num in nums:\n            num_tuple = digit_count(num)\n            variations = generate_variations(num_tuple)\n            for variation in variations:\n                count += seen[variation]\n            seen[num_tuple] += 1\n        \n        return count",
              "solution_hash": "83073e9b601079f12bb08797bfc4fdcbdf691db598b2414596c069aeac5d60de",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpdebmllem.py\", line 269, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpdebmllem.py\", line 133, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\n  File \"/scratch/local/21419950/tmpdebmllem.py\", line 124, in countPairs\n    variations = generate_variations(num_tuple)\n  File \"/scratch/local/21419950/tmpdebmllem.py\", line 91, in generate_variations\n    digits = sorted(count.keys())\nAttributeError: 'tuple' object has no attribute 'keys'\n",
                "execution_time": 0.0614931583404541
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_21",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(count1, count2):\n            diff = defaultdict(int)\n            for d, c in count1:\n                diff[d] += c\n            for d, c in count2:\n                diff[d] -= c\n            \n            changes = 0\n            for c in diff.values():\n                changes += abs(c)\n            \n            # We can make up to 4 changes (2 swaps) to match the counts\n            return changes // 2 <= 2\n        \n        count = 0\n        n = len(nums)\n        digit_counts = [digit_count(num) for num in nums]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_almost_equal(digit_counts[i], digit_counts[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "6d336b1c7ae4ad64c491bd1a9192ca4ee4a5c96def5331d3643bceb16571c5a8",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpe94ubkaj.py\", line 252, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpe94ubkaj.py\", line 118, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06107354164123535
              },
              "depth": 2,
              "parent_id": "1_18",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_22",
          "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sort_digits(num):\n            return tuple(sorted(str(num)))\n        \n        num_count = defaultdict(int)\n        count = 0\n        \n        for num in nums:\n            sorted_num = sort_digits(num)\n            count += num_count[sorted_num]\n            num_count[sorted_num] += 1\n        \n        return count",
          "solution_hash": "cc86f21b4d37c5672f813134523c0f7522942a2ac115d7c0ad7ad8013bc3e3d0",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp2rezvng2.py\", line 237, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp2rezvng2.py\", line 105, in check\n    assert candidate(nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]) == 4\nAssertionError\n",
            "execution_time": 0.06063723564147949
          },
          "depth": 1,
          "parent_id": "0_1",
          "children": [
            {
              "node_id": "2_23",
              "solution": "from typing import List\nfrom itertools import combinations\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(num_str):\n            variations = {num_str}\n            n = len(num_str)\n            for i, j in combinations(range(n), 2):\n                swapped = list(num_str)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                variations.add(''.join(swapped))\n                for k, l in combinations(range(n), 2):\n                    if k != i and k != j and l != i and l != j:\n                        double_swapped = list(swapped)\n                        double_swapped[k], double_swapped[l] = double_swapped[l], double_swapped[k]\n                        variations.add(''.join(double_swapped))\n            return variations\n        \n        num_variations = [generate_variations(str(num)) for num in nums]\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if num_variations[i].intersection(num_variations[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "5cc5997933f9d2890ec202310e31dee36f5f250fef7caeceb33cceeb4864dd08",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpvv152u_w.py\", line 249, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpvv152u_w.py\", line 117, in check\n    assert candidate(nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]) == 4\nAssertionError\n",
                "execution_time": 0.06357383728027344
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_24",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return Counter(str(num))\n        \n        def can_be_almost_equal(count1, count2):\n            diff = 0\n            all_digits = set(count1.keys()).union(set(count2.keys()))\n            for digit in all_digits:\n                diff += abs(count1[digit] - count2[digit])\n            return diff <= 4\n        \n        num_counts = [digit_count(num) for num in nums]\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if can_be_almost_equal(num_counts[i], num_counts[j]):\n                    count += 1\n        \n        return count",
              "solution_hash": "2995f4412411f6a4d42d819f14f8bed0064fd3f345dc5ca04c0891df43214ecd",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp5rq0anje.py\", line 244, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp5rq0anje.py\", line 110, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.06168198585510254
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_25",
              "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variations(num_str):\n            n = len(num_str)\n            variations = set()\n            # No swap\n            variations.add(num_str)\n            # One swap\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variations.add(''.join(swapped))\n            # Two swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    for k in range(n):\n                        if k != i and k != j:\n                            for l in range(k + 1, n):\n                                if l != i and l != j:\n                                    swapped = list(num_str)\n                                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                                    swapped[k], swapped[l] = swapped[l], swapped[k]\n                                    variations.add(''.join(swapped))\n            return variations\n        \n        num_variations = defaultdict(set)\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                num_variations[variation].add(num_str)\n        \n        count = 0\n        seen = set()\n        for num in nums:\n            num_str = str(num)\n            for variation in generate_variations(num_str):\n                for other_num_str in num_variations[variation]:\n                    if other_num_str != num_str and (num_str, other_num_str) not in seen and (other_num_str, num_str) not in seen:\n                        seen.add((num_str, other_num_str))\n                        count += 1\n        \n        return count",
              "solution_hash": "c6593f65eeb102886a5bc08c6b796bdb9269614c113c3338021430c3327f4ad5",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpgvjqjhvc.py\", line 266, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpgvjqjhvc.py\", line 134, in check\n    assert candidate(nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]) == 4\nAssertionError\n",
                "execution_time": 0.06584548950195312
              },
              "depth": 2,
              "parent_id": "1_22",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Function to create a canonical form of a number by sorting its digits\n        def canonical_form(num):\n            return tuple(sorted(str(num)))\n        \n        # Dictionary to count occurrences of each canonical form\n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = canonical_form(num)\n            # Check all possible forms that can be obtained by changing up to 2 digits\n            for i in range(10):\n                for j in range(10):\n                    for k in range(len(form)):\n                        new_form = list(form)\n                        new_form[k] = str(i)\n                        new_form = tuple(sorted(new_form))\n                        result += count[new_form]\n                        if i != j:\n                            for l in range(k + 1, len(form)):\n                                new_form2 = list(new_form)\n                                new_form2[l] = str(j)\n                                new_form2 = tuple(sorted(new_form2))\n                                result += count[new_form2]\n            count[form] += 1\n        \n        return result",
      "solution_hash": "1d285de0e963e0c98a8b5ed0631c048caca7237d87dcfe3b24449368cdc225b2",
      "test_result": {
        "status": "fail",
        "error_message": "Test execution failed with return code 1",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpvur2y4g0.py\", line 251, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpvur2y4g0.py\", line 115, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
        "execution_time": 0.061757564544677734
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        {
          "node_id": "1_27",
          "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for key in count:\n                if self.almost_equal(form, key):\n                    result += count[key]\n            count[form] += 1\n        \n        return result\n    \n    def almost_equal(self, counter1, counter2):\n        if len(counter1) != len(counter2):\n            return False\n        diff = 0\n        for (d1, c1), (d2, c2) in zip(counter1, counter2):\n            if d1 != d2:\n                return False\n            diff += abs(c1 - c2)\n            if diff > 2:\n                return False\n        return True",
          "solution_hash": "58c7b9487ea80f45a7086a48431af556247bf0857675f3b40b6765a5bc4e21f0",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp4sa2qja_.py\", line 251, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp4sa2qja_.py\", line 119, in check\n    assert candidate(nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]) == 4\nAssertionError\n",
            "execution_time": 0.06285452842712402
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_28",
              "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = {}\n        result = 0\n        \n        for num in nums:\n            form = sorted_digits(num)\n            for key in count:\n                if self.almost_equal(form, key):\n                    result += count[key]\n            if form in count:\n                count[form] += 1\n            else:\n                count[form] = 1\n        \n        return result\n    \n    def almost_equal(self, sorted1, sorted2):\n        if len(sorted1) != len(sorted2):\n            return False\n        diff = 0\n        for d1, d2 in zip(sorted1, sorted2):\n            if d1 != d2:\n                diff += 1\n            if diff > 2:\n                return False\n        return True",
              "solution_hash": "47aebf6cbb8bdc2695f4ec867c0ac92d1afd3515a17e5bdb045906204562ea29",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpt92fu8x8.py\", line 252, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpt92fu8x8.py\", line 118, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.061823129653930664
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_29",
              "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = sorted_digits(num)\n            for existing_form in count:\n                if self.almost_equal(form, existing_form):\n                    result += count[existing_form]\n            count[form] += 1\n        \n        return result\n    \n    def almost_equal(self, form1, form2):\n        if len(form1) != len(form2):\n            return False\n        diff = sum(f1 != f2 for f1, f2 in zip(form1, form2))\n        return diff <= 2",
              "solution_hash": "fffeccca35293bd45a551a474e26a463dda867db8d74c338f9298d2a0dd7de35",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmplq7szs8a.py\", line 245, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmplq7szs8a.py\", line 111, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.061120033264160156
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_30",
              "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def sorted_digits(num):\n            return tuple(sorted(str(num)))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = sorted_digits(num)\n            for key in count:\n                if self.almost_equal(form, key):\n                    result += count[key]\n            count[form] += 1\n        \n        return result\n    \n    def almost_equal(self, sorted1, sorted2):\n        if len(sorted1) != len(sorted2):\n            return False\n        diff = 0\n        for d1, d2 in zip(sorted1, sorted2):\n            if d1 != d2:\n                diff += 1\n                if diff > 2:\n                    return False\n        return True",
              "solution_hash": "d9178cc024be4cc85871f6ffe8fe2d5eb923bb80ada4e2247857041b6fc1e479",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpm4eo0sas.py\", line 250, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpm4eo0sas.py\", line 116, in check\n    assert candidate(nums = [12, 21, 13, 31, 23, 32]) == 3\nAssertionError\n",
                "execution_time": 0.061630964279174805
              },
              "depth": 2,
              "parent_id": "1_27",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_31",
          "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for i in range(10):\n                for j in range(i, 10):\n                    # Create a new form by adding or removing one occurrence of digit i and j\n                    new_form = list(form)\n                    new_form.append((str(i), 1))\n                    new_form.append((str(j), 1))\n                    new_form.sort()\n                    result += count[tuple(new_form)]\n                    \n                    if i != j:\n                        new_form2 = list(form)\n                        new_form2.append((str(i), 1))\n                        new_form2.append((str(j), -1))\n                        new_form2.sort()\n                        result += count[tuple(new_form2)]\n                        \n                        new_form3 = list(form)\n                        new_form3.append((str(i), -1))\n                        new_form3.append((str(j), 1))\n                        new_form3.sort()\n                        result += count[tuple(new_form3)]\n                        \n                        new_form4 = list(form)\n                        new_form4.append((str(i), -1))\n                        new_form4.append((str(j), -1))\n                        new_form4.sort()\n                        result += count[tuple(new_form4)]\n            \n            count[form] += 1\n        \n        return result",
          "solution_hash": "1f8cbeea432224769777c34a697fad8b802877becfbc1264765272727e27717f",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpfx76n4gv.py\", line 264, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpfx76n4gv.py\", line 128, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
            "execution_time": 0.06715846061706543
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_32",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for i in range(len(form)):\n                for j in range(i, len(form)):\n                    # Create a new form by reducing the count of the i-th and j-th digits\n                    new_form = list(form)\n                    new_form[i] = (new_form[i][0], new_form[i][1] - 1)\n                    if new_form[i][1] == 0:\n                        new_form.pop(i)\n                    else:\n                        new_form = tuple(new_form)\n                    \n                    if i != j:\n                        new_form_j = list(new_form)\n                        new_form_j[j] = (new_form_j[j][0], new_form_j[j][1] - 1)\n                        if new_form_j[j][1] == 0:\n                            new_form_j.pop(j)\n                        new_form_j = tuple(new_form_j)\n                        result += count[new_form_j]\n                    \n                    result += count[new_form]\n            \n            count[form] += 1\n        \n        return result",
              "solution_hash": "abd763db7906bcc39e6f549861ccc74db7acc86345d3d6a92a8a0d69e53e3305",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpbzoajrnr.py\", line 256, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpbzoajrnr.py\", line 120, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\n  File \"/scratch/local/21419950/tmpbzoajrnr.py\", line 112, in countPairs\n    result += count[new_form]\nTypeError: unhashable type: 'list'\n",
                "execution_time": 0.06171298027038574
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_33",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            for i in range(len(form)):\n                for j in range(i, len(form)):\n                    # Create a new form by reducing the count of digit i and j by 1\n                    new_form = list(form)\n                    new_form[i] = (new_form[i][0], new_form[i][1] - 1)\n                    if new_form[i][1] == 0:\n                        new_form.pop(i)\n                    else:\n                        new_form = tuple(new_form)\n                    \n                    if i != j:\n                        new_form2 = list(new_form)\n                        if j > i:\n                            j -= 1\n                        new_form2[j] = (new_form2[j][0], new_form2[j][1] - 1)\n                        if new_form2[j][1] == 0:\n                            new_form2.pop(j)\n                        new_form2 = tuple(new_form2)\n                    else:\n                        new_form2 = new_form\n                    \n                    result += count[new_form]\n                    if i != j:\n                        result += count[new_form2]\n            \n            count[form] += 1\n        \n        return result",
              "solution_hash": "2816208fe8445be3a1790e82d31d668cedd9d5097864d82b9724316f8902e3f2",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpoojocxom.py\", line 261, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpoojocxom.py\", line 125, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\n  File \"/scratch/local/21419950/tmpoojocxom.py\", line 115, in countPairs\n    result += count[new_form]\nTypeError: unhashable type: 'list'\n",
                "execution_time": 0.0607447624206543
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_34",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            str_num = str(num)\n            n = len(str_num)\n            \n            # Check all pairs of indices for swapping\n            for i in range(n):\n                for j in range(i + 1, n):\n                    # Swap digits at positions i and j\n                    swapped_str = str_num[:i] + str_num[j] + str_num[i+1:j] + str_num[i] + str_num[j+1:]\n                    swapped_form = digit_count(swapped_str)\n                    result += count[swapped_form]\n                    \n                    # Perform a second swap if possible\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if k != i and k != j and l != i and l != j:\n                                second_swapped_str = swapped_str[:k] + swapped_str[l] + swapped_str[k+1:l] + swapped_str[k] + swapped_str[l+1:]\n                                second_swapped_form = digit_count(second_swapped_str)\n                                result += count[second_swapped_form]\n            \n            count[form] += 1\n        \n        return result",
              "solution_hash": "e5e2bf9421981cdba11a69b394fea2a34b3d00b19092cdb5f1ffa0f3f496b428",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpli7qr04f.py\", line 255, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpli7qr04f.py\", line 119, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
                "execution_time": 0.06135106086730957
              },
              "depth": 2,
              "parent_id": "1_31",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        },
        {
          "node_id": "1_35",
          "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            # Check all possible forms that can be obtained by changing up to 2 digits\n            for i in range(10):\n                for j in range(10):\n                    # Create a new form by adding or removing one digit\n                    new_form = list(form)\n                    new_form.append((str(i), 1))\n                    new_form.sort()\n                    new_form = tuple(new_form)\n                    result += count[new_form]\n                    \n                    if i != j:\n                        # Create another new form by adding or removing two different digits\n                        new_form2 = list(new_form)\n                        new_form2.append((str(j), 1))\n                        new_form2.sort()\n                        new_form2 = tuple(new_form2)\n                        result += count[new_form2]\n            \n            # Update the count of the current form\n            count[form] += 1\n        \n        return result",
          "solution_hash": "eb79584deccb8137e20cf7af22d4429fa6c7fe54a3a23688d22a654c05f74626",
          "test_result": {
            "status": "fail",
            "error_message": "Test execution failed with return code 1",
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpc9jgbs0b.py\", line 255, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpc9jgbs0b.py\", line 119, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
            "execution_time": 0.06523585319519043
          },
          "depth": 1,
          "parent_id": "0_2",
          "children": [
            {
              "node_id": "2_36",
              "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        def can_be_almost_equal(form1, form2):\n            if len(form1) != len(form2):\n                return False\n            \n            diff_count = 0\n            i, j = 0, 0\n            \n            while i < len(form1) and j < len(form2):\n                if form1[i] == form2[j]:\n                    i += 1\n                    j += 1\n                else:\n                    if form1[i][1] > form2[j][1]:\n                        diff_count += form1[i][1] - form2[j][1]\n                        i += 1\n                    elif form1[i][1] < form2[j][1]:\n                        diff_count += form2[j][1] - form1[i][1]\n                        j += 1\n                    else:\n                        i += 1\n                        j += 1\n                    \n                    if diff_count > 2:\n                        return False\n            \n            diff_count += abs(len(form1) - i) + abs(len(form2) - j)\n            return diff_count <= 2\n        \n        counts = [digit_count(num) for num in nums]\n        result = 0\n        \n        for i in range(len(counts)):\n            for j in range(i + 1, len(counts)):\n                if can_be_almost_equal(counts[i], counts[j]):\n                    result += 1\n        \n        return result",
              "solution_hash": "2f0a58905a7f553c198c58c4b2545afb5fb26bb3ba0a5ce051480933a34f8765",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp1m08egxm.py\", line 265, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp1m08egxm.py\", line 130, in check\n    assert candidate(nums = [1111, 2222, 3333, 4444]) == 0\nAssertionError\n",
                "execution_time": 0.06193423271179199
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_37",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\nfrom itertools import permutations\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            digits = str(num)\n            variants = set()\n            # Generate all permutations of the digits\n            for perm in permutations(digits):\n                # Join the tuple of characters into a string and convert to integer\n                variant = int(''.join(perm))\n                variants.add(variant)\n            # Include up to 2 swaps by considering subsets of permutations\n            for i in range(len(digits)):\n                for j in range(i + 1, len(digits)):\n                    swapped_digits = list(digits)\n                    swapped_digits[i], swapped_digits[j] = swapped_digits[j], swapped_digits[i]\n                    swapped_num = int(''.join(swapped_digits))\n                    variants.add(swapped_num)\n                    for k in range(len(digits)):\n                        for l in range(k + 1, len(digits)):\n                            if k != i and k != j and l != i and l != j:\n                                double_swapped_digits = list(swapped_digits)\n                                double_swapped_digits[k], double_swapped_digits[l] = double_swapped_digits[l], double_swapped_digits[k]\n                                double_swapped_num = int(''.join(double_swapped_digits))\n                                variants.add(double_swapped_num)\n            return variants\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            variants = generate_variants(num)\n            for variant in variants:\n                result += count[variant]\n            count[num] += 1\n        \n        return result",
              "solution_hash": "e8ccd7acd8d8e0bb00428454399b9af3eaeec6758c269ddf3f6af217a17a95ca",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmpz07w91db.py\", line 260, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmpz07w91db.py\", line 128, in check\n    assert candidate(nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]) == 4\nAssertionError\n",
                "execution_time": 0.06168651580810547
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            },
            {
              "node_id": "2_38",
              "solution": "from collections import Counter, defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def digit_count(num):\n            return tuple(sorted(Counter(str(num)).items()))\n        \n        count = defaultdict(int)\n        result = 0\n        \n        for num in nums:\n            form = digit_count(num)\n            # Check all possible forms that can be obtained by changing up to 2 digits\n            for i in range(len(form)):\n                for j in range(i, len(form)):\n                    # Remove one digit\n                    new_form1 = form[:i] + form[i+1:]\n                    result += count[new_form1]\n                    \n                    # Remove two digits\n                    for k in range(j+1, len(form)):\n                        new_form2 = form[:i] + form[i+1:j] + form[j+1:k] + form[k+1:]\n                        result += count[new_form2]\n            \n            # Check if the form itself has been seen before\n            result += count[form]\n            \n            # Update the count of the current form\n            count[form] += 1\n        \n        # Each pair is counted twice, so we divide by 2\n        return result // 2",
              "solution_hash": "1858edda2995c08d4219c3d56b5e316738c0b31cfed7b539da2ed31b34c8652f",
              "test_result": {
                "status": "fail",
                "error_message": "Test execution failed with return code 1",
                "stdout": "",
                "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21419950/tmp6d1fl57n.py\", line 253, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21419950/tmp6d1fl57n.py\", line 117, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n",
                "execution_time": 0.06222200393676758
              },
              "depth": 2,
              "parent_id": "1_35",
              "children": [],
              "passed": false
            }
          ],
          "passed": false
        }
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 39,
    "candidates_generated": 39,
    "tests_passed": 0,
    "tests_failed": 39,
    "test_errors": 0,
    "execution_times": [],
    "tree_depth": 0
  },
  "processing_time": 895.6620199680328,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.025000000000000022,
      "pass@3": 0.07499999999999996,
      "pass@5": 0.125,
      "pass@10": 0.25
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unsupported operand type(s) for +: 'int' and 'str'",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: 'tuple' object has no attribute 'keys'",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unhashable type: 'list'",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unhashable type: 'list'",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 37
          }
        ],
        [
          38,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 38
          }
        ],
        [
          39,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 39
          }
        ]
      ]
    },
    "solutions_evaluated": 40,
    "test_cases": 1
  }
}