{
  "problem_id": "find-the-count-of-monotonic-pairs-ii",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                max_sum = sum(nums)\n                # Initialize dp arrays\n                dp1 = [0] * (max_sum + 1)\n                dp2 = [0] * (max_sum + 1)\n                # Initialize for the first element\n                for a1 in range(nums[0] + 1):\n                    a2 = nums[0] - a1\n                    dp1[a1] += 1\n                    dp2[a2] += 1\n                # Iterate through the rest of the elements\n                for i in range(1, n):\n                    new_dp1 = [0] * (max_sum + 1)\n                    new_dp2 = [0] * (max_sum + 1)\n                    for a1 in range(nums[i] + 1):\n                        a2 = nums[i] - a1\n                        if a1 >= dp1[i-1]:\n                            new_dp1[a1] = (new_dp1[a1] + dp1[a1]) % MOD\n                        if a2 <= dp2[i-1]:\n                            new_dp2[a2] = (new_dp2[a2] + dp2[a2]) % MOD\n                    dp1 = new_dp1\n                    dp2 = new_dp2\n                # The total count is the sum of products of dp1 and dp2 for all possible sums\n                total = 0\n                for a1 in range(max_sum + 1):\n                    for a2 in range(max_sum + 1):\n                        if a1 + a2 == nums[-1]:\n                            total = (total + dp1[a1] * dp2[a2]) % MOD\n                return total",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                # Initialize prefix arrays for arr1 and arr2\n                prefix_max_arr1 = [0] * n\n                prefix_min_arr2 = [nums[0]] * n\n                # Forward pass to compute prefix constraints\n                max_arr1 = 0\n                min_arr2 = nums[0]\n                for i in range(n):\n                    max_arr1 = min(max_arr1, nums[i] - min_arr2)\n                    min_arr2 = nums[i] - max_arr1\n                    prefix_max_arr1[i] = max_arr1\n                    prefix_min_arr2[i] = min_arr2\n                # Initialize suffix arrays for arr1 and arr2\n                suffix_min_arr1 = [nums[-1]] * n\n                suffix_max_arr2 = [0] * n\n                # Backward pass to compute suffix constraints\n                min_arr1 = nums[-1]\n                max_arr2 = 0\n                for i in range(n-1, -1, -1):\n                    min_arr1 = max(min_arr1, nums[i] - max_arr2)\n                    max_arr2 = nums[i] - min_arr1\n                    suffix_min_arr1[i] = min_arr1\n                    suffix_max_arr2[i] = max_arr2\n                # Calculate the number of valid pairs\n                total = 1\n                for i in range(n):\n                    low_arr1 = max(prefix_max_arr1[i], suffix_min_arr1[i] - nums[i])\n                    high_arr1 = min(suffix_min_arr1[i], nums[i] - prefix_min_arr2[i])\n                    count = high_arr1 - low_arr1 + 1\n                    if count < 0:\n                        return 0\n                    total = (total * count) % MOD\n                return total",
    "from typing import List\n\n        class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                if n == 0:\n                    return 1  # Edge case: empty array\n\n                # Initialize dp arrays\n                dp_arr1 = [0] * n\n                dp_arr2 = [0] * n\n\n                # Initialize the first position\n                dp_arr1[0] = nums[0] + 1  # arr1[0] can be from 0 to nums[0]\n                dp_arr2[0] = nums[0] + 1  # arr2[0] can be from 0 to nums[0]\n\n                # Forward pass for arr1 (non-decreasing)\n                for i in range(1, n):\n                    min_arr1 = max(0, nums[i] - dp_arr2[i-1])\n                    max_arr1 = nums[i]\n                    dp_arr1[i] = max_arr1 - min_arr1 + 1\n                    if dp_arr1[i] < 0:\n                        return 0  # No valid pairs\n\n                # Backward pass for arr2 (non-increasing)\n                for i in range(n-2, -1, -1):\n                    min_arr2 = max(0, nums[i] - dp_arr1[i+1])\n                    max_arr2 = nums[i]\n                    dp_arr2[i] = max_arr2 - min_arr2 + 1\n                    if dp_arr2[i] < 0:\n                        return 0  # No valid pairs\n\n                # Calculate the total number of valid pairs\n                total = 1\n                for i in range(n):\n                    low_arr1 = max(0, nums[i] - dp_arr2[i])\n                    high_arr1 = min(nums[i], dp_arr1[i] - 1)\n                    count = high_arr1 - low_arr1 + 1\n                    if count < 0:\n                        return 0\n                    total = (total * count) % MOD\n\n                return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize dp arrays\n        dp1 = [0] * n\n        dp2 = [0] * n\n        \n        # Initialize the first element\n        dp1[0] = 1  # arr1 can be from 0 to nums[0]\n        dp2[0] = nums[0] + 1  # arr2 can be from 0 to nums[0]\n        \n        # Forward pass\n        for i in range(1, n):\n            # arr1[i] can be from arr1[i-1] to nums[i] - arr2[i-1]\n            # arr2[i] is determined by nums[i] - arr1[i]\n            min_arr1 = dp1[i-1]\n            max_arr1 = nums[i]\n            if i >= 1:\n                max_arr1 = min(max_arr1, nums[i] - 0)\n                min_arr1 = max(min_arr1, nums[i] - dp2[i-1])\n            dp1[i] = max_arr1 - min_arr1 + 1\n            dp2[i] = dp1[i]\n        \n        # Backward pass to ensure arr2 is non-increasing\n        dp3 = [0] * n\n        dp4 = [0] * n\n        dp3[-1] = 1  # arr2 can be from 0 to nums[-1]\n        dp4[-1] = nums[-1] + 1  # arr1 can be from 0 to nums[-1]\n        \n        for i in range(n-2, -1, -1):\n            # arr2[i] can be from arr2[i+1] to nums[i] - arr1[i+1]\n            # arr1[i] is determined by nums[i] - arr2[i]\n            min_arr2 = dp3[i+1]\n            max_arr2 = nums[i]\n            if i <= n-2:\n                max_arr2 = min(max_arr2, nums[i] - 0)\n                min_arr2 = max(min_arr2, nums[i] - dp4[i+1])\n            dp3[i] = max_arr2 - min_arr2 + 1\n            dp4[i] = dp3[i]\n        \n        # Calculate the total number of valid pairs\n        total = 1\n        for i in range(n):\n            # The number of valid arr1[i] at position i is the intersection\n            # of the forward and backward constraints\n            low = max(dp1[i], nums[i] - dp4[i])\n            high = min(nums[i] - dp3[i], dp2[i])\n            count = max(0, high - low + 1)\n            total = (total * count) % MOD\n        \n        return total",
    "from typing import List\n\n        class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                if n == 0:\n                    return 0\n                # Initialize dp arrays\n                dp = [1] * n  # Number of ways to form arr1 and arr2 up to index i\n                # Initialize the minimum and maximum possible values for arr1[i]\n                min_arr1 = [0] * n\n                max_arr1 = [nums[0]] * n\n                # Forward pass\n                for i in range(1, n):\n                    # arr1[i] must be >= arr1[i-1] and arr1[i] <= nums[i]\n                    # arr2[i] must be <= arr2[i-1] and arr2[i] >= 0\n                    # Since arr1[i] + arr2[i] == nums[i], and arr2[i] <= arr2[i-1]\n                    # arr1[i] >= arr1[i-1] and arr1[i] <= nums[i]\n                    # arr2[i] <= arr2[i-1] => nums[i] - arr1[i] <= arr2[i-1]\n                    # arr1[i] >= nums[i] - arr2[i-1]\n                    # So, arr1[i] must be in [max(arr1[i-1], nums[i] - arr2[i-1]), nums[i]]\n                    # Similarly, arr2[i] must be in [0, min(arr2[i-1], nums[i])]\n                    # But since arr2[i] = nums[i] - arr1[i], and arr2[i] <= arr2[i-1]\n                    # We need to ensure arr1[i] >= nums[i] - arr2[i-1]\n                    # Let's keep track of the possible range for arr1[i]\n                    min_arr1[i] = max(min_arr1[i-1], nums[i] - max_arr2[i-1])\n                    max_arr1[i] = nums[i]\n                    # The number of valid arr1[i] is (max_arr1[i] - min_arr1[i] + 1)\n                    if min_arr1[i] > max_arr1[i]:\n                        return 0\n                    dp[i] = (max_arr1[i] - min_arr1[i] + 1) % MOD\n                # Backward pass to ensure arr2 is non-increasing\n                # We need to ensure that arr2[i] <= arr2[i-1] for all i\n                # arr2[i] = nums[i] - arr1[i]\n                # So, nums[i] - arr1[i] <= nums[i-1] - arr1[i-1]\n                # arr1[i] >= arr1[i-1] + nums[i] - nums[i-1]\n                # We need to adjust the range of arr1[i] based on this condition\n                # Let's keep track of the lower bound for arr1[i]\n                lower_bound = 0\n                for i in range(n):\n                    lower_bound = max(lower_bound, nums[i] - max_arr2[i])\n                    if lower_bound > max_arr1[i]:\n                        return 0\n                    dp[i] = (dp[i] * (max_arr1[i] - lower_bound + 1)) % MOD\n                # The total number of valid pairs is the product of dp[i] for all i\n                total = 1\n                for count in dp:\n                    total = (total * count) % MOD\n                return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        max_sum = sum(nums)\n        # Initialize dp arrays\n        dp1 = [0] * (max_sum + 1)\n        dp2 = [0] * (max_sum + 1)\n        # Initialize for the first element\n        for a1 in range(nums[0] + 1):\n            a2 = nums[0] - a1\n            dp1[a1] = 1\n            dp2[a2] = 1\n        # Iterate through the rest of the elements\n        for i in range(1, n):\n            new_dp1 = [0] * (max_sum + 1)\n            new_dp2 = [0] * (max_sum + 1)\n            for a1 in range(nums[i] + 1):\n                a2 = nums[i] - a1\n                if a1 >= dp1[i-1]:\n                    new_dp1[a1] = (new_dp1[a1] + dp1[a1]) % MOD\n                if a2 <= dp2[i-1]:\n                    new_dp2[a2] = (new_dp2[a2] + dp2[a2]) % MOD\n            dp1 = new_dp1\n            dp2 = new_dp2\n        # The total count is the sum of products of dp1 and dp2 for all possible sums\n        total = 0\n        for a1 in range(max_sum + 1):\n            for a2 in range(max_sum + 1):\n                if a1 + a2 == nums[-1]:\n                    total = (total + dp1[a1] * dp2[a2]) % MOD\n        return total",
    "from typing import List\n\n        class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                max_val = max(nums)\n                \n                # Initialize dp arrays\n                dp1 = [0] * (max_val + 1)\n                dp2 = [0] * (max_val + 1)\n                \n                # Initialize for the first element\n                for a1 in range(nums[0] + 1):\n                    a2 = nums[0] - a1\n                    if 0 <= a2 <= max_val:\n                        dp1[a1] = 1\n                        dp2[a2] = 1\n                \n                # Iterate through the rest of the elements\n                for i in range(1, n):\n                    new_dp1 = [0] * (max_val + 1)\n                    new_dp2 = [0] * (max_val + 1)\n                    for a1 in range(nums[i] + 1):\n                        a2 = nums[i] - a1\n                        if 0 <= a2 <= max_val:\n                            # Update new_dp1[a1] by summing dp1[x] for all x <= a1\n                            if a1 > 0:\n                                new_dp1[a1] = (new_dp1[a1 - 1] + dp1[a1]) % MOD\n                            else:\n                                new_dp1[a1] = dp1[a1]\n                            # Update new_dp2[a2] by summing dp2[x] for all x >= a2\n                            if a2 <= max_val:\n                                new_dp2[a2] = (dp2[a2] + new_dp2[a2 + 1]) % MOD\n                    dp1 = new_dp1\n                    dp2 = new_dp2\n                \n                # The total count is the sum of products of dp1[a1] and dp2[a2] for a1 + a2 == nums[-1]\n                total = 0\n                for a1 in range(max_val + 1):\n                    a2 = nums[-1] - a1\n                    if 0 <= a2 <= max_val:\n                        total = (total + dp1[a1] * dp2[a2]) % MOD\n                return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        max_sum = sum(nums)\n        # Initialize dp arrays\n        dp1 = [0] * (max_sum + 1)\n        dp2 = [0] * (max_sum + 1)\n        # Initialize for the first element\n        for a1 in range(nums[0] + 1):\n            a2 = nums[0] - a1\n            dp1[a1] = 1\n            dp2[a2] = 1\n        # Iterate through the rest of the elements\n        for i in range(1, n):\n            new_dp1 = [0] * (max_sum + 1)\n            new_dp2 = [0] * (max_sum + 1)\n            prefix_sum1 = 0\n            prefix_sum2 = 0\n            for a1 in range(nums[i] + 1):\n                a2 = nums[i] - a1\n                # Update new_dp1 considering arr1 should be non-decreasing\n                if a1 >= dp1[i-1]:\n                    prefix_sum1 = (prefix_sum1 + dp1[a1]) % MOD\n                new_dp1[a1] = prefix_sum1\n                # Update new_dp2 considering arr2 should be non-increasing\n                if a2 <= dp2[i-1]:\n                    prefix_sum2 = (prefix_sum2 + dp2[a2]) % MOD\n                new_dp2[a2] = prefix_sum2\n            dp1 = new_dp1\n            dp2 = new_dp2\n        # The total count is the sum of products of dp1 and dp2 for all possible sums\n        total = 0\n        for a1 in range(max_sum + 1):\n            for a2 in range(max_sum + 1):\n                if a1 + a2 == nums[-1]:\n                    total = (total + dp1[a1] * dp2[a2]) % MOD\n        return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        max_val = max(nums)\n        # Initialize dp arrays\n        dp1 = [0] * (max_val + 1)\n        dp2 = [0] * (max_val + 1)\n        # Initialize for the first element\n        for a1 in range(nums[0] + 1):\n            a2 = nums[0] - a1\n            dp1[a1] = 1\n            dp2[a2] = 1\n        # Iterate through the rest of the elements\n        for i in range(1, n):\n            new_dp1 = [0] * (max_val + 1)\n            new_dp2 = [0] * (max_val + 1)\n            for a1 in range(max_val + 1):\n                if a1 > nums[i]:\n                    continue\n                a2 = nums[i] - a1\n                if a2 < 0:\n                    continue\n                # Update new_dp1: arr1 must be non-decreasing\n                for prev_a1 in range(a1 + 1):\n                    new_dp1[a1] = (new_dp1[a1] + dp1[prev_a1]) % MOD\n                # Update new_dp2: arr2 must be non-increasing\n                for prev_a2 in range(a2, max_val + 1):\n                    new_dp2[a2] = (new_dp2[a2] + dp2[prev_a2]) % MOD\n            dp1 = new_dp1\n            dp2 = new_dp2\n        # The total count is the sum of products of dp1 and dp2 for all possible sums\n        total = 0\n        for a1 in range(max_val + 1):\n            a2 = nums[-1] - a1\n            if 0 <= a2 <= max_val:\n                total = (total + dp1[a1] * dp2[a2]) % MOD\n        return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        max_sum = sum(nums)\n        # Initialize dp arrays\n        dp1 = [0] * (max_sum + 1)\n        dp2 = [0] * (max_sum + 1)\n        # Initialize for the first element\n        for a1 in range(nums[0] + 1):\n            a2 = nums[0] - a1\n            dp1[a1] = 1\n            dp2[a2] = 1\n        # Iterate through the rest of the elements\n        for i in range(1, n):\n            new_dp1 = [0] * (max_sum + 1)\n            new_dp2 = [0] * (max_sum + 1)\n            max_a1 = -1\n            min_a2 = float('inf')\n            for a1 in range(nums[i] + 1):\n                a2 = nums[i] - a1\n                if a1 >= max_a1:\n                    new_dp1[a1] = dp1[a1]\n                    max_a1 = a1\n                else:\n                    new_dp1[a1] = new_dp1[max_a1]\n                if a2 <= min_a2:\n                    new_dp2[a2] = dp2[a2]\n                    min_a2 = a2\n                else:\n                    new_dp2[a2] = new_dp2[min_a2]\n            dp1 = new_dp1\n            dp2 = new_dp2\n        # The total count is the sum of products of dp1 and dp2 for all possible sums\n        total = 0\n        for a1 in range(max_sum + 1):\n            a2 = nums[-1] - a1\n            if 0 <= a2 <= max_sum:\n                total = (total + dp1[a1] * dp2[a2]) % MOD\n        return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Precompute prefix_max for arr1 and suffix_min for arr2\n        prefix_max = [0] * n\n        suffix_min = [nums[-1]] * n\n        \n        for i in range(1, n):\n            prefix_max[i] = max(prefix_max[i-1], nums[i] - suffix_min[i-1])\n        \n        for i in range(n-2, -1, -1):\n            suffix_min[i] = min(suffix_min[i+1], nums[i] - prefix_max[i])\n        \n        # Calculate the number of valid arr1[i] for each position\n        total = 1\n        for i in range(n):\n            arr1_min = prefix_max[i]\n            arr1_max = nums[i] - suffix_min[i]\n            if arr1_min > arr1_max:\n                return 0  # No valid pairs\n            count = arr1_max - arr1_min + 1\n            total = (total * count) % MOD\n        \n        return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        max_sum = sum(nums)\n        # Initialize dp arrays\n        dp1 = [0] * (max_sum + 1)\n        dp2 = [0] * (max_sum + 1)\n        # Initialize for the first element\n        for a1 in range(nums[0] + 1):\n            a2 = nums[0] - a1\n            dp1[a1] = 1\n            dp2[a2] = 1\n        # Iterate through the rest of the elements\n        for i in range(1, n):\n            new_dp1 = [0] * (max_sum + 1)\n            new_dp2 = [0] * (max_sum + 1)\n            max_a1 = -1\n            min_a2 = float('inf')\n            for a1 in range(nums[i] + 1):\n                a2 = nums[i] - a1\n                if a1 >= max_a1:\n                    new_dp1[a1] = dp1[a1]\n                    if a1 > max_a1:\n                        max_a1 = a1\n                else:\n                    new_dp1[a1] = new_dp1[max_a1]\n                if a2 <= min_a2:\n                    new_dp2[a2] = dp2[a2]\n                    if a2 < min_a2:\n                        min_a2 = a2\n                else:\n                    new_dp2[a2] = new_dp2[min_a2]\n            dp1 = new_dp1\n            dp2 = new_dp2\n        # The total count is the sum of products of dp1 and dp2 for all possible sums\n        total = 0\n        for a1 in range(max_sum + 1):\n            a2 = nums[-1] - a1\n            if 0 <= a2 <= max_sum:\n                total = (total + dp1[a1] * dp2[a2]) % MOD\n        return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize prefix and suffix arrays\n        prefix_max = [0] * n\n        suffix_min = [1000] * n  # Since nums[i] <= 1000\n        \n        # Compute prefix_max: the maximum value arr1 can take up to index i\n        current_max = -1\n        for i in range(n):\n            current_max = max(current_max, 0)\n            if i > 0:\n                current_max = max(current_max, prefix_max[i-1])\n            prefix_max[i] = min(current_max, nums[i])\n        \n        # Compute suffix_min: the minimum value arr2 can take from index i onwards\n        current_min = 1001\n        for i in range(n-1, -1, -1):\n            current_min = min(current_min, 1000)\n            if i < n-1:\n                current_min = min(current_min, suffix_min[i+1])\n            suffix_min[i] = max(current_min, nums[i] - 1000)\n        \n        # Calculate the number of valid pairs for each position\n        total = 0\n        for i in range(n):\n            a1_max = prefix_max[i]\n            a2_min = suffix_min[i]\n            possible_a1 = a1_max + 1  # arr1[i] can be from 0 to a1_max inclusive\n            possible_a2 = 1000 - a2_min + 1  # arr2[i] can be from a2_min to 1000 inclusive\n            total = (total + (possible_a1 * possible_a2) % MOD) % MOD\n        \n        return total",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize prev and curr as lists of zeros with length 1001\n        prev = [0] * 1001\n        curr = [0] * 1001\n        \n        # arr1[0] can be from 0 to nums[0]\n        for j in range(nums[0] + 1):\n            prev[j] = 1\n        # Compute prefix sums for prev\n        for j in range(1, 1001):\n            prev[j] += prev[j - 1]\n            prev[j] %= MOD\n        \n        for i in range(1, n):\n            curr = [0] * 1001\n            for j in range(0, nums[i] + 1):\n                # Calculate lower and upper bounds for k (arr1[i-1])\n                lower = max(j + nums[i - 1] - nums[i], 0)\n                upper = j\n                if lower > upper:\n                    continue\n                # Use prefix sums to get the number of ways for k in [lower, upper]\n                count = prev[upper]\n                if lower > 0:\n                    count -= prev[lower - 1]\n                count %= MOD\n                # Add to curr[j]\n                curr[j] += count\n                curr[j] %= MOD\n            # Update prefix sums for curr\n            for j in range(1, 1001):\n                curr[j] += curr[j - 1]\n                curr[j] %= MOD\n            # Update prev to curr for the next iteration\n            prev = curr.copy()\n        \n        # Sum all possible ways for arr1[n-1]\n        result = sum(curr) % MOD\n        return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        lower = max(j + nums[i - 1] - nums[i], 0)\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize prev and curr as lists of zeros with length 1001\n        prev = [0] * 1001\n        curr = [0] * 1001\n        \n        # arr1[0] can be from 0 to nums[0]\n        for j in range(nums[0] + 1):\n            prev[j] = 1\n        # Compute prefix sums for prev\n        for j in range(1, 1001):\n            prev[j] = (prev[j] + prev[j - 1]) % MOD\n        \n        for i in range(1, n):\n            curr = [0] * 1001\n            for j in range(0, nums[i] + 1):\n                # Calculate lower and upper bounds for k (arr1[i-1])\n                lower = max(j - nums[i] + nums[i - 1], 0)\n                upper = min(j, nums[i - 1])\n                if lower > upper:\n                    continue\n                # Use prefix sums to get the number of ways for k in [lower, upper]\n                count = prev[upper]\n                if lower > 0:\n                    count = (count - prev[lower - 1] + MOD) % MOD\n                # Add to curr[j]\n                curr[j] = (curr[j] + count) % MOD\n            # Update prefix sums for curr\n            for j in range(1, 1001):\n                curr[j] = (curr[j] + curr[j - 1]) % MOD\n            # Update prev to curr for the next iteration\n            prev = curr.copy()\n        \n        # Sum all possible ways for arr1[n-1]\n        result = sum(curr) % MOD\n        return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        lower = max(j, nums[i - 1] - (nums[i] - j))\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        lower = max(j - nums[i] + nums[i - 1], 0)\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize prev and curr as lists of zeros with length 1001\n        prev = [0] * 1001\n        curr = [0] * 1001\n        \n        # arr1[0] can be from 0 to nums[0]\n        for j in range(nums[0] + 1):\n            prev[j] = 1\n        # Compute prefix sums for prev\n        for j in range(1, 1001):\n            prev[j] = (prev[j] + prev[j - 1]) % MOD\n        \n        for i in range(1, n):\n            curr = [0] * 1001\n            for j in range(0, nums[i] + 1):\n                # Calculate lower and upper bounds for k (arr1[i-1])\n                lower = max(j + nums[i - 1] - nums[i], 0)\n                upper = min(j, nums[i - 1])\n                if lower > upper:\n                    continue\n                # Use prefix sums to get the number of ways for k in [lower, upper]\n                count = prev[upper]\n                if lower > 0:\n                    count = (count - prev[lower - 1] + MOD) % MOD\n                # Add to curr[j]\n                curr[j] = (curr[j] + count) % MOD\n            # Update prefix sums for curr\n            for j in range(1, 1001):\n                curr[j] = (curr[j] + curr[j - 1]) % MOD\n            # Update prev to curr for the next iteration\n            prev = curr.copy()\n        \n        # Sum all possible ways for arr1[n-1]\n        result = sum(curr) % MOD\n        return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        lower = max(j + nums[i - 1] - nums[i], 0)\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        lower = max(j + nums[i - 1] - nums[i], 0)\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        lower = max(j, nums[i - 1] - (nums[i] - j))\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize prev and curr as lists of zeros with length 1001\n        prev = [0] * 1001\n        curr = [0] * 1001\n        \n        # arr1[0] can be from 0 to nums[0]\n        for j in range(nums[0] + 1):\n            prev[j] = 1\n        # Compute prefix sums for prev\n        for j in range(1, 1001):\n            prev[j] = (prev[j] + prev[j - 1]) % MOD\n        \n        for i in range(1, n):\n            curr = [0] * 1001\n            for j in range(0, nums[i] + 1):\n                # Calculate lower and upper bounds for k (arr1[i-1])\n                lower = max(j + nums[i - 1] - nums[i], 0)\n                upper = min(j, nums[i - 1])\n                if lower > upper:\n                    continue\n                # Use prefix sums to get the number of ways for k in [lower, upper]\n                count = prev[upper]\n                if lower > 0:\n                    count = (count - prev[lower - 1] + MOD) % MOD\n                # Add to curr[j]\n                curr[j] = (curr[j] + count) % MOD\n            # Update prefix sums for curr\n            for j in range(1, 1001):\n                curr[j] = (curr[j] + curr[j - 1]) % MOD\n            # Update prev to curr for the next iteration\n            prev = curr.copy()\n        \n        # Sum all possible ways for arr1[n-1]\n        result = sum(curr) % MOD\n        return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        lower = max(j, nums[i - 1] - (nums[i] - j))\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                \n                # Initialize prev and curr as lists of zeros with length 1001\n                prev = [0] * 1001\n                curr = [0] * 1001\n                \n                # arr1[0] can be from 0 to nums[0]\n                for j in range(nums[0] + 1):\n                    prev[j] = 1\n                # Compute prefix sums for prev\n                for j in range(1, 1001):\n                    prev[j] = (prev[j] + prev[j - 1]) % MOD\n                \n                for i in range(1, n):\n                    curr = [0] * 1001\n                    for j in range(0, nums[i] + 1):\n                        # Calculate lower and upper bounds for k (arr1[i-1])\n                        # arr1[i-1] should be >= j + nums[i-1] - nums[i] and <= j\n                        # Also, arr1[i-1] should be between 0 and nums[i-1]\n                        lower = max(j + nums[i - 1] - nums[i], 0)\n                        upper = min(j, nums[i - 1])\n                        if lower > upper:\n                            continue\n                        # Use prefix sums to get the number of ways for k in [lower, upper]\n                        count = prev[upper]\n                        if lower > 0:\n                            count = (count - prev[lower - 1] + MOD) % MOD\n                        # Add to curr[j]\n                        curr[j] = (curr[j] + count) % MOD\n                    # Update prefix sums for curr\n                    for j in range(1, 1001):\n                        curr[j] = (curr[j] + curr[j - 1]) % MOD\n                    # Update prev to curr for the next iteration\n                    prev = curr.copy()\n                \n                # Sum all possible ways for arr1[n-1]\n                result = sum(curr) % MOD\n                return result",
    "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize prev and curr as lists of zeros with length 1001\n        prev = [0] * 1001\n        curr = [0] * 1001\n        \n        # arr1[0] can be from 0 to nums[0]\n        for j in range(nums[0] + 1):\n            prev[j] = 1\n        # Compute prefix sums for prev\n        for j in range(1, 1001):\n            prev[j] = (prev[j] + prev[j - 1]) % MOD\n        \n        for i in range(1, n):\n            curr = [0] * 1001\n            for j in range(0, nums[i] + 1):\n                # Calculate lower and upper bounds for k (arr1[i-1])\n                lower = max(j + nums[i - 1] - nums[i], 0)\n                upper = min(j, nums[i - 1])\n                if lower > upper:\n                    continue\n                # Use prefix sums to get the number of ways for k in [lower, upper]\n                count = prev[upper]\n                if lower > 0:\n                    count = (count - prev[lower - 1] + MOD) % MOD\n                # Add to curr[j]\n                curr[j] = (curr[j] + count) % MOD\n            # Update prefix sums for curr\n            for j in range(1, 1001):\n                curr[j] = (curr[j] + curr[j - 1]) % MOD\n            # Update prev to curr for the next iteration\n            prev = curr.copy()\n        \n        # Sum all possible ways for arr1[n-1]\n        result = sum(curr) % MOD\n        return result"
  ],
  "total_candidates": 26,
  "nodes_explored": 26,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n            def countOfPairs(self, nums: List[int]) -> int:\n                MOD = 10**9 + 7\n                n = len(nums)\n                max_sum = sum(nums)\n                # Initialize dp arrays\n                dp1 = [0] * (max_sum + 1)\n                dp2 = [0] * (max_sum + 1)\n                # Initialize for the first element\n                for a1 in range(nums[0] + 1):\n                    a2 = nums[0] - a1\n                    dp1[a1] += 1\n                    dp2[a2] += 1\n                # Iterate through the rest of the elements\n                for i in range(1, n):\n                    new_dp1 = [0] * (max_sum + 1)\n                    new_dp2 = [0] * (max_sum + 1)\n                    for a1 in range(nums[i] + 1):\n                        a2 = nums[i] - a1\n                        if a1 >= dp1[i-1]:\n                            new_dp1[a1] = (new_dp1[a1] + dp1[a1]) % MOD\n                        if a2 <= dp2[i-1]:\n                            new_dp2[a2] = (new_dp2[a2] + dp2[a2]) % MOD\n                    dp1 = new_dp1\n                    dp2 = new_dp2\n                # The total count is the sum of products of dp1 and dp2 for all possible sums\n                total = 0\n                for a1 in range(max_sum + 1):\n                    for a2 in range(max_sum + 1):\n                        if a1 + a2 == nums[-1]:\n                            total = (total + dp1[a1] * dp2[a2]) % MOD\n                return total",
      "solution_hash": "e25c40b66849417709f8bc9ea0fe74413b2fefd059d83acdebeffd4125dc81e5",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpbt6ickpt.py\", line 202, in <module>\n    check(Solution().countOfPairs)\n  File \"/scratch/local/21926555/tmpbt6ickpt.py\", line 116, in check\n    assert candidate(nums = [2, 3, 2]) == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpbt6ickpt.py` failed. (See above for error)\n",
        "execution_time": 19.624677658081055,
        "failed_tests": [
          {
            "input": "nums = [2, 3, 2]",
            "expected": "4",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpbt6ickpt.py\", line 202, in <module>\n    check(Solution().countOfPairs)\n  File \"/scratch/local/21926555/tmpbt6ickpt.py\", line 116, in check\n    assert candidate(nums = [2, 3, 2]) == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpbt6ickpt.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Initialize prev and curr as lists of zeros with length 1001\n        prev = [0] * 1001\n        curr = [0] * 1001\n        \n        # arr1[0] can be from 0 to nums[0]\n        for j in range(nums[0] + 1):\n            prev[j] = 1\n        # Compute prefix sums for prev\n        for j in range(1, 1001):\n            prev[j] += prev[j - 1]\n            prev[j] %= MOD\n        \n        for i in range(1, n):\n            curr = [0] * 1001\n            for j in range(0, nums[i] + 1):\n                # Calculate lower and upper bounds for k (arr1[i-1])\n                lower = max(j + nums[i - 1] - nums[i], 0)\n                upper = j\n                if lower > upper:\n                    continue\n                # Use prefix sums to get the number of ways for k in [lower, upper]\n                count = prev[upper]\n                if lower > 0:\n                    count -= prev[lower - 1]\n                count %= MOD\n                # Add to curr[j]\n                curr[j] += count\n                curr[j] %= MOD\n            # Update prefix sums for curr\n            for j in range(1, 1001):\n                curr[j] += curr[j - 1]\n                curr[j] %= MOD\n            # Update prev to curr for the next iteration\n            prev = curr.copy()\n        \n        # Sum all possible ways for arr1[n-1]\n        result = sum(curr) % MOD\n        return result",
      "solution_hash": "cc04ae38a5f572518985cec8c4eb57b9c58d84a70824ae26dbf584947dc5ff19",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpiwlwjdde.py\", line 213, in <module>\n    check(Solution().countOfPairs)\n  File \"/scratch/local/21926555/tmpiwlwjdde.py\", line 127, in check\n    assert candidate(nums = [2, 3, 2]) == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpiwlwjdde.py` failed. (See above for error)\n",
        "execution_time": 17.929356336593628,
        "failed_tests": [
          {
            "input": "nums = [2, 3, 2]",
            "expected": "4",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpiwlwjdde.py\", line 213, in <module>\n    check(Solution().countOfPairs)\n  File \"/scratch/local/21926555/tmpiwlwjdde.py\", line 127, in check\n    assert candidate(nums = [2, 3, 2]) == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpiwlwjdde.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14",
        "1_18",
        "1_22"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 26,
    "candidates_generated": 26,
    "tests_passed": 0,
    "tests_failed": 26,
    "test_errors": 0,
    "execution_times": [
      19.624677658081055,
      15.651294708251953,
      17.50996971130371,
      16.675471305847168,
      16.963460683822632,
      17.23374915122986,
      16.261900663375854,
      16.939732551574707,
      14.45965313911438,
      15.20228910446167,
      17.45028853416443,
      16.963902473449707,
      16.995272874832153,
      17.929356336593628,
      19.638627290725708,
      18.0911066532135,
      16.76943802833557,
      18.0911066532135,
      19.638627290725708,
      19.638627290725708,
      19.638627290725708,
      16.76943802833557,
      19.638627290725708,
      16.76943802833557,
      19.638627290725708,
      19.638627290725708
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 17,
      "unique_ratio": 0.6538461538461539,
      "similarity_score": 0.0,
      "solution_lengths": {
        "min": 886,
        "max": 2730,
        "avg": 1627.2307692307693
      }
    },
    "test_case_analysis": {
      "hardest_cases": {
        "nums = [2, 3, 2]": 23
      },
      "first_failing_tests": {
        "nums = [2, 3, 2]": 23
      }
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 6,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 18,
          "improvements": 3,
          "solved": 0
        }
      },
      "error_types": {
        "assertion_failure": {
          "attempts": 8,
          "improvements": 3
        }
      },
      "test_case_improvements": {
        "nums = [2, 3, 2]": 3
      },
      "error_transitions": {
        "assertion_failure->assertion_failure": 21,
        "assertion_failure->other_error": 3
      }
    },
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.6153846153846154,
        "solutions_per_depth": {
          "0": 2,
          "1": 6,
          "2": 18
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.03703703703703698,
        "pass@3": 0.11111111111111116,
        "pass@5": 0.18518518518518512,
        "pass@10": 0.37037037037037035
      },
      "solutions_evaluated": 27
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0
      },
      "error_recovery": {
        "total_attempts": 8,
        "total_improvements": 3,
        "recovery_rate": 0.375
      },
      "top_errors": [
        [
          "assertion_failure",
          8
        ]
      ],
      "hardest_test_cases": [
        [
          "nums = [2, 3, 2]",
          23
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      }
    }
  },
  "processing_time": 1616.9634976387024,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.03703703703703698,
      "pass@3": 0.11111111111111116,
      "pass@5": 0.18518518518518512,
      "pass@10": 0.37037037037037035
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 97)",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 26
          }
        ]
      ]
    },
    "solutions_evaluated": 27,
    "test_cases": 1
  }
}