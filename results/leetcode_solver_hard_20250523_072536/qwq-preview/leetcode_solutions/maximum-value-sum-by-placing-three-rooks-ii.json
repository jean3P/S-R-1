{
  "problem_id": "maximum-value-sum-by-placing-three-rooks-ii",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = []\n        \n        # Step 1: Flatten the board into a list of cells\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort cells by value in descending order\n        cells.sort(reverse=True)\n        \n        selected_rows = set()\n        selected_cols = set()\n        sum_values = 0\n        rooks_placed = 0\n        \n        # Step 4: Iterate through sorted cells and select up to three rooks\n        for value, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                sum_values += value\n                selected_rows.add(row)\n                selected_cols.add(col)\n                rooks_placed += 1\n                if rooks_placed == 3:\n                    break\n        \n        return sum_values",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = []\n        \n        # Step 1: Flatten the board into a list of cells\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort cells by value in descending order\n        cells.sort(reverse=True)\n        \n        selected_rows = set()\n        selected_cols = set()\n        sum_values = 0\n        rooks_placed = 0\n        \n        # Step 4: Iterate through sorted cells and select up to three rooks\n        for value, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                sum_values += value\n                selected_rows.add(row)\n                selected_cols.add(col)\n                rooks_placed += 1\n                if rooks_placed == 3:\n                    break\n        \n        return sum_values",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute top 3 values and their columns for each row\n                row_top3 = []\n                for i in range(m):\n                    sorted_cols = sorted([(board[i][j], j) for j in range(n)], reverse=True)\n                    row_top3.append(sorted_cols[:3])\n                \n                max_sum = float('-inf')\n                \n                # Iterate through all combinations of 3 rows\n                for i in range(m):\n                    for j in range(i+1, m):\n                        for k in range(j+1, m):\n                            # Get top 3 values from each row\n                            top_i = row_top3[i]\n                            top_j = row_top3[j]\n                            top_k = row_top3[k]\n                            \n                            # Try all combinations of columns from the three rows\n                            for val_i, col_i in top_i:\n                                for val_j, col_j in top_j:\n                                    if col_j == col_i:\n                                        continue  # skip if same column\n                                    for val_k, col_k in top_k:\n                                        if col_k == col_i or col_k == col_j:\n                                            continue  # skip if same column as previous rooks\n                                        current_sum = val_i + val_j + val_k\n                                        if current_sum > max_sum:\n                                            max_sum = current_sum\n                                            \n                return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = []\n        \n        # Step 1: Flatten the board into a list of cells\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort cells by value in descending order\n        cells.sort(reverse=True)\n        \n        selected_rows = set()\n        selected_cols = set()\n        sum_values = 0\n        rooks_placed = 0\n        \n        # Step 4: Iterate through sorted cells and select up to three rooks\n        for value, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                sum_values += value\n                selected_rows.add(row)\n                selected_cols.add(col)\n                rooks_placed += 1\n                if rooks_placed == 3:\n                    break\n        \n        return sum_values",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Sort each row in descending order\n        for row in board:\n            row.sort(reverse=True)\n        \n        # Select the top three cells without conflicting rows and columns\n        sum_values = 0\n        selected_rows = set()\n        selected_cols = set()\n        \n        # Iterate through the board to select cells\n        for _ in range(3):\n            max_val = float('-inf')\n            best_row, best_col = -1, -1\n            for i in range(m):\n                if i in selected_rows:\n                    continue\n                for j in range(n):\n                    if j in selected_cols:\n                        continue\n                    if board[i][j] > max_val:\n                        max_val = board[i][j]\n                        best_row, best_col = i, j\n            if max_val == float('-inf'):\n                break\n            sum_values += max_val\n            selected_rows.add(best_row)\n            selected_cols.add(best_col)\n        \n        return sum_values",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                cells = []\n                \n                # Step 1: Flatten the board into a list of cells\n                for i in range(m):\n                    for j in range(n):\n                        cells.append((board[i][j], i, j))\n                \n                # Step 2: Sort cells by value in descending order\n                cells.sort(reverse=True)\n                \n                selected_rows = set()\n                selected_cols = set()\n                sum_values = 0\n                rooks_placed = 0\n                \n                # Step 4: Iterate through sorted cells and select up to three rooks\n                for value, row, col in cells:\n                    if row not in selected_rows and col not in selected_cols:\n                        sum_values += value\n                        selected_rows.add(row)\n                        selected_cols.add(col)\n                        rooks_placed += 1\n                        if rooks_placed == 3:\n                            break\n                \n                return sum_values",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = []\n        \n        # Step 1: Flatten the board into a list of cells\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort cells by value in descending order\n        cells.sort(reverse=True)\n        \n        selected_rows = set()\n        selected_cols = set()\n        sum_values = 0\n        rooks_placed = 0\n        \n        # Step 4: Iterate through sorted cells and select up to three rooks\n        for value, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                sum_values += value\n                selected_rows.add(row)\n                selected_cols.add(col)\n                rooks_placed += 1\n                if rooks_placed == 3:\n                    break\n        \n        return sum_values",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = []\n        \n        # Step 1: Flatten the board into a list of cells\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort cells by value in descending order\n        cells.sort(reverse=True)\n        \n        selected_rows = set()\n        selected_cols = set()\n        sum_values = 0\n        rooks_placed = 0\n        \n        # Step 4: Iterate through sorted cells and select up to three rooks\n        for value, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                sum_values += value\n                selected_rows.add(row)\n                selected_cols.add(col)\n                rooks_placed += 1\n                if rooks_placed == 3:\n                    break\n        \n        return sum_values",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        row_max = [max(row) for row in board]\n        col_max = [max(board[i][j] for i in range(m)) for j in range(n)]\n        \n        sum_values = 0\n        selected_rows = set()\n        selected_cols = set()\n        \n        for _ in range(3):\n            max_val = float('-inf')\n            selected_row, selected_col = -1, -1\n            for i in range(m):\n                if i in selected_rows:\n                    continue\n                for j in range(n):\n                    if j in selected_cols:\n                        continue\n                    if board[i][j] == row_max[i] and board[i][j] == col_max[j]:\n                        if board[i][j] > max_val:\n                            max_val = board[i][j]\n                            selected_row, selected_col = i, j\n            if max_val == float('-inf'):\n                break\n            sum_values += max_val\n            selected_rows.add(selected_row)\n            selected_cols.add(selected_col)\n        \n        return sum_values",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                max_sum = float('-inf')\n                path = []\n                rows = set()\n                cols = set()\n                \n                def backtrack(row, col_index, rooks_placed):\n                    nonlocal max_sum, path, rows, cols\n                    if rooks_placed == 3:\n                        current_sum = sum(board[r][c] for r, c in path)\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n                        return\n                    if row == m:\n                        return\n                    # Skip the current cell\n                    if col_index < n:\n                        backtrack(row, col_index + 1, rooks_placed)\n                    # Place a rook in the current cell\n                    if col_index < n and row not in rows and col_index not in cols:\n                        path.append((row, col_index))\n                        rows.add(row)\n                        cols.add(col_index)\n                        backtrack(row + 1, 0, rooks_placed + 1)\n                        path.pop()\n                        rows.remove(row)\n                        cols.remove(col_index)\n                    # Move to the next row\n                    backtrack(row + 1, 0, rooks_placed)\n                \n                backtrack(0, 0, 0)\n                return max_sum",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                max_sum = float('-inf')\n                path = []\n                rows = set()\n                cols = set()\n                \n                def backtrack(row, col_index, rooks_placed):\n                    nonlocal max_sum, path, rows, cols\n                    if rooks_placed == 3:\n                        current_sum = sum(board[r][c] for r, c in path)\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n                        return\n                    if row == m:\n                        return\n                    # Skip the current cell\n                    if col_index < n:\n                        backtrack(row, col_index + 1, rooks_placed)\n                    # Place a rook in the current cell\n                    if col_index < n and row not in rows and col_index not in cols:\n                        path.append((row, col_index))\n                        rows.add(row)\n                        cols.add(col_index)\n                        backtrack(row + 1, 0, rooks_placed + 1)\n                        path.pop()\n                        rows.remove(row)\n                        cols.remove(col_index)\n                    # Move to the next row\n                    backtrack(row + 1, 0, rooks_placed)\n                \n                backtrack(0, 0, 0)\n                return max_sum",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                max_sum = float('-inf')\n                path = []\n                rows = set()\n                cols = set()\n                \n                def backtrack(row, col_index, rooks_placed):\n                    nonlocal max_sum, path, rows, cols\n                    if rooks_placed == 3:\n                        current_sum = sum(board[r][c] for r, c in path)\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n                        return\n                    if row == m:\n                        return\n                    # Skip the current cell\n                    if col_index < n:\n                        backtrack(row, col_index + 1, rooks_placed)\n                    # Place a rook in the current cell\n                    if col_index < n and row not in rows and col_index not in cols:\n                        path.append((row, col_index))\n                        rows.add(row)\n                        cols.add(col_index)\n                        backtrack(row + 1, 0, rooks_placed + 1)\n                        path.pop()\n                        rows.remove(row)\n                        cols.remove(col_index)\n                    # Move to the next row\n                    backtrack(row + 1, 0, rooks_placed)\n                \n                backtrack(0, 0, 0)\n                return max_sum",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                max_sum = float('-inf')\n                path = []\n                rows = set()\n                cols = set()\n                \n                def backtrack(row, col_index, rooks_placed):\n                    nonlocal max_sum, path, rows, cols\n                    if rooks_placed == 3:\n                        current_sum = sum(board[r][c] for r, c in path)\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n                        return\n                    if row == m:\n                        return\n                    # Skip the current cell\n                    if col_index < n:\n                        backtrack(row, col_index + 1, rooks_placed)\n                    # Place a rook in the current cell\n                    if col_index < n and row not in rows and col_index not in cols:\n                        path.append((row, col_index))\n                        rows.add(row)\n                        cols.add(col_index)\n                        backtrack(row + 1, 0, rooks_placed + 1)\n                        path.pop()\n                        rows.remove(row)\n                        cols.remove(col_index)\n                    # Move to the next row\n                    backtrack(row + 1, 0, rooks_placed)\n                \n                backtrack(0, 0, 0)\n                return max_sum",
    "import heapq\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        # Flatten the board and store cells in a max heap based on cell values\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                heapq.heappush(heap, (-board[i][j], i, j))  # Use negative values for max heap\n        \n        used_rows = set()\n        used_cols = set()\n        sum_val = 0\n        for _ in range(3):\n            if not heap:\n                break  # If heap is empty, no more rooks can be placed\n            val, r, c = heapq.heappop(heap)\n            while heap and (r in used_rows or c in used_cols):\n                val, r, c = heapq.heappop(heap)\n            if r not in used_rows and c not in used_cols:\n                sum_val -= val  # Since we stored negative values\n                used_rows.add(r)\n                used_cols.add(c)\n        \n        return sum_val",
    "import heapq\nfrom typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute top 3 values and their columns for each row\n        row_max = []\n        for i in range(m):\n            heap = [(-board[i][j], j) for j in range(n)]\n            heapq.heapify(heap)\n            row_max.append(heap)\n        \n        # Precompute top 3 values and their rows for each column\n        col_max = []\n        for j in range(n):\n            heap = [(-board[i][j], i) for i in range(m)]\n            heapq.heapify(heap)\n            col_max.append(heap)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of 3 rows and 3 columns\n        for r1 in range(m):\n            for r2 in range(r1+1, m):\n                for r3 in range(r2+1, m):\n                    rows = [r1, r2, r3]\n                    cols_used = set()\n                    sum_val = 0\n                    # For each row, pick the maximum column not used yet\n                    for r in rows:\n                        while row_max[r]:\n                            val, c = heapq.heappop(row_max[r])\n                            if c not in cols_used:\n                                sum_val -= val  # Since we stored negative values\n                                cols_used.add(c)\n                                break\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, sum_val)\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute top 3 columns for each row\n        row_top = []\n        for i in range(m):\n            # Sort columns for the current row in descending order of cell values\n            sorted_cols = sorted(range(n), key=lambda j: board[i][j], reverse=True)\n            row_top.append(sorted_cols[:3])\n        \n        # Precompute top 3 rows for each column\n        col_top = []\n        for j in range(n):\n            # Sort rows for the current column in descending order of cell values\n            sorted_rows = sorted(range(m), key=lambda i: board[i][j], reverse=True)\n            col_top.append(sorted_rows[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of 3 distinct rows\n        for r1 in range(m):\n            for r2 in range(r1+1, m):\n                for r3 in range(r2+1, m):\n                    rows = [r1, r2, r3]\n                    cols_used = set()\n                    sum_val = 0\n                    # For each row, pick the best column not used yet\n                    for r in rows:\n                        for c in row_top[r]:\n                            if c not in cols_used:\n                                sum_val += board[r][c]\n                                cols_used.add(c)\n                                break\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, sum_val)\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute top 3 columns for each row\n        row_max = []\n        for i in range(m):\n            # Sort columns by value in descending order\n            sorted_cols = sorted(range(n), key=lambda j: board[i][j], reverse=True)\n            row_max.append(sorted_cols[:3])\n        \n        # Precompute top 3 rows for each column\n        col_max = []\n        for j in range(n):\n            # Sort rows by value in descending order\n            sorted_rows = sorted(range(m), key=lambda i: board[i][j], reverse=True)\n            col_max.append(sorted_rows[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of 3 rows\n        for r1 in range(m):\n            for r2 in range(r1 + 1, m):\n                for r3 in range(r2 + 1, m):\n                    rows = [r1, r2, r3]\n                    cols_used = set()\n                    sum_val = 0\n                    # For each row, pick the best column not used yet\n                    for r in rows:\n                        for c in row_max[r]:\n                            if c not in cols_used:\n                                sum_val += board[r][c]\n                                cols_used.add(c)\n                                break\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, sum_val)\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute top 3 columns for each row\n        row_max = []\n        for i in range(m):\n            # Sort columns by value in descending order\n            sorted_cols = sorted(range(n), key=lambda j: board[i][j], reverse=True)\n            row_max.append(sorted_cols[:3])\n        \n        # Precompute top 3 rows for each column\n        col_max = []\n        for j in range(n):\n            # Sort rows by value in descending order\n            sorted_rows = sorted(range(m), key=lambda i: board[i][j], reverse=True)\n            col_max.append(sorted_rows[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of 3 rows\n        for r1 in range(m):\n            for r2 in range(r1+1, m):\n                for r3 in range(r2+1, m):\n                    rows = [r1, r2, r3]\n                    cols_used = set()\n                    sum_val = 0\n                    # For each row, pick the best column not used yet\n                    for r in rows:\n                        for c in row_max[r]:\n                            if c not in cols_used:\n                                sum_val += board[r][c]\n                                cols_used.add(c)\n                                break\n                    if len(cols_used) == 3:\n                        max_sum = max(max_sum, sum_val)\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Sort each row in descending order\n        for row in board:\n            row.sort(reverse=True)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three different rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Find the best columns for each row to avoid conflicts\n                    # Initialize a list to store the possible sums\n                    sums = []\n                    for c1 in range(n):\n                        for c2 in range(n):\n                            for c3 in range(n):\n                                if c1 != c2 and c1 != c3 and c2 != c3:\n                                    current_sum = board[i][c1] + board[j][c2] + board[k][c3]\n                                    sums.append(current_sum)\n                    if sums:\n                        max_sum = max(max_sum, max(sums))\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three different rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Find the best columns for each row to avoid conflicts\n                    # Initialize a list to store the possible sums\n                    sums = []\n                    for c1 in range(n):\n                        for c2 in range(n):\n                            for c3 in range(n):\n                                if c1 != c2 and c1 != c3 and c2 != c3:\n                                    current_sum = board[i][c1] + board[j][c2] + board[k][c3]\n                                    sums.append(current_sum)\n                    if sums:\n                        max_sum = max(max_sum, max(sums))\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute top 3 values and their columns for each row\n        row_maxes = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            row_maxes.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three different rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top available columns for each row\n                    candidates_i = row_maxes[i]\n                    candidates_j = row_maxes[j]\n                    candidates_k = row_maxes[k]\n                    \n                    # Try all combinations of columns from the top candidates\n                    for ci in candidates_i:\n                        for cj in candidates_j:\n                            for ck in candidates_k:\n                                # Ensure columns are unique\n                                cols = [ci[0], cj[0], ck[0]]\n                                if len(set(cols)) == 3:\n                                    current_sum = board[i][ci[0]] + board[j][cj[0]] + board[k][ck[0]]\n                                    if current_sum > max_sum:\n                                        max_sum = current_sum\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their indices for each row\n        row_top3 = []\n        for row in board:\n            sorted_indices = sorted(range(n), key=lambda x: row[x], reverse=True)\n            top3 = [(row[i], i) for i in sorted_indices[:3]]\n            row_top3.append(top3)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three different rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Collect the top 3 candidates from each row\n                    candidates = row_top3[i] + row_top3[j] + row_top3[k]\n                    \n                    # Generate all possible selections of one cell from each row\n                    for c1 in row_top3[i]:\n                        for c2 in row_top3[j]:\n                            for c3 in row_top3[k]:\n                                # Check if all columns are unique\n                                if len({c1[1], c2[1], c3[1]}) == 3:\n                                    current_sum = c1[0] + c2[0] + c3[0]\n                                    if current_sum > max_sum:\n                                        max_sum = current_sum\n        return max_sum",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute the top 3 values and their columns for each row\n                row_top3 = []\n                for row in board:\n                    sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n                    row_top3.append(sorted_row[:3])\n                \n                max_sum = float('-inf')\n                \n                # Iterate through all combinations of three distinct rows\n                for i in range(m):\n                    for j in range(i+1, m):\n                        for k in range(j+1, m):\n                            # Collect the top 3 cells from each row, avoiding duplicate columns\n                            candidates = []\n                            rows = [row_top3[i], row_top3[j], row_top3[k]]\n                            for row in rows:\n                                for col, val in row:\n                                    if all(col != c for r in rows if r is not row for c, _ in r):\n                                        candidates.append((col, val))\n                            \n                            # Sort candidates by value descending\n                            candidates.sort(key=lambda x: x[1], reverse=True)\n                            \n                            # Select the top 3 candidates with unique columns\n                            selected = []\n                            used_cols = set()\n                            for col, val in candidates:\n                                if col not in used_cols:\n                                    selected.append(val)\n                                    used_cols.add(col)\n                                    if len(selected) == 3:\n                                        break\n                            \n                            # If we have selected 3 rooks, calculate the sum\n                            if len(selected) == 3:\n                                current_sum = sum(selected)\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n                \n                return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their columns for each row\n        row_top3 = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three distinct rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Collect the top 3 cells from each row, avoiding duplicate columns\n                    candidates = []\n                    rows = [row_top3[i], row_top3[j], row_top3[k]]\n                    for row in rows:\n                        for col, val in row:\n                            if all(col != c for r in rows if r is not row for c, _ in r):\n                                candidates.append((col, val))\n                    \n                    # Sort candidates by value descending\n                    candidates.sort(key=lambda x: x[1], reverse=True)\n                    \n                    # Select the top 3 candidates with unique columns\n                    selected = []\n                    used_cols = set()\n                    for col, val in candidates:\n                        if col not in used_cols:\n                            selected.append(val)\n                            used_cols.add(col)\n                            if len(selected) == 3:\n                                break\n                    \n                    # If we have selected 3 rooks, calculate the sum\n                    if len(selected) == 3:\n                        current_sum = sum(selected)\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the top 3 values and their columns for each row\n        row_top3 = []\n        for row in board:\n            sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n            row_top3.append(sorted_row[:3])\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three distinct rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Collect the top 3 cells from each row, avoiding duplicate columns\n                    candidates = []\n                    rows = [row_top3[i], row_top3[j], row_top3[k]]\n                    for row in rows:\n                        for col, val in row:\n                            if all(col != c for r in rows if r is not row for c, _ in r):\n                                candidates.append((col, val))\n                    \n                    # Sort candidates by value descending\n                    candidates.sort(key=lambda x: x[1], reverse=True)\n                    \n                    # Select the top 3 candidates with unique columns\n                    selected = []\n                    used_cols = set()\n                    for col, val in candidates:\n                        if col not in used_cols:\n                            selected.append(val)\n                            used_cols.add(col)\n                            if len(selected) == 3:\n                                break\n                    \n                    # If we have selected 3 rooks, calculate the sum\n                    if len(selected) == 3:\n                        current_sum = sum(selected)\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute the sorted columns for each row, sorted by value descending\n        row_sorted = []\n        for row in board:\n            sorted_cols = sorted(range(n), key=lambda col: row[col], reverse=True)\n            row_sorted.append(sorted_cols)\n        \n        max_sum = float('-inf')\n        \n        # Iterate through all combinations of three distinct rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the sorted column indices for the three rows\n                    cols_i = row_sorted[i]\n                    cols_j = row_sorted[j]\n                    cols_k = row_sorted[k]\n                    \n                    # Initialize pointers for each row's columns\n                    ptr_i = 0\n                    ptr_j = 0\n                    ptr_k = 0\n                    \n                    # Initialize the sum and the selected columns\n                    current_sum = 0\n                    selected_cols = []\n                    \n                    # Try to select the top columns with unique indices\n                    while len(selected_cols) < 3:\n                        # Get the current top columns\n                        col_i = cols_i[ptr_i]\n                        col_j = cols_j[ptr_j]\n                        col_k = cols_k[ptr_k]\n                        \n                        # Check if all three columns are unique\n                        if len({col_i, col_j, col_k}) == 3:\n                            selected_cols = [col_i, col_j, col_k]\n                            break\n                        else:\n                            # Move the pointer of the smallest value\n                            min_val = min(board[i][col_i], board[j][col_j], board[k][col_k])\n                            if board[i][col_i] == min_val:\n                                ptr_i += 1\n                            if board[j][col_j] == min_val:\n                                ptr_j += 1\n                            if board[k][col_k] == min_val:\n                                ptr_k += 1\n                            \n                            # Check if we've exhausted any row\n                            if ptr_i == n or ptr_j == n or ptr_k == n:\n                                break\n                    \n                    # If we have selected 3 unique columns, calculate the sum\n                    if len(selected_cols) == 3:\n                        current_sum = board[i][selected_cols[0]] + board[j][selected_cols[1]] + board[k][selected_cols[2]]\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Step 1: Flatten the board and sort cells by value in descending order\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        cells.sort(reverse=True)\n        \n        selected = set()\n        result = []\n        for val, row, col in cells:\n            if row not in selected and col not in selected:\n                selected.add(row)\n                selected.add(col)\n                result.append(val)\n                if len(result) == 3:\n                    break\n        \n        return sum(result)",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Step 1: Collect all cells with their values, row, and column indices\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort the cells in descending order of their values\n        cells.sort(reverse=True)\n        \n        # Step 3: Select up to three cells ensuring no two are in the same row or column\n        selected_rows = set()\n        selected_cols = set()\n        result = []\n        for val, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                selected_rows.add(row)\n                selected_cols.add(col)\n                result.append(val)\n                if len(result) == 3:\n                    break\n        \n        # Step 4: Return the sum of the selected cell values\n        return sum(result)",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Collect all cells with their values, row, and column indices\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Sort the cells in descending order of their values\n        cells.sort(reverse=True)\n        \n        # Select up to three cells ensuring no two are in the same row or column\n        selected_rows = set()\n        selected_cols = set()\n        result = []\n        for val, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                selected_rows.add(row)\n                selected_cols.add(col)\n                result.append(val)\n                if len(result) == 3:\n                    break\n        \n        # Return the sum of the selected cell values\n        return sum(result)",
    "import heapq\n        from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Initialize heaps for rows and columns\n                row_heaps = [[] for _ in range(m)]\n                col_heaps = [[] for _ in range(n)]\n                \n                # Populate row heaps with top 3 values and their columns\n                for i in range(m):\n                    for j in range(n):\n                        if len(row_heaps[i]) < 3:\n                            heapq.heappush(row_heaps[i], (board[i][j], j))\n                        else:\n                            heapq.heappushpop(row_heaps[i], (board[i][j], j))\n                \n                # Populate col heaps with top 3 values and their rows\n                for j in range(n):\n                    for i in range(m):\n                        if len(col_heaps[j]) < 3:\n                            heapq.heappush(col_heaps[j], (board[i][j], i))\n                        else:\n                            heapq.heappushpop(col_heaps[j], (board[i][j], i))\n                \n                max_sum = float('-inf')\n                \n                # Iterate through all combinations of three rows\n                for row1 in range(m):\n                    for row2 in range(row1+1, m):\n                        for row3 in range(row2+1, m):\n                            # Get the top values from these rows\n                            candidates = []\n                            for val, col in row_heaps[row1]:\n                                candidates.append((val, col, row1))\n                            for val, col in row_heaps[row2]:\n                                candidates.append((val, col, row2))\n                            for val, col in row_heaps[row3]:\n                                candidates.append((val, col, row3))\n                            \n                            # Sort candidates in descending order\n                            candidates.sort(reverse=True)\n                            \n                            # Try to select three non-conflicting rooks\n                            selected = []\n                            cols_used = set()\n                            rows_used = set()\n                            for val, col, row in candidates:\n                                if col not in cols_used and row not in rows_used:\n                                    selected.append(val)\n                                    cols_used.add(col)\n                                    rows_used.add(row)\n                                    if len(selected) == 3:\n                                        break\n                            \n                            if len(selected) == 3:\n                                max_sum = max(max_sum, sum(selected))\n                \n                return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Step 1: Collect all cells with their values, row, and column indices\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort the cells in descending order of their values\n        cells.sort(reverse=True)\n        \n        # Step 3: Select up to three cells ensuring no two are in the same row or column\n        selected_rows = set()\n        selected_cols = set()\n        result = []\n        for val, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                selected_rows.add(row)\n                selected_cols.add(col)\n                result.append(val)\n                if len(result) == 3:\n                    break\n        \n        # Step 4: Return the sum of the selected cell values\n        return sum(result)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute row and column maximums\n                row_max = [[0] * n for _ in range(m)]\n                col_max = [[0] * m for _ in range(n)]\n                \n                for i in range(m):\n                    for j in range(n):\n                        row_max[i][j] = board[i][j] if j == 0 else max(board[i][j], row_max[i][j-1])\n                        col_max[j][i] = board[i][j] if i == 0 else max(board[i][j], col_max[j][i-1])\n                \n                max_sum = float('-inf')\n                \n                for i in range(m):\n                    for j in range(n):\n                        # Place first rook at (i, j)\n                        val1 = board[i][j]\n                        \n                        # Find the maximum value for the second rook in a different row and column\n                        val2 = float('-inf')\n                        for ii in range(m):\n                            if ii == i:\n                                continue\n                            max_in_row = row_max[ii][n-1]\n                            if j < n-1:\n                                max_in_row = max(row_max[ii][j], row_max[ii][n-1])\n                            val2 = max(val2, max_in_row)\n                        \n                        for jj in range(n):\n                            if jj == j:\n                                continue\n                            max_in_col = col_max[jj][m-1]\n                            if i < m-1:\n                                max_in_col = max(col_max[jj][i], col_max[jj][m-1])\n                            val2 = max(val2, max_in_col)\n                        \n                        # Find the maximum value for the third rook in a different row and column\n                        val3 = float('-inf')\n                        for ii in range(m):\n                            if ii == i:\n                                continue\n                            for jj in range(n):\n                                if jj == j:\n                                    continue\n                                if board[ii][jj] < val2:\n                                    continue\n                                # Ensure third rook is not in the same row or column as the second rook\n                                # This part needs further refinement to correctly handle the third rook's position\n                                val3 = max(val3, board[ii][jj])\n                        \n                        current_sum = val1 + val2 + val3\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n                \n                return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute row and column maximums\n        row_max = [[0] * n for _ in range(m)]\n        col_max = [[0] * m for _ in range(n)]\n        \n        for i in range(m):\n            for j in range(n):\n                row_max[i][j] = board[i][j] if j == 0 else max(board[i][j], row_max[i][j-1])\n                col_max[j][i] = board[i][j] if i == 0 else max(board[i][j], col_max[j][i-1])\n        \n        max_sum = float('-inf')\n        \n        for i in range(m):\n            for j in range(n):\n                # Place first rook at (i, j)\n                val1 = board[i][j]\n                \n                # Find the maximum value for the second rook in a different row and column\n                val2 = float('-inf')\n                for ii in range(m):\n                    if ii == i:\n                        continue\n                    max_in_row = row_max[ii][n-1]\n                    if j < n-1:\n                        max_in_row = max(row_max[ii][j], row_max[ii][n-1])\n                    val2 = max(val2, max_in_row)\n                \n                for jj in range(n):\n                    if jj == j:\n                        continue\n                    max_in_col = col_max[jj][m-1]\n                    if i < m-1:\n                        max_in_col = max(col_max[jj][i], col_max[jj][m-1])\n                    val2 = max(val2, max_in_col)\n                \n                # Find the maximum value for the third rook in a different row and column\n                val3 = float('-inf')\n                for ii in range(m):\n                    if ii == i:\n                        continue\n                    for jj in range(n):\n                        if jj == j:\n                            continue\n                        if board[ii][jj] < val2:\n                            continue\n                        # Ensure third rook is not in the same row or column as the second rook\n                        # This part needs further refinement to correctly handle the third rook's position\n                        val3 = max(val3, board[ii][jj])\n                \n                current_sum = val1 + val2 + val3\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Precompute row and column maximums\n        row_max = [[0] * n for _ in range(m)]\n        col_max = [[0] * m for _ in range(n)]\n        \n        for i in range(m):\n            for j in range(n):\n                if j == 0:\n                    row_max[i][j] = board[i][j]\n                else:\n                    row_max[i][j] = max(board[i][j], row_max[i][j-1])\n                if i == 0:\n                    col_max[j][i] = board[i][j]\n                else:\n                    col_max[j][i] = max(board[i][j], col_max[j][i-1])\n        \n        max_sum = float('-inf')\n        \n        for i in range(m):\n            for j in range(n):\n                # Place first rook at (i, j)\n                val1 = board[i][j]\n                \n                # Find the maximum value for the second rook in a different row and column\n                val2 = float('-inf')\n                for ii in range(m):\n                    if ii == i:\n                        continue\n                    if j == 0:\n                        val2 = max(val2, row_max[ii][n-1])\n                    else:\n                        val2 = max(val2, row_max[ii][n-1], row_max[ii][j-1])\n                \n                for jj in range(n):\n                    if jj == j:\n                        continue\n                    if i == 0:\n                        val2 = max(val2, col_max[jj][m-1])\n                    else:\n                        val2 = max(val2, col_max[jj][m-1], col_max[jj][i-1])\n                \n                # Find the maximum value for the third rook in a different row and column\n                val3 = float('-inf')\n                for ii in range(m):\n                    if ii == i:\n                        continue\n                    for jj in range(n):\n                        if jj == j:\n                            continue\n                        if board[ii][jj] < val2:\n                            continue\n                        # Ensure third rook is not in the same row or column as the second rook\n                        # This part needs further refinement to correctly handle the third rook's position\n                        val3 = max(val3, board[ii][jj])\n                \n                current_sum = val1 + val2 + val3\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        \n        return max_sum",
    "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        def backtrack(row, used_cols, current_sum):\n            if row == 3:\n                return current_sum\n            max_sum = float('-inf')\n            for i in range(m):\n                for j in range(n):\n                    if j not in used_cols and all(board[i][k] <= board[i][j] for k in range(n) if k != j):\n                        used_cols.add(j)\n                        max_sum = max(max_sum, backtrack(row + 1, used_cols, current_sum + board[i][j]))\n                        used_cols.remove(j)\n            return max_sum\n        \n        return backtrack(0, set(), 0)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute row and column sums for efficiency\n                row_sums = [sum(row) for row in board]\n                col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n                \n                # Initialize a list to store the top cells by value\n                top_cells = []\n                for i in range(m):\n                    for j in range(n):\n                        top_cells.append((board[i][j], i, j))\n                top_cells.sort(reverse=True)\n                \n                # Use sets to keep track of used rows and columns\n                used_rows = set()\n                used_cols = set()\n                result = []\n                \n                for val, row, col in top_cells:\n                    if row not in used_rows and col not in used_cols:\n                        used_rows.add(row)\n                        used_cols.add(col)\n                        result.append(val)\n                        if len(result) == 3:\n                            break\n                \n                return sum(result)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Create a list of all cells with their values, row, and column indices\n                cells = []\n                for i in range(m):\n                    for j in range(n):\n                        cells.append((board[i][j], i, j))\n                \n                # Sort the cells in descending order of their values\n                cells.sort(reverse=True)\n                \n                # Initialize sets to track used rows and columns\n                used_rows = set()\n                used_cols = set()\n                \n                # Initialize the result sum\n                result_sum = 0\n                # Initialize a counter for the number of rooks placed\n                rooks_placed = 0\n                \n                # Iterate through the sorted cells\n                for val, row, col in cells:\n                    # Check if the current cell's row and column are not used\n                    if row not in used_rows and col not in used_cols:\n                        # Place the rook\n                        used_rows.add(row)\n                        used_cols.add(col)\n                        result_sum += val\n                        rooks_placed += 1\n                        # If we have placed 3 rooks, break out of the loop\n                        if rooks_placed == 3:\n                            break\n                \n                return result_sum",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute row and column sums for efficiency\n                row_sums = [sum(row) for row in board]\n                col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n                \n                # Initialize a list to store the top cells by value\n                top_cells = []\n                for i in range(m):\n                    for j in range(n):\n                        top_cells.append((board[i][j], i, j))\n                top_cells.sort(reverse=True)\n                \n                # Use sets to keep track of used rows and columns\n                used_rows = set()\n                used_cols = set()\n                result = []\n                \n                for val, row, col in top_cells:\n                    if row not in used_rows and col not in used_cols:\n                        used_rows.add(row)\n                        used_cols.add(col)\n                        result.append(val)\n                        if len(result) == 3:\n                            break\n                \n                return sum(result)",
    "from typing import List\n\n        class Solution:\n            def maximumValueSum(self, board: List[List[int]]) -> int:\n                m, n = len(board), len(board[0])\n                \n                # Precompute top 3 cells in each row\n                row_top = []\n                for row in board:\n                    sorted_row = sorted(enumerate(row), key=lambda x: x[1], reverse=True)\n                    row_top.append(sorted_row[:3])\n                \n                # Precompute top 3 cells in each column\n                col_top = []\n                for j in range(n):\n                    column = [board[i][j] for i in range(m)]\n                    sorted_col = sorted(enumerate(column), key=lambda x: x[1], reverse=True)\n                    col_top.append(sorted_col[:3])\n                \n                max_sum = float('-inf')\n                \n                # Iterate through all combinations of row and column selections\n                for r1 in range(m):\n                    for c1 in range(n):\n                        val1 = board[r1][c1]\n                        # Get top 3 in row r1 and top 3 in column c1\n                        row_candidates = row_top[r1]\n                        col_candidates = col_top[c1]\n                        # Avoid using the same cell twice\n                        for (r2, val2) in row_candidates:\n                            if r2 != r1:\n                                for (c3, val3) in col_candidates:\n                                    if c3 != c1 and c3 != r2:\n                                        # Sum the values\n                                        current_sum = val1 + val2 + val3\n                                        if current_sum > max_sum:\n                                            max_sum = current_sum\n                return max_sum"
  ],
  "total_candidates": 39,
  "nodes_explored": 39,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        cells = []\n        \n        # Step 1: Flatten the board into a list of cells\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        \n        # Step 2: Sort cells by value in descending order\n        cells.sort(reverse=True)\n        \n        selected_rows = set()\n        selected_cols = set()\n        sum_values = 0\n        rooks_placed = 0\n        \n        # Step 4: Iterate through sorted cells and select up to three rooks\n        for value, row, col in cells:\n            if row not in selected_rows and col not in selected_cols:\n                sum_values += value\n                selected_rows.add(row)\n                selected_cols.add(col)\n                rooks_placed += 1\n                if rooks_placed == 3:\n                    break\n        \n        return sum_values",
      "solution_hash": "902ba3c374fdb81fc769eb22a0d92a9ea758c02304c58dbe390d6e14f861b836",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpf5gzl4n8.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpf5gzl4n8.py` failed. (See above for error)\n",
        "execution_time": 17.440513610839844,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "import heapq\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        # Flatten the board and store cells in a max heap based on cell values\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                heapq.heappush(heap, (-board[i][j], i, j))  # Use negative values for max heap\n        \n        used_rows = set()\n        used_cols = set()\n        sum_val = 0\n        for _ in range(3):\n            if not heap:\n                break  # If heap is empty, no more rooks can be placed\n            val, r, c = heapq.heappop(heap)\n            while heap and (r in used_rows or c in used_cols):\n                val, r, c = heapq.heappop(heap)\n            if r not in used_rows and c not in used_cols:\n                sum_val -= val  # Since we stored negative values\n                used_rows.add(r)\n                used_cols.add(c)\n        \n        return sum_val",
      "solution_hash": "f3b83cc786a3d119a9e02fb306bbc3c0b12be7c51dba876f9c775198cbd4de86",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpwbivrdi9.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpwbivrdi9.py` failed. (See above for error)\n",
        "execution_time": 15.55864143371582,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14",
        "1_18",
        "1_22"
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        \n        # Step 1: Flatten the board and sort cells by value in descending order\n        cells = []\n        for i in range(m):\n            for j in range(n):\n                cells.append((board[i][j], i, j))\n        cells.sort(reverse=True)\n        \n        selected = set()\n        result = []\n        for val, row, col in cells:\n            if row not in selected and col not in selected:\n                selected.add(row)\n                selected.add(col)\n                result.append(val)\n                if len(result) == 3:\n                    break\n        \n        return sum(result)",
      "solution_hash": "1b778ebc4df2f8edf898f26d81c14c3e42a3745535a5f2358ebf145e39762539",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmp7d88ogsz.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmp7d88ogsz.py` failed. (See above for error)\n",
        "execution_time": 17.839860439300537,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_27",
        "1_31",
        "1_35"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 39,
    "candidates_generated": 39,
    "tests_passed": 0,
    "tests_failed": 15,
    "test_errors": 24,
    "execution_times": [
      17.440513610839844,
      19.08259868621826,
      14.73474407196045,
      19.08259868621826,
      17.716200828552246,
      19.08259868621826,
      19.08259868621826,
      19.08259868621826,
      20.106597423553467,
      14.630040168762207,
      14.630040168762207,
      14.630040168762207,
      14.630040168762207,
      15.55864143371582,
      16.000173330307007,
      19.3448269367218,
      18.444281101226807,
      14.390590190887451,
      14.627297163009644,
      16.628302335739136,
      16.189594745635986,
      13.671215295791626,
      14.978341102600098,
      14.978341102600098,
      14.978341102600098,
      18.21920657157898,
      17.839860439300537,
      19.865824460983276,
      19.865824460983276,
      18.45354986190796,
      17.610426425933838,
      20.637597799301147,
      20.637597799301147,
      19.75864028930664,
      17.925029277801514,
      18.13220739364624,
      19.380841493606567,
      18.13220739364624,
      13.748194217681885
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 27,
      "unique_ratio": 0.6923076923076923,
      "similarity_score": 0.0,
      "solution_lengths": {
        "min": 719,
        "max": 2932,
        "avg": 1502.871794871795
      }
    },
    "test_case_analysis": {
      "hardest_cases": {},
      "first_failing_tests": {}
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 9,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 27,
          "improvements": 0,
          "solved": 0
        }
      },
      "error_types": {
        "other_error": {
          "attempts": 12,
          "improvements": 0
        }
      },
      "test_case_improvements": {},
      "error_transitions": {
        "other_error->other_error": 36
      }
    },
    "import_errors": 21,
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.6153846153846154,
        "solutions_per_depth": {
          "0": 3,
          "1": 9,
          "2": 27
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.0,
        "pass@3": 0.0,
        "pass@5": 0.0,
        "pass@10": 0.0
      },
      "solutions_evaluated": 40
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0
      },
      "error_recovery": {
        "total_attempts": 12,
        "total_improvements": 0,
        "recovery_rate": 0.0
      },
      "top_errors": [
        [
          "other_error",
          12
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      }
    }
  },
  "processing_time": 2492.5945394039154,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.0,
      "pass@3": 0.0,
      "pass@5": 0.0,
      "pass@10": 0.0
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 99)",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 37
          }
        ],
        [
          38,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: unexpected indent (<string>, line 100)",
            "completion_id": 38
          }
        ],
        [
          39,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 39
          }
        ]
      ]
    },
    "solutions_evaluated": 40,
    "test_cases": 1
  }
}