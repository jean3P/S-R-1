{
  "problem_id": "maximum-value-sum-by-placing-three-rooks-i",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -inf\n        \n        # Iterate through all possible triplets of cells\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum",
    "from itertools import combinations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Generate all possible combinations of 3 distinct rows\n        for rows in combinations(range(m), 3):\n            # Generate all possible combinations of 3 distinct columns\n            for cols in combinations(range(n), 3):\n                # Calculate the sum of the selected cells\n                current_sum = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        return max_sum",
    "from itertools import combinations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Generate all possible combinations of 3 distinct rows\n        for rows in combinations(range(m), 3):\n            # Generate all possible combinations of 3 distinct columns\n            for cols in combinations(range(n), 3):\n                # Calculate the sum of the selected cells\n                current_sum = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        return max_sum",
    "from itertools import combinations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Generate all possible combinations of 3 distinct rows\n        for rows in combinations(range(m), 3):\n            # Generate all possible combinations of 3 distinct columns\n            for cols in combinations(range(n), 3):\n                # Calculate the sum of the selected cells\n                current_sum = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        return max_sum",
    "from itertools import combinations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Generate all possible combinations of 3 distinct rows\n        for rows in combinations(range(m), 3):\n            # Generate all possible combinations of 3 distinct columns\n            for cols in combinations(range(n), 3):\n                # Calculate the sum of the selected cells\n                current_sum = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        return max_sum",
    "from itertools import combinations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Generate all possible combinations of 3 distinct rows\n        for rows in combinations(range(m), 3):\n            # Generate all possible combinations of 3 distinct columns\n            for cols in combinations(range(n), 3):\n                # Calculate the sum for the current triplet of cells\n                current_sum = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        return max_sum",
    "from itertools import combinations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Precompute the top 3 values and their columns for each row\n        row_top = []\n        for i in range(m):\n            row = board[i]\n            # Get the top 3 values along with their columns\n            sorted_row = sorted([(val, j) for j, val in enumerate(row)], key=lambda x: (-x[0], x[1]))\n            top3 = sorted_row[:3]\n            row_top.append(top3)\n        \n        # Iterate through all possible triplets of rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get the top 3 values for each of the three rows\n                    row1 = row_top[i]\n                    row2 = row_top[j]\n                    row3 = row_top[k]\n                    \n                    # Iterate through all possible combinations of columns for the three rows\n                    for c1 in row1:\n                        for c2 in row2:\n                            if c2[1] == c1[1]:\n                                continue  # same column, skip\n                            for c3 in row3:\n                                if c3[1] == c1[1] or c3[1] == c2[1]:\n                                    continue  # same column, skip\n                                current_sum = c1[0] + c2[0] + c3[0]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Iterate through all possible triplets of rows\n        for i in range(m):\n            for j in range(m):\n                if j == i:\n                    continue\n                for k in range(m):\n                    if k == i or k == j:\n                        continue\n                    # Now iterate through all possible triplets of columns\n                    for x in range(n):\n                        for y in range(n):\n                            if y == x:\n                                continue\n                            for z in range(n):\n                                if z == x or z == y:\n                                    continue\n                                # Calculate the sum for the current triplet of cells\n                                current_sum = board[i][x] + board[j][y] + board[k][z]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum",
    "from itertools import combinations, permutations\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -float('inf')\n        \n        # Generate all possible combinations of 3 distinct rows\n        for rows in combinations(range(m), 3):\n            # Generate all possible permutations of 3 distinct columns\n            for cols in permutations(range(n), 3):\n                # Calculate the sum for the current triplet of cells\n                current_sum = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Select 3 distinct rows\n        rows = list(itertools.combinations(range(m), 3))\n        max_sum = -float('inf')\n        \n        for selected_rows in rows:\n            # For each selected row, collect the top 3 values and their columns\n            row_values = []\n            for r in selected_rows:\n                # Get the top 3 values in the row, along with their columns\n                sorted_cells = sorted([(val, col) for col, val in enumerate(board[r])], reverse=True, key=lambda x: x[0])\n                row_values.append(sorted_cells[:3])\n            \n            # Now, we need to choose one cell from each row, ensuring all columns are distinct\n            # We'll generate all possible combinations of columns across the three rows\n            for c1 in range(len(row_values[0])):\n                for c2 in range(len(row_values[1])):\n                    for c3 in range(len(row_values[2])):\n                        # Check if all columns are distinct\n                        cols = [row_values[0][c1][1], row_values[1][c2][1], row_values[2][c3][1]]\n                        if len(set(cols)) == 3:\n                            current_sum = row_values[0][c1][0] + row_values[1][c2][0] + row_values[2][c3][0]\n                            if current_sum > max_sum:\n                                max_sum = current_sum\n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        max_sum = -float('inf')\n        \n        # Generate all possible combinations of 3 distinct rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each row, collect all possible cells\n            row_cells = []\n            for r in rows:\n                row_cells.append([(board[r][c], c) for c in range(n)])\n            \n            # Generate all possible combinations of cells from the three rows\n            for c1 in row_cells[0]:\n                for c2 in row_cells[1]:\n                    for c3 in row_cells[2]:\n                        # Check if all columns are distinct\n                        if c1[1] != c2[1] and c1[1] != c3[1] and c2[1] != c3[1]:\n                            current_sum = c1[0] + c2[0] + c3[0]\n                            if current_sum > max_sum:\n                                max_sum = current_sum\n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible triplets of cells\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the top 3 values and their columns for each row\n        top_rows = []\n        for r in range(m):\n            # Get the top 3 values in the row, along with their columns\n            sorted_cells = sorted([(val, col) for col, val in enumerate(board[r])], reverse=True, key=lambda x: x[0])\n            top_rows.append(sorted_cells[:3])\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible triplets of rows\n        for r1 in range(m):\n            for r2 in range(r1 + 1, m):\n                for r3 in range(r2 + 1, m):\n                    # Get the top 3 cells for each of the three rows\n                    row1 = top_rows[r1]\n                    row2 = top_rows[r2]\n                    row3 = top_rows[r3]\n                    \n                    # Iterate through all possible combinations of top cells in these rows\n                    for c1 in range(len(row1)):\n                        for c2 in range(len(row2)):\n                            for c3 in range(len(row3)):\n                                # Extract the columns\n                                col1 = row1[c1][1]\n                                col2 = row2[c2][1]\n                                col3 = row3[c3][1]\n                                \n                                # Check if all columns are distinct\n                                if col1 != col2 and col1 != col3 and col2 != col3:\n                                    current_sum = row1[c1][0] + row2[c2][0] + row3[c3][0]\n                                    if current_sum > max_sum:\n                                        max_sum = current_sum\n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the maximum values for each row and column\n        max_row = [max(row) for row in board]\n        max_col = [max(col) for col in zip(*board)]\n        \n        # Initialize DP tables\n        dp = [[-inf for _ in range(n)] for __ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = board[i][j] + max_row[i] + max_col[j]\n        \n        # Now, for each cell, find the best two other cells not in the same row or column\n        max_sum = -inf\n        for i in range(m):\n            for j in range(n):\n                current = board[i][j]\n                # Find the best two cells in different rows and columns\n                for x in range(m):\n                    if x == i:\n                        continue\n                    for y in range(n):\n                        if y == j:\n                            continue\n                        if dp[x][y] > max_sum:\n                            max_sum = dp[x][y] + current\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible triplets of cells\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the top three values in each row and their columns\n        row_top = []\n        for i in range(m):\n            row = board[i]\n            sorted_row = sorted([(val, j) for j, val in enumerate(row)], reverse=True)\n            row_top.append(sorted_row[:3])\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all combinations of three different rows\n        for i1 in range(m):\n            for i2 in range(i1 + 1, m):\n                for i3 in range(i2 + 1, m):\n                    # Get top 3 values from each row\n                    r1 = row_top[i1]\n                    r2 = row_top[i2]\n                    r3 = row_top[i3]\n                    \n                    # Check all combinations of columns from each row's top 3\n                    for j1, val1 in r1:\n                        for j2, val2 in r2:\n                            if j2 == j1:\n                                continue\n                            for j3, val3 in r3:\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = val1 + val2 + val3\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the top 3 values and their columns for each row\n        row_top = []\n        for i in range(m):\n            # Get the top 3 values and their columns\n            sorted_row = sorted([(val, j) for j, val in enumerate(board[i])], key=lambda x: (-x[0], x[1]))\n            top = sorted_row[:3]\n            row_top.append(top)\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all combinations of 3 distinct rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each row, get the top 3 candidates\n            candidates = [row_top[r] for r in rows]\n            # Generate all possible triplets of columns from these candidates\n            for c1 in candidates[0]:\n                for c2 in candidates[1]:\n                    if c2[1] == c1[1]:\n                        continue\n                    for c3 in candidates[2]:\n                        if c3[1] == c1[1] or c3[1] == c2[1]:\n                            continue\n                        current_sum = c1[0] + c2[0] + c3[0]\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the top 3 values for each row and column\n        row_top = []\n        for i in range(m):\n            row = board[i]\n            sorted_row = sorted([(val, j) for j, val in enumerate(row)], reverse=True)\n            row_top.append(sorted_row[:3])\n        \n        col_top = []\n        for j in range(n):\n            column = [board[i][j] for i in range(m)]\n            sorted_col = sorted([(val, i) for i, val in enumerate(column)], reverse=True)\n            col_top.append(sorted_col[:3])\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible combinations of top candidates\n        for i1 in range(m):\n            for j1, val1 in row_top[i1]:\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2, val2 in row_top[i2]:\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3, val3 in row_top[i3]:\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = val1 + val2 + val3\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible triplets of rows and columns\n        for r1 in range(m):\n            for c1 in range(n):\n                for r2 in range(m):\n                    if r2 == r1:\n                        continue\n                    for c2 in range(n):\n                        if c2 == c1:\n                            continue\n                        for r3 in range(m):\n                            if r3 == r1 or r3 == r2:\n                                continue\n                            for c3 in range(n):\n                                if c3 == c1 or c3 == c2:\n                                    continue\n                                current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the top 3 values for each row and column\n        row_top = []\n        for row in board:\n            sorted_row = sorted([(val, idx) for idx, val in enumerate(row)], reverse=True)\n            row_top.append(sorted_row[:3])\n        \n        col_top = []\n        for col in range(n):\n            column = [board[row][col] for row in range(m)]\n            sorted_col = sorted([(val, idx) for idx, val in enumerate(column)], reverse=True)\n            col_top.append(sorted_col[:3])\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible combinations of rows and columns\n        for i in range(m):\n            for j in range(n):\n                current_val = board[i][j]\n                # Get top 3 values from row i, excluding column j\n                for r1_val, r1_col in row_top[i]:\n                    if r1_col == j:\n                        continue\n                    # Get top 3 values from column j, excluding row i\n                    for c1_val, c1_row in col_top[j]:\n                        if c1_row == i or c1_row == r1_col:\n                            continue\n                        # Now, find the best third rook that doesn't conflict with the first two\n                        # Check all rows except i and c1_row, and all columns except j and r1_col\n                        for r3 in range(m):\n                            if r3 == i or r3 == c1_row:\n                                continue\n                            for c3 in range(n):\n                                if c3 == j or c3 == r1_col:\n                                    continue\n                                current_sum = current_val + r1_val + c1_val + board[r3][c3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute top 3 values and their columns for each row\n        row_top = []\n        for row in board:\n            sorted_row = sorted([(val, col) for col, val in enumerate(row)], reverse=True)\n            row_top.append(sorted_row[:3])\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible combinations of three rows\n        for i in range(m):\n            for j in range(i+1, m):\n                for k in range(j+1, m):\n                    # Get top 3 values from each of the three rows\n                    top_i = row_top[i]\n                    top_j = row_top[j]\n                    top_k = row_top[k]\n                    \n                    # Check all combinations of columns from the top values\n                    for ci in range(len(top_i)):\n                        for cj in range(len(top_j)):\n                            if top_i[ci][1] == top_j[cj][1]:\n                                continue\n                            for ck in range(len(top_k)):\n                                if top_i[ci][1] == top_k[ck][1] or top_j[cj][1] == top_k[ck][1]:\n                                    continue\n                                current_sum = top_i[ci][0] + top_j[cj][0] + top_k[ck][0]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute top 3 values and their columns for each row\n        row_top = []\n        for row in board:\n            sorted_row = sorted([(val, col) for col, val in enumerate(row)], reverse=True)\n            row_top.append(sorted_row[:3])\n        \n        # Precompute top 3 values and their rows for each column\n        col_top = []\n        for col in range(n):\n            column = [board[row][col] for row in range(m)]\n            sorted_col = sorted([(val, row) for row, val in enumerate(column)], reverse=True)\n            col_top.append(sorted_col[:3])\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible combinations of three rows\n        for r1 in range(m):\n            for r2 in range(r1+1, m):\n                for r3 in range(r2+1, m):\n                    # Get top 3 values for each row\n                    top_r1 = row_top[r1]\n                    top_r2 = row_top[r2]\n                    top_r3 = row_top[r3]\n                    \n                    # Collect all possible column indices for each top value\n                    cols_r1 = [t[1] for t in top_r1]\n                    cols_r2 = [t[1] for t in top_r2]\n                    cols_r3 = [t[1] for t in top_r3]\n                    \n                    # Check all combinations of columns from each row's top\n                    for c1 in cols_r1:\n                        for c2 in cols_r2:\n                            if c2 == c1:\n                                continue\n                            for c3 in cols_r3:\n                                if c3 == c1 or c3 == c2:\n                                    continue\n                                # Calculate the sum of the selected cells\n                                current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible triplets of cells\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute top 3 values and their columns for each row\n        row_top = []\n        for i in range(m):\n            sorted_row = sorted([(board[i][j], j) for j in range(n)], key=lambda x: (-x[0], x[1]))\n            top3 = sorted_row[:3]\n            row_top.append(top3)\n        \n        # Precompute top 3 values and their rows for each column\n        col_top = []\n        for j in range(n):\n            sorted_col = sorted([(board[i][j], i) for i in range(m)], key=lambda x: (-x[0], x[1]))\n            top3 = sorted_col[:3]\n            col_top.append(top3)\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible combinations of rows and columns\n        for i1 in range(m):\n            for j1 in range(n):\n                # Skip if current cell is not in top 3 of its row or column\n                if (board[i1][j1], j1) not in row_top[i1] or (board[i1][j1], i1) not in col_top[j1]:\n                    continue\n                # Consider all possible pairs from other rows and columns\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        # Check if (i2, j2) is in top 3 of its row and column\n                        if (board[i2][j2], j2) not in row_top[i2] or (board[i2][j2], i2) not in col_top[j2]:\n                            continue\n                        # Now, find the best third rook that doesn't share row or column\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                # Check if (i3, j3) is in top 3 of its row and column\n                                if (board[i3][j3], j3) not in row_top[i3] or (board[i3][j3], i3) not in col_top[j3]:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the top 3 values and their columns for each row\n        row_max = []\n        for i in range(m):\n            sorted_row = sorted([(board[i][j], j) for j in range(n)], reverse=True)\n            row_max.append(sorted_row[:3])\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all combinations of three distinct rows\n        for i1 in range(m):\n            for i2 in range(i1 + 1, m):\n                for i3 in range(i2 + 1, m):\n                    # Get top 3 columns for each of the three rows\n                    r1 = row_max[i1]\n                    r2 = row_max[i2]\n                    r3 = row_max[i3]\n                    \n                    # Check all combinations of columns from the top 3 of each row\n                    for c1 in r1:\n                        for c2 in r2:\n                            if c2[1] == c1[1]:\n                                continue\n                            for c3 in r3:\n                                if c3[1] == c1[1] or c3[1] == c2[1]:\n                                    continue\n                                current_sum = c1[0] + c2[0] + c3[0]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the top 3 values and their columns for each row\n        row_top = []\n        for row in board:\n            # Get the top 3 values and their columns\n            sorted_cells = sorted([(val, col) for col, val in enumerate(row)], reverse=True)\n            top3 = sorted_cells[:3]\n            row_top.append(top3)\n        \n        max_sum = -float('inf')\n        \n        # Iterate through all possible combinations of 3 rows\n        for i1 in range(m):\n            for i2 in range(i1+1, m):\n                for i3 in range(i2+1, m):\n                    # Get the top 3 cells for each of the selected rows\n                    r1 = row_top[i1]\n                    r2 = row_top[i2]\n                    r3 = row_top[i3]\n                    \n                    # Iterate through all possible combinations of columns from each row's top 3\n                    for c1 in r1:\n                        for c2 in r2:\n                            if c2[1] == c1[1]:\n                                continue\n                            for c3 in r3:\n                                if c3[1] == c1[1] or c3[1] == c2[1]:\n                                    continue\n                                current_sum = c1[0] + c2[0] + c3[0]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -inf\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each triplet, collect the columns and their maximum values\n            columns = []\n            for r in rows:\n                max_val = -inf\n                max_col = -1\n                for c in range(n):\n                    if board[r][c] > max_val:\n                        max_val = board[r][c]\n                        max_col = c\n                columns.append((max_val, max_col))\n            \n            # Check if all columns are unique\n            used_cols = set()\n            valid = True\n            for val, col in columns:\n                if col in used_cols:\n                    valid = False\n                    break\n                used_cols.add(col)\n            if valid:\n                current_sum = sum(val for val, col in columns)\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each triplet, collect the columns and their maximum values\n            columns = []\n            for r in rows:\n                max_val = float('-inf')\n                max_col = -1\n                for c in range(n):\n                    if board[r][c] > max_val:\n                        max_val = board[r][c]\n                        max_col = c\n                columns.append((max_val, max_col))\n            \n            # Check if all columns are unique\n            used_cols = set()\n            valid = True\n            for val, col in columns:\n                if col in used_cols:\n                    valid = False\n                    break\n                used_cols.add(col)\n            if valid:\n                current_sum = sum(val for val, col in columns)\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = float('-inf')\n        \n        # Iterate through all possible triplets of cells\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = float('-inf')\n        \n        # Generate all possible triplets of cells with distinct rows and columns\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = float('-inf')\n        \n        # Precompute the top 3 columns for each row\n        row_top3 = []\n        for r in range(m):\n            # Get the top 3 values and their columns\n            sorted_cols = sorted([(board[r][c], c) for c in range(n)], reverse=True)\n            top3 = sorted_cols[:3]\n            row_top3.append(top3)\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # Collect all possible column combinations for these rows\n            cols_combinations = itertools.product(*[row_top3[r] for r in rows])\n            for cols in cols_combinations:\n                # Extract the columns and their values\n                used_cols = []\n                current_sum = 0\n                valid = True\n                for val, col in cols:\n                    if col in used_cols:\n                        valid = False\n                        break\n                    used_cols.append(col)\n                    current_sum += val\n                if valid and current_sum > max_sum:\n                    max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each row in the triplet, find the top 3 columns with highest values\n            row_data = []\n            for r in rows:\n                # Get the top 3 columns for this row\n                top_cols = sorted([(board[r][c], c) for c in range(n)], reverse=True, key=lambda x: x[0])[:3]\n                row_data.append(top_cols)\n            \n            # Now, we need to select one column from each row's top 3, ensuring all are unique\n            # This is a combinatorial problem, but since each row has up to 3 options, it's manageable\n            # We'll generate all possible combinations of columns from the top 3 of each row\n            from itertools import product\n            for cols in product(*[range(len(rd)) for rd in row_data]):\n                selected_cols = [row_data[i][cols[i]][1] for i in range(3)]\n                if len(set(selected_cols)) == 3:\n                    current_sum = sum(row_data[i][cols[i]][0] for i in range(3))\n                    if current_sum > max_sum:\n                        max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            row_data = []\n            for r in rows:\n                # Get all possible columns for this row, sorted by value descending\n                sorted_cols = sorted([(board[r][c], c) for c in range(n)], reverse=True, key=lambda x: x[0])\n                # Take top 3 columns for this row\n                top_cols = sorted_cols[:3]\n                row_data.append(top_cols)\n            \n            # Generate all possible combinations of column indices from the top 3 of each row\n            for cols in itertools.product(*[range(len(rd)) for rd in row_data]):\n                # Extract the actual column indices\n                selected_cols = [row_data[i][cols[i]][1] for i in range(3)]\n                # Check if all columns are unique\n                if len(set(selected_cols)) == 3:\n                    # Calculate the sum of the selected cells\n                    current_sum = sum(row_data[i][cols[i]][0] for i in range(3))\n                    if current_sum > max_sum:\n                        max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each row, collect all possible column values\n            row_data = []\n            for r in rows:\n                row = board[r]\n                # Create a list of tuples (value, column index)\n                row_values = [(row[c], c) for c in range(n)]\n                row_data.append(row_values)\n            \n            # Now, find all possible column combinations where each column is unique\n            # We'll use backtracking to explore all possibilities\n            def backtrack(index, used_cols, current_sum):\n                nonlocal max_sum\n                if index == 3:\n                    if current_sum > max_sum:\n                        max_sum = current_sum\n                    return\n                for val, col in row_data[index]:\n                    if col not in used_cols:\n                        backtrack(index + 1, used_cols | {col}, current_sum + val)\n            \n            backtrack(0, set(), 0)\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            row_data = []\n            for r in rows:\n                # Get the top 3 columns for this row\n                top_cols = sorted([(board[r][c], c) for c in range(n)], reverse=True)[:3]\n                row_data.append(top_cols)\n            \n            # Generate all possible combinations of column indices from the top 3 of each row\n            for cols in itertools.product(*[range(len(rd)) for rd in row_data]):\n                selected_cols = [row_data[i][cols[i]][1] for i in range(3)]\n                if len(set(selected_cols)) == 3:\n                    current_sum = sum(row_data[i][cols[i]][0] for i in range(3))\n                    if current_sum > max_sum:\n                        max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Precompute the top 3 columns for each row\n        row_top = []\n        for r in range(m):\n            # Get the top 3 values and their columns\n            sorted_cols = sorted([(board[r][c], c) for c in range(n)], reverse=True)\n            top3 = sorted_cols[:3]\n            row_top.append(top3)\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each row in the triplet, collect the top 3 columns\n            candidates = []\n            for r in rows:\n                candidates.append(row_top[r])\n            \n            # Generate all possible combinations of columns from the top3 of each row\n            for c1 in candidates[0]:\n                for c2 in candidates[1]:\n                    if c2[1] == c1[1]:\n                        continue\n                    for c3 in candidates[2]:\n                        if c3[1] == c1[1] or c3[1] == c2[1]:\n                            continue\n                        current_sum = c1[0] + c2[0] + c3[0]\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each row in the triplet, collect all possible columns\n            row1, row2, row3 = rows\n            # Generate all possible column combinations for the three rows\n            for c1 in range(n):\n                for c2 in range(n):\n                    if c2 == c1:\n                        continue\n                    for c3 in range(n):\n                        if c3 == c1 or c3 == c2:\n                            continue\n                        current_sum = board[row1][c1] + board[row2][c2] + board[row3][c3]\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n        \n        return max_sum",
    "import itertools\n\nclass Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Precompute the top 3 columns for each row\n        row_top = []\n        for r in range(m):\n            # Get the top 3 values and their columns\n            sorted_cols = sorted([(board[r][c], c) for c in range(n)], key=lambda x: (-x[0], x[1]))\n            top3 = sorted_cols[:3]\n            row_top.append(top3)\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each row in the triplet, collect the top 3 columns\n            candidates = [row_top[r] for r in rows]\n            \n            # Generate all possible combinations of columns from the top3 of each row\n            for c1 in candidates[0]:\n                for c2 in candidates[1]:\n                    if c2[1] == c1[1]:\n                        continue\n                    for c3 in candidates[2]:\n                        if c3[1] == c1[1] or c3[1] == c2[1]:\n                            continue\n                        current_sum = c1[0] + c2[0] + c3[0]\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n        \n        return max_sum",
    "class Solution:\n    def maximumValueSum(self, board: list[list[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -float('inf')\n        \n        # Generate all possible triplets of cells\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum"
  ],
  "total_candidates": 39,
  "nodes_explored": 39,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        max_sum = -inf\n        \n        # Iterate through all possible triplets of cells\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(m):\n                    if i2 == i1:\n                        continue\n                    for j2 in range(n):\n                        if j2 == j1:\n                            continue\n                        for i3 in range(m):\n                            if i3 == i1 or i3 == i2:\n                                continue\n                            for j3 in range(n):\n                                if j3 == j1 or j3 == j2:\n                                    continue\n                                current_sum = board[i1][j1] + board[i2][j2] + board[i3][j3]\n                                if current_sum > max_sum:\n                                    max_sum = current_sum\n        return max_sum",
      "solution_hash": "b6f1a77f91f452349a119698257c99dde321f935ac314678f0d2c300151020e3",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmp6uq9zemb.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmp6uq9zemb.py` failed. (See above for error)\n",
        "execution_time": 14.695626258850098,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0]) if m > 0 else 0\n        \n        # Precompute the maximum values for each row and column\n        max_row = [max(row) for row in board]\n        max_col = [max(col) for col in zip(*board)]\n        \n        # Initialize DP tables\n        dp = [[-inf for _ in range(n)] for __ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = board[i][j] + max_row[i] + max_col[j]\n        \n        # Now, for each cell, find the best two other cells not in the same row or column\n        max_sum = -inf\n        for i in range(m):\n            for j in range(n):\n                current = board[i][j]\n                # Find the best two cells in different rows and columns\n                for x in range(m):\n                    if x == i:\n                        continue\n                    for y in range(n):\n                        if y == j:\n                            continue\n                        if dp[x][y] > max_sum:\n                            max_sum = dp[x][y] + current\n        \n        return max_sum",
      "solution_hash": "9b8e04ed3cfd86dd4b65c2aeef852924b1caeb83557e7da8a37be89f78a4c45c",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpajbta4rd.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpajbta4rd.py` failed. (See above for error)\n",
        "execution_time": 13.541038990020752,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14",
        "1_18",
        "1_22"
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m = len(board)\n        n = len(board[0])\n        max_sum = -inf\n        \n        # Iterate over all possible triplets of rows\n        for rows in itertools.combinations(range(m), 3):\n            # For each triplet, collect the columns and their maximum values\n            columns = []\n            for r in rows:\n                max_val = -inf\n                max_col = -1\n                for c in range(n):\n                    if board[r][c] > max_val:\n                        max_val = board[r][c]\n                        max_col = c\n                columns.append((max_val, max_col))\n            \n            # Check if all columns are unique\n            used_cols = set()\n            valid = True\n            for val, col in columns:\n                if col in used_cols:\n                    valid = False\n                    break\n                used_cols.add(col)\n            if valid:\n                current_sum = sum(val for val, col in columns)\n                if current_sum > max_sum:\n                    max_sum = current_sum\n        \n        return max_sum",
      "solution_hash": "8115a4823585fe883c662cb42febedb9faf3c6e41b1340168017ca8ff51aa73f",
      "test_result": {
        "status": "import_error",
        "error_message": "Missing required module: sortedcontainers",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpnie4tvk1.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpnie4tvk1.py` failed. (See above for error)\n",
        "execution_time": 13.583657026290894,
        "import_failures": [
          "sortedcontainers"
        ]
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_27",
        "1_31",
        "1_35"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 39,
    "candidates_generated": 39,
    "tests_passed": 0,
    "tests_failed": 0,
    "test_errors": 39,
    "execution_times": [
      14.695626258850098,
      14.602914094924927,
      14.602914094924927,
      14.602914094924927,
      14.602914094924927,
      14.602914094924927,
      14.049921751022339,
      13.659218549728394,
      13.59562087059021,
      13.549285173416138,
      14.655878782272339,
      13.55900502204895,
      13.585090637207031,
      13.541038990020752,
      13.55900502204895,
      14.709576606750488,
      13.532836437225342,
      13.661459922790527,
      13.576797246932983,
      14.660385131835938,
      13.590595245361328,
      13.623124599456787,
      13.55900502204895,
      14.917285919189453,
      13.53845763206482,
      13.567983150482178,
      13.583657026290894,
      14.028410196304321,
      14.317384481430054,
      13.520653486251831,
      15.890475273132324,
      13.599902391433716,
      13.832725286483765,
      13.601302862167358,
      13.633851766586304,
      13.534405946731567,
      14.826003551483154,
      13.653148889541626,
      13.62083387374878
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 33,
      "unique_ratio": 0.8461538461538461,
      "similarity_score": 0.0,
      "solution_lengths": {
        "min": 723,
        "max": 2485,
        "avg": 1254.7948717948718
      }
    },
    "test_case_analysis": {
      "hardest_cases": {},
      "first_failing_tests": {}
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 9,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 27,
          "improvements": 0,
          "solved": 0
        }
      },
      "error_types": {
        "other_error": {
          "attempts": 12,
          "improvements": 0
        }
      },
      "test_case_improvements": {},
      "error_transitions": {
        "other_error->other_error": 36
      }
    },
    "import_errors": 36,
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.6153846153846154,
        "solutions_per_depth": {
          "0": 3,
          "1": 9,
          "2": 27
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.0,
        "pass@3": 0.0,
        "pass@5": 0.0,
        "pass@10": 0.0
      },
      "solutions_evaluated": 40
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0
      },
      "error_recovery": {
        "total_attempts": 12,
        "total_improvements": 0,
        "recovery_rate": 0.0
      },
      "top_errors": [
        [
          "other_error",
          12
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      }
    }
  },
  "processing_time": 2587.0903680324554,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.0,
      "pass@3": 0.0,
      "pass@5": 0.0,
      "pass@10": 0.0
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 37
          }
        ],
        [
          38,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 38
          }
        ],
        [
          39,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: No module named 'sortedcontainers'",
            "completion_id": 39
          }
        ]
      ]
    },
    "solutions_evaluated": 40,
    "test_cases": 1
  }
}