{
  "problem_id": "count-almost-equal-pairs-ii",
  "problem_title": "",
  "difficulty": "Hard",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = str(num)\n            variants = set()\n            variants.add(s)\n            n = len(s)\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            variants.add(''.join(s))\n            # First swap\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    # Second swap\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            swapped2 = swapped.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            # Add the original number\n            variants.add(''.join(s))\n            # Generate all possible one-swap variants\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two-swap variants\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    # Now perform a second swap on the swapped array\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            swapped2 = swapped.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            # For each variant, add the count of how many times it has been seen before\n            for v in variants:\n                total += count_map.get(v, 0)\n            # Update the count_map with the current variants\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            # Add the original number\n            variants.add(''.join(s))\n            # Generate all possible one-swap variants\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two-swap variants\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    # Now perform a second swap on swapped1\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_key(num):\n            s = list(str(num))\n            s_sorted = sorted(s)\n            return tuple(s_sorted)\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            key = get_key(num)\n            total += count_map.get(key, 0)\n            count_map[key] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            variants = set()\n            variants.add(''.join(s))\n            n = len(s)\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible double swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            variants.add(''.join(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if k == i and l == j:\n                                continue  # Skip if same swap\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            # Convert the number to a sorted tuple of its digits\n            key = tuple(sorted(str(num)))\n            total += count_map[key]\n            count_map[key] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            variants.add(''.join(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom itertools import permutations\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = str(num)\n            n = len(s)\n            seen = set()\n            for p in permutations(s):\n                seen.add(''.join(p))\n            return seen\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            variants.add(''.join(s))  # original number\n            \n            # Generate all possible one-swap variants\n            for i in range(n):\n                for j in range(i+1, n):\n                    s[i], s[j] = s[j], s[i]\n                    variants.add(''.join(s))\n                    s[i], s[j] = s[j], s[i]  # swap back\n            \n            # Generate all possible two-swap variants\n            for i in range(n):\n                for j in range(i+1, n):\n                    s[i], s[j] = s[j], s[i]\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            s[k], s[l] = s[l], s[k]\n                            variants.add(''.join(s))\n                            s[k], s[l] = s[l], s[k]  # swap back\n                    s[i], s[j] = s[j], s[i]  # swap back\n            \n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def get_key(num):\n            s = str(num)\n            return tuple(sorted(s))\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            key = get_key(num)\n            total += count_map.get(key, 0)\n            count_map[key] += 1\n        return total",
    "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            variants.add(''.join(s))  # include the original number\n            \n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    s[i], s[j] = s[j], s[i]\n                    variants.add(''.join(s))\n                    s[i], s[j] = s[j], s[i]  # swap back\n            \n            # Generate all possible double swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    s[i], s[j] = s[j], s[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if k == i or k == j or l == i or l == j:\n                                continue\n                            s[k], s[l] = s[l], s[k]\n                            variants.add(''.join(s))\n                            s[k], s[l] = s[l], s[k]  # swap back\n                    s[i], s[j] = s[j], s[i]  # swap back\n            \n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = str(num)\n            n = len(s)\n            variants = set()\n            variants.add(s)\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                count_map[v] += 1\n        \n        total = 0\n        for cnt in count_map.values():\n            if cnt >= 2:\n                total += cnt * (cnt - 1) // 2\n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        for num in nums:\n            s = str(num)\n            key = tuple(sorted(s))\n            count_map[key] += 1\n        \n        total = 0\n        for cnt in count_map.values():\n            if cnt >= 2:\n                total += cnt * (cnt - 1) // 2\n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_transformations(num_str):\n            transformations = set()\n            n = len(num_str)\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    transformations.add(''.join(swapped))\n                    # Generate all possible double swaps\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if k == i or k == j or l == i or l == j:\n                                continue\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            transformations.add(''.join(swapped2))\n            return transformations\n        \n        count_map = defaultdict(int)\n        for num in nums:\n            s = str(num)\n            count_map[s] += 1\n        \n        total = 0\n        for num in nums:\n            s = str(num)\n            transforms = generate_transformations(s)\n            for t in transforms:\n                if t in count_map:\n                    total += count_map[t]\n            # Add the count for the original number (no swaps needed)\n            total += count_map[s] - 1  # Subtract 1 to avoid counting itself\n        \n        # Each pair is counted twice, so divide by 2\n        return total // 2",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_equal(x, y):\n            x_str = str(x)\n            y_str = str(y)\n            if len(x_str) != len(y_str):\n                return False\n            diff = []\n            for a, b in zip(x_str, y_str):\n                if a != b:\n                    diff.append((a, b))\n            if len(diff) == 0:\n                return True\n            if len(diff) == 2:\n                a1, b1 = diff[0]\n                a2, b2 = diff[1]\n                return (a1 == b2 and b1 == a2) or (a1 == a2 and b1 == b2)\n            if len(diff) == 4:\n                a1, b1 = diff[0]\n                a2, b2 = diff[1]\n                a3, b3 = diff[2]\n                a4, b4 = diff[3]\n                return (a1 == b2 and b1 == a2 and a3 == b4 and b3 == a4) or \\\n                       (a1 == a2 and b1 == b2 and a3 == a4 and b3 == b4)\n            return False\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if can_be_equal(nums[i], nums[j]):\n                    count +=1\n        return count",
    "from itertools import combinations\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_swaps(s):\n            swaps = set()\n            swaps.add(s)\n            n = len(s)\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    swapped_str = ''.join(swapped)\n                    swaps.add(swapped_str)\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            if k == i and l == j:\n                                continue\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            swaps.add(''.join(swapped2))\n            return swaps\n        \n        count_map = defaultdict(int)\n        for num in nums:\n            s = str(num)\n            swaps = generate_swaps(s)\n            for swap in swaps:\n                count_map[swap] += 1\n        \n        total = 0\n        for cnt in count_map.values():\n            if cnt >= 2:\n                total += cnt * (cnt - 1) // 2\n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = str(num)\n            n = len(s)\n            variants = set()\n            # 0 swaps: the number itself\n            variants.add(s)\n            # 1 swap\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # 2 swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped1 = list(s)\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            swapped2 = list(swapped1)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        variant_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            variants = generate_variants(num)\n            for v in variants:\n                variant_indices[v].append(idx)\n        \n        total = 0\n        for indices in variant_indices.values():\n            count = len(indices)\n            if count >= 2:\n                total += count * (count - 1) // 2\n        \n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        digit_counts = defaultdict(int)\n        for num in nums:\n            key = tuple(sorted(str(num)))\n            digit_counts[key] += 1\n        \n        total = 0\n        for count in digit_counts.values():\n            if count >= 2:\n                total += count * (count - 1) // 2\n        \n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_be_equal(x, y):\n            x_str = str(x)\n            y_str = str(y)\n            if len(x_str) != len(y_str):\n                return False\n            diff = []\n            for a, b in zip(x_str, y_str):\n                if a != b:\n                    diff.append((a, b))\n            if len(diff) > 4:\n                return False\n            if len(diff) % 2 != 0:\n                return False\n            return len(diff) // 2 <= 2\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_be_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            variants.add(''.join(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible double swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        variant_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            variants = generate_variants(num)\n            for v in variants:\n                variant_indices[v].append(idx)\n        \n        total = 0\n        for indices in variant_indices.values():\n            count = len(indices)\n            if count >= 2:\n                total += count * (count - 1) // 2\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        from itertools import combinations\n\n        def generate_variants(num):\n            s = str(num)\n            n = len(s)\n            variants = set()\n            variants.add(s)\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            variants = generate_variants(num)\n            for var in variants:\n                total += count_map.get(var, 0)\n            count_map[num] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            # Add the original number\n            variants.add(''.join(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            # Convert to integers to handle leading zeros\n            return {int(var) for var in variants}\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            variants = generate_variants(num)\n            # Check each variant in the map\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Increment the count for the current number\n            count_map[num] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            # Add the original number\n            variants.add(''.join(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            # Convert to integers to handle leading zeros\n            return {int(var) for var in variants}\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            variants = generate_variants(num)\n            # Check each variant in the map\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Increment the count for the current number\n            count_map[num] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(num):\n            s = list(str(num))\n            n = len(s)\n            variants = set()\n            # Add the original number\n            variants.add(''.join(s))\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i + 1, n):\n                    swapped1 = s.copy()\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(k + 1, n):\n                            if k == i and l == j:\n                                continue  # Skip if same swap\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            # Convert to integers to handle leading zeros\n            return {int(var) for var in variants}\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            variants = generate_variants(num)\n            # Check each variant in the map\n            for var in variants:\n                total += count_map.get(var, 0)\n            # Increment the count for the current number\n            count_map[num] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def get_key(num):\n            s = list(str(num))\n            return tuple(sorted(s))\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            key = get_key(num)\n            total += count_map.get(key, 0)\n            count_map[key] += 1\n\n        return total",
    "from itertools import permutations\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: list[int]) -> int:\n        def get_permutations(num_str):\n            perms = set()\n            for p in permutations(num_str):\n                perms.add(''.join(p))\n            return perms\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            num_str = str(num)\n            perms = get_permutations(num_str)\n            for perm in perms:\n                total += count_map.get(perm, 0)\n            count_map[num_str] += 1\n        \n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: list[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            variants.add(num_str)\n            n = len(num_str)\n            # Generate all possible single swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Generate all possible two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped1 = list(num_str)\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    swapped1_str = ''.join(swapped1)\n                    # Now swap again in swapped1_str\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped1_str)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            for variant in variants:\n                total += count_map.get(variant, 0)\n            count_map[num_str] += 1\n        \n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: list[int]) -> int:\n        def generate_variants(num_str):\n            variants = set()\n            n = len(num_str)\n            # 0 swaps: original\n            variants.add(num_str)\n            # 1 swap: swap any two different positions\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # 2 swaps: swap any two pairs, including same positions\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    swapped1 = list(num_str)\n                    swapped1[i], swapped1[j] = swapped1[j], swapped1[i]\n                    for k in range(n):\n                        for l in range(n):\n                            if k == l:\n                                continue\n                            swapped2 = swapped1.copy()\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            num_str = str(num)\n            variants = generate_variants(num_str)\n            for variant in variants:\n                total += count_map.get(variant, 0)\n            count_map[num_str] += 1\n        \n        return total",
    "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: list[int]) -> int:\n        def generate_swaps(num_str):\n            swaps = set()\n            swaps.add(num_str)\n            n = len(num_str)\n            # Generate all possible numbers after one swap\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    swaps.add(''.join(swapped))\n            # Generate all possible numbers after two swaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(num_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    # Now perform a second swap on the swapped string\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            swaps.add(''.join(swapped2))\n            return swaps\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            num_str = str(num)\n            swaps = generate_swaps(num_str)\n            for s in swaps:\n                total += count_map.get(s, 0)\n            count_map[num_str] += 1\n        \n        return total"
  ],
  "total_candidates": 31,
  "nodes_explored": 31,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = str(num)\n            variants = set()\n            variants.add(s)\n            n = len(s)\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        return total",
      "solution_hash": "30eea27306c56431fd90d848665d4357327b478c71515ed48a5ab75de4ca40e9",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpp7gh1sd0.py\", line 251, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926555/tmpp7gh1sd0.py\", line 115, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpp7gh1sd0.py` failed. (See above for error)\n",
        "execution_time": 14.321731328964233,
        "failed_tests": [
          {
            "input": "nums = [123, 321, 213, 132]",
            "expected": "6",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmpp7gh1sd0.py\", line 251, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926555/tmpp7gh1sd0.py\", line 115, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmpp7gh1sd0.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "from collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(num):\n            s = str(num)\n            n = len(s)\n            variants = set()\n            variants.add(s)\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n        \n        count_map = defaultdict(int)\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                count_map[v] += 1\n        \n        total = 0\n        for cnt in count_map.values():\n            if cnt >= 2:\n                total += cnt * (cnt - 1) // 2\n        return total",
      "solution_hash": "a04bb8e001f1bc290144610210a0e95cda14b0891ccba281e3bdb9dd2bd74bd9",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmp8xjej05s.py\", line 252, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926555/tmp8xjej05s.py\", line 116, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmp8xjej05s.py` failed. (See above for error)\n",
        "execution_time": 13.489429950714111,
        "failed_tests": [
          {
            "input": "nums = [123, 321, 213, 132]",
            "expected": "6",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmp8xjej05s.py\", line 252, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926555/tmp8xjej05s.py\", line 116, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmp8xjej05s.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14",
        "1_18"
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        from itertools import combinations\n\n        def generate_variants(num):\n            s = str(num)\n            n = len(s)\n            variants = set()\n            variants.add(s)\n            for i in range(n):\n                for j in range(i+1, n):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n                    for k in range(n):\n                        for l in range(k+1, n):\n                            swapped2 = list(swapped)\n                            swapped2[k], swapped2[l] = swapped2[l], swapped2[k]\n                            variants.add(''.join(swapped2))\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            variants = generate_variants(num)\n            for var in variants:\n                total += count_map.get(var, 0)\n            count_map[num] += 1\n\n        return total",
      "solution_hash": "e60c3b1aee7f1cf56ec85b498e049ec6ce760043942156d47961ba116d78166a",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmp4q9lsrej.py\", line 252, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926555/tmp4q9lsrej.py\", line 116, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmp4q9lsrej.py` failed. (See above for error)\n",
        "execution_time": 13.516635417938232,
        "failed_tests": [
          {
            "input": "nums = [123, 321, 213, 132]",
            "expected": "6",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/21926555/tmp4q9lsrej.py\", line 252, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/21926555/tmp4q9lsrej.py\", line 116, in check\n    assert candidate(nums = [123, 321, 213, 132]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/21926555/tmp4q9lsrej.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_23",
        "1_27"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 31,
    "candidates_generated": 31,
    "tests_passed": 0,
    "tests_failed": 31,
    "test_errors": 0,
    "execution_times": [
      14.321731328964233,
      14.175324440002441,
      14.434937953948975,
      13.484452724456787,
      13.488235712051392,
      13.506927490234375,
      13.889019966125488,
      13.475865840911865,
      13.499400615692139,
      13.52065134048462,
      14.212212324142456,
      13.517977952957153,
      13.52205753326416,
      13.489429950714111,
      13.774639129638672,
      14.291882514953613,
      13.520334482192993,
      13.506206274032593,
      13.564382314682007,
      14.075968265533447,
      13.48612904548645,
      13.488598585128784,
      13.516635417938232,
      14.404868841171265,
      14.404868841171265,
      14.523355484008789,
      13.43049693107605,
      13.49001932144165,
      14.051537275314331,
      13.538744449615479,
      13.590956687927246
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 30,
      "unique_ratio": 0.967741935483871,
      "similarity_score": 0.0,
      "solution_lengths": {
        "min": 402,
        "max": 1682,
        "avg": 1159.0645161290322
      }
    },
    "test_case_analysis": {
      "hardest_cases": {
        "nums = [123, 321, 213, 132]": 18,
        "nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]": 7,
        "nums = [1000, 1001, 1010, 1100, 1, 10, 100]": 3,
        "nums = [11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 202, 303, 404, 505, 606, 707, 808, 909]": 3
      },
      "first_failing_tests": {
        "nums = [123, 321, 213, 132]": 18,
        "nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]": 7,
        "nums = [1000, 1001, 1010, 1100, 1, 10, 100]": 3,
        "nums = [11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 202, 303, 404, 505, 606, 707, 808, 909]": 3
      }
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 7,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 21,
          "improvements": 0,
          "solved": 0
        }
      },
      "error_types": {
        "assertion_failure": {
          "attempts": 10,
          "improvements": 0
        }
      },
      "test_case_improvements": {},
      "error_transitions": {
        "assertion_failure->assertion_failure": 28
      }
    },
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.5806451612903225,
        "solutions_per_depth": {
          "0": 3,
          "1": 7,
          "2": 21
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.03125,
        "pass@3": 0.09375,
        "pass@5": 0.15625,
        "pass@10": 0.3125
      },
      "solutions_evaluated": 32
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0
      },
      "error_recovery": {
        "total_attempts": 10,
        "total_improvements": 0,
        "recovery_rate": 0.0
      },
      "top_errors": [
        [
          "assertion_failure",
          10
        ]
      ],
      "hardest_test_cases": [
        [
          "nums = [123, 321, 213, 132]",
          18
        ],
        [
          "nums = [123456, 654321, 12345, 54321, 1234, 4321, 123, 321, 12, 21, 1]",
          7
        ],
        [
          "nums = [1000, 1001, 1010, 1100, 1, 10, 100]",
          3
        ],
        [
          "nums = [11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 202, 303, 404, 505, 606, 707, 808, 909]",
          3
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      }
    }
  },
  "processing_time": 2459.5009734630585,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.03125,
      "pass@3": 0.09375,
      "pass@5": 0.15625,
      "pass@10": 0.3125
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 31
          }
        ]
      ]
    },
    "solutions_evaluated": 32,
    "test_cases": 1
  }
}