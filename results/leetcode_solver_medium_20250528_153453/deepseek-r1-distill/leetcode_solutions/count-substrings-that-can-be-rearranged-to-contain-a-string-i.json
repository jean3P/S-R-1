{
  "problem_id": "count-substrings-that-can-be-rearranged-to-contain-a-string-i",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "unsolved",
  "best_solution": "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            idx = ord(c) - ord('a')\n            if 0 <= idx < 26:\n                target[idx] += 1\n        \n        # Precompute prefix sums for each character\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            if 0 <= idx < 26:\n                prefix[i+1][idx] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
  "passed_solutions": [
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            idx = ord(c) - ord('a')\n            if 0 <= idx < 26:\n                target[idx] += 1\n        \n        # Precompute prefix sums for each character\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            if 0 <= idx < 26:\n                prefix[i+1][idx] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            if 'a' <= c <= 'z':\n                target[ord(c) - ord('a')] += 1\n        \n        # Precompute prefix sums for each character\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            if 'a' <= c <= 'z':\n                prefix[i+1][ord(c) - ord('a')] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2, considering only lowercase letters\n        target = [0] * 26\n        for c in word2:\n            if 'a' <= c <= 'z':\n                target[ord(c) - ord('a')] += 1\n        \n        # Precompute prefix sums for each character, considering only lowercase letters\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            if 'a' <= c <= 'z':\n                prefix[i+1][ord(c) - ord('a')] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result"
  ],
  "all_solutions": [
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] == window[idx]:\n                matches += 1\n            elif count_word2[idx] == window[idx] - 1:\n                matches -= 1\n            \n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                \n                if count_word2[left_idx] == window[left_idx]:\n                    matches += 1\n                elif count_word2[left_idx] == window[left_idx] + 1:\n                    matches -= 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0:\n                if window[idx] == count_word2[idx]:\n                    matches += 1\n                elif window[idx] > count_word2[idx]:\n                    pass\n                else:\n                    pass\n            \n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                \n                if count_word2[left_idx] > 0:\n                    if window[left_idx] == count_word2[left_idx] - 1:\n                        matches -= 1\n                    elif window[left_idx] == count_word2[left_idx]:\n                        pass\n                    else:\n                        pass\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0:\n                if window[idx] == count_word2[idx]:\n                    matches += 1\n                elif window[idx] > count_word2[idx]:\n                    pass\n                else:\n                    pass\n            \n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                \n                if count_word2[left_idx] > 0:\n                    if window[left_idx] == count_word2[left_idx] - 1:\n                        matches -= 1\n                    elif window[left_idx] == count_word2[left_idx]:\n                        pass\n                    else:\n                        pass\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            # Check if current window is valid\n            if i >= len2 - 1:\n                valid = True\n                for j in range(26):\n                    if window[j] < count_word2[j]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n                \n                # Slide the window\n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0:\n                if window[idx] == count_word2[idx]:\n                    matches += 1\n                elif window[idx] > count_word2[idx]:\n                    pass\n                else:\n                    pass\n            \n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                \n                if count_word2[left_idx] > 0:\n                    if window[left_idx] == count_word2[left_idx] - 1:\n                        matches -= 1\n                    elif window[left_idx] < count_word2[left_idx]:\n                        pass\n                    else:\n                        pass\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0 and window[idx] == count_word2[idx]:\n                matches += 1\n            elif count_word2[idx] > 0 and window[idx] > count_word2[idx]:\n                # This condition is not possible because we are adding to the window\n                pass\n            \n            # Check if current window is valid\n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                # Now, we need to consider all possible extensions beyond len2\n                # So, for each position, after the initial window, we can extend the window\n                # and check if the current window is valid\n                # However, this approach is not efficient for large len1\n                # Instead, we can use a different approach where we track the earliest position\n                # where the window becomes valid and count all possible substrings from there\n                # But for the sake of time, let's adjust the initial approach\n                \n                # Instead of moving the left pointer, we can count all possible substrings\n                # starting from the current left position and extending to the end\n                # But this would be O(n^2), which is not efficient for len1=1e5\n                # So, we need a more efficient way\n                \n                # Alternative approach: for each right, find the earliest left where the window is valid\n                # Then, the number of valid substrings ending at right is (right - left + 1)\n                # But this requires tracking the earliest left for each right\n                \n                # Let's implement this approach\n                \n                # To do this, we'll maintain a sliding window where the window [left, right] is the smallest window\n                # that contains all required characters. Then, any window starting at left and ending at right or beyond\n                # will also be valid.\n                \n                # So, for each right, we'll find the smallest left such that the window [left, right] is valid\n                # Then, the number of valid substrings ending at right is (right - left + 1)\n                \n                # However, this approach may not directly apply because the window can be any size >= len2\n                # So, perhaps a better way is to track the earliest left where the window is valid, and for each right >= len2-1,\n                # the number of valid substrings is (right - left + 1) - (len2 - 1)\n                # Wait, perhaps not. Let's think differently.\n                \n                # Let's track the earliest left where the window [left, right] is valid. Then, for each right, the number of valid\n                # substrings ending at right is (right - left + 1) - (len2 - 1) = right - left + 1 - len2 + 1 = right - left + 2 - len2\n                # But this might not be correct. Alternatively, for each right, the number of valid substrings is (right - left + 1) if the window is valid.\n                # But this is getting complicated.\n                \n                # Let's try to adjust the initial approach to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial approach, when the window is valid, we can count all possible substrings that include this window and extend to the right.\n                # But this would require nested loops, which is not efficient.\n                \n                # Another idea: for each position in word1, determine the earliest position where the substring from that position to current is valid.\n                # Then, for each such position, the number of valid substrings is (current position - earliest position + 1).\n                \n                # This seems more manageable. Let's try to implement this.\n                \n                # We'll maintain a sliding window where the window [left, right] is the smallest window that contains all required characters.\n                # For each right, we'll find the smallest left such that the window is valid.\n                # Then, for each right, the number of valid substrings ending at right is (right - left + 1) - (len2 - 1) = right - left + 1 - len2 + 1 = right - left + 2 - len2\n                # Wait, perhaps not. Let's think again.\n                \n                # The valid substrings are those that have length >= len2 and contain all required characters.\n                # So, for each right, the number of valid substrings ending at right is the number of left positions <= right - len2 + 1 such that the window [left, right] is valid.\n                \n                # Alternatively, for each right, the earliest left where the window is valid is found, and then all left positions from that left to right - len2 + 1 are valid.\n                \n                # This is getting a bit too abstract. Let's try to adjust the initial code to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial code, when the window is valid, we can count all possible substrings that start at any position from the current left to i - len2 + 1, and end at i.\n                # But this would require O(n^2) time, which is not feasible for len1=1e5.\n                \n                # Therefore, we need a more efficient approach.\n                \n                # Let's consider that a valid substring must have a length >= len2 and contain all the required characters with counts >= those in word2.\n                # So, for each position in word1, we can track the counts and determine if the substring from some left to current right is valid.\n                # Once the window is valid, any extension to the right will also be valid, so we can count all possible substrings starting from the current left to the current right.\n                \n                # Wait, no. Because adding more characters can only increase the counts, so once a window is valid, any larger window including it will also be valid.\n                # So, for each right, once we find the smallest left where the window is valid, then all substrings starting from left to right, and ending at right, are valid.\n                # The number of such substrings is (right - left + 1) - (len2 - 1) = right - left + 1 - len2 + 1 = right - left + 2 - len2\n                # Wait, perhaps not. Let's think differently.\n                \n                # For example, if the window [left, right] is valid, then any substring [x, right] where x <= left is also valid, as long as x <= right - len2 + 1.\n                # Wait, no. Because the substring [x, right] must have length >= len2, so x <= right - len2 + 1.\n                \n                # So, for each right, the number of valid substrings ending at right is the number of x such that x <= right - len2 + 1 and the window [x, right] is valid.\n                \n                # To find this efficiently, we can maintain a sliding window where the window [left, right] is the smallest window that is valid. Then, for each right, the number of valid substrings is (right - left + 1) if the window is valid.\n                \n                # But I'm getting stuck. Let's try to adjust the initial code to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial code, when the window is valid, we can count all possible substrings that include this window and have length >= len2.\n                # But this is not straightforward.\n                \n                # Another approach: for each possible starting index in word1, find the earliest ending index where the substring is valid, and then count all substrings from that starting index to any ending index >= that earliest ending index.\n                \n                # This would require O(n^2) time in the worst case, which is not acceptable for len1=1e5.\n                \n                # Therefore, we need a more efficient way.\n                \n                # Let's think about the problem differently. A substring is valid if it contains all the characters in word2 with at least the required counts.\n                # So, for each position in word1, we can track the counts of characters and determine if the substring from some left to current right is valid.\n                # Once the window is valid, any extension to the right will also be valid, so we can count all possible substrings starting from the current left to the current right.\n                \n                # Wait, no. Because adding more characters can only increase the counts, so once a window is valid, any larger window including it will also be valid.\n                # So, for each right, once we find the smallest left where the window is valid, then all substrings starting from left to right, and ending at right, are valid.\n                # The number of such substrings is (right - left + 1) - (len2 - 1) = right - left + 1 - len2 + 1 = right - left + 2 - len2\n                # Wait, perhaps not. Let's think with an example.\n                \n                # Example 1: word1 = \"bcca\", word2 = \"abc\"\n                # len2 = 3\n                # The valid substring is \"bcca\" (length 4). So, for right=3 (0-based), left=0.\n                # The number of valid substrings ending at right=3 is 1 (the substring itself).\n                \n                # According to the formula: right - left + 2 - len2 = 3 - 0 + 2 -3 = 2. Which is incorrect.\n                \n                # So, perhaps the formula is not correct.\n                \n                # Another idea: for each right, the number of valid substrings ending at right is (right - left + 1) if the window is valid, but only for substrings of length >= len2.\n                \n                # Wait, no. Because the window can be longer than len2, but the substring can be any length >= len2 as long as it contains the required characters.\n                \n                # This is getting too complicated. Let's try to adjust the initial code to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial code, when the window is valid, we can count all possible substrings that include this window and have length >= len2.\n                # But this is not straightforward.\n                \n                # Perhaps a better approach is to precompute the prefix sums of character counts and then for each possible substring, check if it contains all required characters with sufficient counts.\n                # But this would be O(n^2), which is not feasible for len1=1e5.\n                \n                # Therefore, we need a more efficient approach.\n                \n                # Let's consider that a valid substring must have a length >= len2 and contain all the required characters with counts >= those in word2.\n                # So, for each position in word1, we can track the counts and determine if the substring from some left to current right is valid.\n                # Once the window is valid, any extension to the right will also be valid, so we can count all possible substrings starting from the current left to the current right.\n                \n                # Wait, no. Because adding more characters can only increase the counts, so once a window is valid, any larger window including it will also be valid.\n                # So, for each right, once we find the smallest left where the window is valid, then all substrings starting from left to right, and ending at right, are valid.\n                # The number of such substrings is (right - left + 1) if the window is valid, but only for substrings of length >= len2.\n                \n                # Wait, no. Because the window can be longer than len2, but the substring can be any length >= len2 as long as it contains the required characters.\n                \n                # This is getting too complicated. Let's try to adjust the initial code to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial code, when the window is valid, we can count all possible substrings that include this window and have length >= len2.\n                # But this is not straightforward.\n                \n                # Another idea: for each right, find the earliest left where the window is valid. Then, the number of valid substrings ending at right is (right - left + 1) - (len2 - 1) = right - left + 1 - len2 + 1 = right - left + 2 - len2\n                # Wait, perhaps not. Let's think with an example.\n                \n                # Example 1: word1 = \"bcca\", word2 = \"abc\"\n                # len2 = 3\n                # The valid substring is \"bcca\" (length 4). So, for right=3 (0-based), left=0.\n                # The number of valid substrings ending at right=3 is 1 (the substring itself).\n                # According to the formula: 3 - 0 + 2 -3 = 2. Which is incorrect.\n                \n                # So, perhaps the formula is not correct.\n                \n                # Another approach: for each right, the number of valid substrings ending at right is the number of left positions <= right - len2 + 1 such that the window [left, right] is valid.\n                \n                # To find this efficiently, we can maintain a sliding window where the window [left, right] is the smallest window that is valid. Then, for each right, the number of valid substrings is (right - left + 1) if the window is valid.\n                \n                # But I'm getting stuck. Let's try to adjust the initial code to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial code, when the window is valid, we can count all possible substrings that include this window and have length >= len2.\n                # But this is not straightforward.\n                \n                # Perhaps a better approach is to precompute the prefix sums of character counts and then for each possible substring, check if it contains all required characters with sufficient counts.\n                # But this would be O(n^2), which is not feasible for len1=1e5.\n                \n                # Therefore, we need a more efficient approach.\n                \n                # Let's consider that a valid substring must have a length >= len2 and contain all the required characters with counts >= those in word2.\n                # So, for each position in word1, we can track the counts and determine if the substring from some left to current right is valid.\n                # Once the window is valid, any extension to the right will also be valid, so we can count all possible substrings starting from the current left to the current right.\n                \n                # Wait, no. Because adding more characters can only increase the counts, so once a window is valid, any larger window including it will also be valid.\n                # So, for each right, once we find the smallest left where the window is valid, then all substrings starting from left to right, and ending at right, are valid.\n                # The number of such substrings is (right - left + 1) if the window is valid, but only for substrings of length >= len2.\n                \n                # Wait, no. Because the window can be longer than len2, but the substring can be any length >= len2 as long as it contains the required characters.\n                \n                # This is getting too complicated. Let's try to adjust the initial code to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial code, when the window is valid, we can count all possible substrings that include this window and have length >= len2.\n                # But this is not straightforward.\n                \n                # Another idea: for each right, find the earliest left where the window is valid. Then, the number of valid substrings ending at right is (right - left + 1) - (len2 - 1) = right - left + 1 - len2 + 1 = right - left + 2 - len2\n                # Wait, perhaps not. Let's think with an example.\n                \n                # Example 1: word1 = \"bcca\", word2 = \"abc\"\n                # len2 = 3\n                # The valid substring is \"bcca\" (length 4). So, for right=3 (0-based), left=0.\n                # The number of valid substrings ending at right=3 is 1 (the substring itself).\n                # According to the formula: 3 - 0 + 2 -3 = 2. Which is incorrect.\n                \n                # So, perhaps the formula is not correct.\n                \n                # Another approach: for each right, the number of valid substrings ending at right is the number of left positions <= right - len2 + 1 such that the window [left, right] is valid.\n                \n                # To find this efficiently, we can maintain a sliding window where the window [left, right] is the smallest window that is valid. Then, for each right, the number of valid substrings is (right - left + 1) if the window is valid.\n                \n                # But I'm getting stuck. Let's try to adjust the initial code to count all valid substrings, not just those of length len2.\n                \n                # So, in the initial code, when the window is valid, we can count all possible substrings that include this window and have length >= len2.\n                # But this is not",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        left = 0\n        \n        for right in range(len1):\n            c = word1[right]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0 and window[idx] == count_word2[idx]:\n                matches += 1\n            elif count_word2[idx] > 0 and window[idx] > count_word2[idx]:\n                pass\n            \n            while matches == required and left <= right:\n                if right - left + 1 >= len2:\n                    result += (right - left + 1) - (len2 - 1)\n                \n                left_char = word1[left]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                if count_word2[left_idx] > 0 and window[left_idx] < count_word2[left_idx]:\n                    matches -= 1\n                left += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        left = 0\n        \n        for right in range(len1):\n            c = word1[right]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0 and window[idx] == count_word2[idx]:\n                matches += 1\n            elif count_word2[idx] > 0 and window[idx] > count_word2[idx]:\n                pass\n            \n            while matches == required and left <= right:\n                if right - left + 1 >= len2:\n                    result += (right - left + 1) - (len2 - 1)\n                \n                left_char = word1[left]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                if count_word2[left_idx] > 0 and window[left_idx] < count_word2[left_idx]:\n                    matches -= 1\n                left += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        left = 0\n        \n        for right in range(len1):\n            c = word1[right]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0 and window[idx] == count_word2[idx]:\n                matches += 1\n            elif count_word2[idx] > 0 and window[idx] > count_word2[idx]:\n                pass\n            \n            while matches == required and left <= right:\n                if right - left + 1 >= len2:\n                    result += (right - left + 1) - (len2 - 1)\n                left += 1\n                c_left = word1[left - 1]\n                idx_left = ord(c_left) - ord('a')\n                if count_word2[idx_left] > 0 and window[idx_left] == count_word2[idx_left]:\n                    matches -= 1\n                window[idx_left] -= 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0:\n                if window[idx] == count_word2[idx]:\n                    matches += 1\n                elif window[idx] == count_word2[idx] + 1:\n                    matches -= 1\n            \n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                \n                if count_word2[left_idx] > 0:\n                    if window[left_idx] == count_word2[left_idx]:\n                        matches += 1\n                    elif window[left_idx] == count_word2[left_idx] - 1:\n                        matches -= 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] > 0:\n                if window[idx] == count_word2[idx]:\n                    matches += 1\n                elif window[idx] == count_word2[idx] + 1:\n                    matches -= 1\n            \n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                \n                if count_word2[left_idx] > 0:\n                    if window[left_idx] == count_word2[left_idx]:\n                        matches += 1\n                    elif window[left_idx] == count_word2[left_idx] - 1:\n                        matches -= 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            # Check if the current window is valid\n            if i >= len2 - 1:\n                valid = True\n                for j in range(26):\n                    if count_word2[j] > window[j]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n                \n                # Remove the leftmost character from the window\n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        current = [0] * 26\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            current[ord(c) - ord('a')] += 1\n            \n            if i >= len2 - 1:\n                valid = True\n                for j in range(26):\n                    if current[j] < count_word2[j]:\n                        valid = False\n                        break\n                if valid:\n                    result += (len1 - i)\n                \n                left_char = word1[i - len2 + 1]\n                current[ord(left_char) - ord('a')] -= 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            target[ord(c) - ord('a')] += 1\n        \n        # Initialize current window frequency\n        current = [0] * 26\n        result = 0\n        \n        # Sliding window of size len2\n        for i in range(len1):\n            # Add current character to window\n            current[ord(word1[i]) - ord('a')] += 1\n            \n            # If window size exceeds len2, remove the leftmost character\n            if i >= len2:\n                current[ord(word1[i - len2]) - ord('a')] -= 1\n            \n            # Check if current window meets the target\n            if i >= len2 - 1:\n                valid = True\n                for j in range(26):\n                    if current[j] < target[j]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            target[ord(c) - ord('a')] += 1\n        \n        # Precompute prefix sums for each character\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            prefix[i+1][ord(c) - ord('a')] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            idx = ord(c) - ord('a')\n            if 0 <= idx < 26:\n                target[idx] += 1\n        \n        # Precompute prefix sums for each character\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            if 0 <= idx < 26:\n                prefix[i+1][idx] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            if 'a' <= c <= 'z':\n                target[ord(c) - ord('a')] += 1\n        \n        # Precompute prefix sums for each character\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            if 'a' <= c <= 'z':\n                prefix[i+1][ord(c) - ord('a')] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
    "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2, considering only lowercase letters\n        target = [0] * 26\n        for c in word2:\n            if 'a' <= c <= 'z':\n                target[ord(c) - ord('a')] += 1\n        \n        # Precompute prefix sums for each character, considering only lowercase letters\n        prefix = [[0] * 26 for _ in range(len1 + 1)]\n        for i in range(len1):\n            for j in range(26):\n                prefix[i+1][j] = prefix[i][j]\n            c = word1[i]\n            if 'a' <= c <= 'z':\n                prefix[i+1][ord(c) - ord('a')] += 1\n        \n        result = 0\n        \n        # For each possible starting index i\n        for i in range(len1):\n            # For each possible ending index j >= i + len2 - 1\n            min_j = i + len2 - 1\n            if min_j >= len1:\n                continue\n            # Check all j from min_j to len1 - 1\n            for j in range(min_j, len1):\n                # Get the counts from i to j\n                current = [prefix[j+1][k] - prefix[i][k] for k in range(26)]\n                valid = True\n                for k in range(26):\n                    if current[k] < target[k]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result"
  ],
  "total_candidates": 18,
  "nodes_explored": 18,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len2 > len1:\n            return 0\n        \n        count_word2 = [0] * 26\n        for c in word2:\n            count_word2[ord(c) - ord('a')] += 1\n        \n        window = [0] * 26\n        required = sum(1 for x in count_word2 if x > 0)\n        matches = 0\n        result = 0\n        \n        for i in range(len1):\n            c = word1[i]\n            idx = ord(c) - ord('a')\n            window[idx] += 1\n            \n            if count_word2[idx] == window[idx]:\n                matches += 1\n            elif count_word2[idx] == window[idx] - 1:\n                matches -= 1\n            \n            if i >= len2 - 1:\n                if matches == required:\n                    result += 1\n                \n                left_char = word1[i - len2 + 1]\n                left_idx = ord(left_char) - ord('a')\n                window[left_idx] -= 1\n                \n                if count_word2[left_idx] == window[left_idx]:\n                    matches += 1\n                elif count_word2[left_idx] == window[left_idx] + 1:\n                    matches -= 1\n        \n        return result",
      "solution_hash": "c531b27ded79bfe712c573dd6ebde695841be34125904ec8dc3e4c6dd9d63aa6",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpu24tyb5l.py\", line 233, in <module>\n    check(Solution().validSubstringCount)\n  File \"/scratch/local/22242032/tmpu24tyb5l.py\", line 123, in check\n    assert candidate(word1 = \"banana\",word2 = \"ban\") == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpu24tyb5l.py` failed. (See above for error)\n",
        "execution_time": 13.819929122924805,
        "failed_tests": [
          {
            "input": "word1 = \"banana\",word2 = \"ban\"",
            "expected": "4",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpu24tyb5l.py\", line 233, in <module>\n    check(Solution().validSubstringCount)\n  File \"/scratch/local/22242032/tmpu24tyb5l.py\", line 123, in check\n    assert candidate(word1 = \"banana\",word2 = \"ban\") == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpu24tyb5l.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        if len1 < len2:\n            return 0\n        \n        # Frequency count for word2\n        target = [0] * 26\n        for c in word2:\n            target[ord(c) - ord('a')] += 1\n        \n        # Initialize current window frequency\n        current = [0] * 26\n        result = 0\n        \n        # Sliding window of size len2\n        for i in range(len1):\n            # Add current character to window\n            current[ord(word1[i]) - ord('a')] += 1\n            \n            # If window size exceeds len2, remove the leftmost character\n            if i >= len2:\n                current[ord(word1[i - len2]) - ord('a')] -= 1\n            \n            # Check if current window meets the target\n            if i >= len2 - 1:\n                valid = True\n                for j in range(26):\n                    if current[j] < target[j]:\n                        valid = False\n                        break\n                if valid:\n                    result += 1\n        \n        return result",
      "solution_hash": "09814f90b283763a4702d455f2ebcd07abdd722c1ba3dea812af0b78adc20e1d",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpcgoil_w2.py\", line 229, in <module>\n    check(Solution().validSubstringCount)\n  File \"/scratch/local/22242032/tmpcgoil_w2.py\", line 119, in check\n    assert candidate(word1 = \"banana\",word2 = \"ban\") == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpcgoil_w2.py` failed. (See above for error)\n",
        "execution_time": 13.770613670349121,
        "failed_tests": [
          {
            "input": "word1 = \"banana\",word2 = \"ban\"",
            "expected": "4",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpcgoil_w2.py\", line 229, in <module>\n    check(Solution().validSubstringCount)\n  File \"/scratch/local/22242032/tmpcgoil_w2.py\", line 119, in check\n    assert candidate(word1 = \"banana\",word2 = \"ban\") == 4\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpcgoil_w2.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 18,
    "candidates_generated": 18,
    "tests_passed": 3,
    "tests_failed": 15,
    "test_timeouts": 0,
    "test_errors": 0,
    "import_errors": 0,
    "import_terminated_branches": 0,
    "unique_import_failures": [],
    "execution_times": [
      13.819929122924805,
      13.8184335231781,
      13.8184335231781,
      13.833351850509644,
      13.846901416778564,
      13.802129983901978,
      13.85254168510437,
      13.85254168510437,
      13.794077634811401,
      13.828414916992188,
      13.828414916992188,
      13.818243265151978,
      13.828844547271729,
      13.770613670349121,
      14.009940147399902,
      13.99526333808899,
      14.018002271652222,
      14.018002271652222
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 1,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 14,
      "unique_ratio": 0.7777777777777778,
      "similarity_score": 0.9151017199053973,
      "solution_lengths": {
        "min": 892,
        "max": 18150,
        "avg": 2220.6666666666665
      },
      "algorithm_approaches": {
        "binary_search": 3,
        "two_pointers": 1,
        "sliding_window": 14
      },
      "feature_diversity": 0.8333333333333334,
      "features_analysis": {
        "boolean_features": {
          "has_recursion": {
            "true_ratio": 1.0,
            "count": 18
          },
          "uses_list": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dict": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_set": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_heap": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_queue": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_stack": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dp": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_bfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_binary_search": {
            "true_ratio": 0.16666666666666666,
            "count": 3
          },
          "nested_loops": {
            "true_ratio": 1.0,
            "count": 18
          }
        },
        "numeric_features": {
          "loop_count": {
            "min": 3,
            "max": 8,
            "avg": 4.277777777777778,
            "variance": 4.0895061728395055
          },
          "if_count": {
            "min": 4,
            "max": 8,
            "avg": 5.833333333333333,
            "variance": 2.2499999999999996
          },
          "else_count": {
            "min": 0,
            "max": 2,
            "avg": 0.3333333333333333,
            "variance": 0.5555555555555554
          },
          "return_count": {
            "min": 1,
            "max": 2,
            "avg": 1.9444444444444444,
            "variance": 0.05246913580246915
          },
          "assignment_count": {
            "min": 12,
            "max": 24,
            "avg": 18.833333333333332,
            "variance": 15.472222222222225
          },
          "class_method_count": {
            "min": 1,
            "max": 1,
            "avg": 1.0,
            "variance": 0.0
          },
          "line_count": {
            "min": 30,
            "max": 227,
            "avg": 49.833333333333336,
            "variance": 1863.5833333333333
          },
          "char_count": {
            "min": 892,
            "max": 18150,
            "avg": 2220.6666666666665,
            "variance": 14952151.777777778
          },
          "max_indent": {
            "min": 20,
            "max": 24,
            "avg": 22.88888888888889,
            "variance": 3.209876543209878
          }
        }
      },
      "complexity_diversity": {
        "complexity_distribution": {
          "exponential": 18
        },
        "avg_complexity_metrics": {
          "avg_line_count": 49.833333333333336,
          "avg_loop_count": 4.277777777777778,
          "avg_condition_count": 7.055555555555555,
          "avg_method_count": 1.0,
          "avg_assignment_count": 18.833333333333332,
          "avg_max_loop_nesting": 1.0555555555555556
        },
        "complexity_diversity_ratio": 0.16666666666666666
      }
    },
    "test_case_analysis": {
      "hardest_cases": {
        "word1 = \"banana\",word2 = \"ban\"": 13,
        "word1 = \"mississippi\",word2 = \"issi\"": 1,
        "word1 = \"12345678901234567890\",word2 = \"9087654321\"": 1
      },
      "first_failing_tests": {
        "word1 = \"banana\",word2 = \"ban\"": 13,
        "word1 = \"mississippi\",word2 = \"issi\"": 1,
        "word1 = \"12345678901234567890\",word2 = \"9087654321\"": 1
      }
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 6,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 12,
          "improvements": 0,
          "solved": 3
        }
      },
      "error_types": {
        "assertion_failure": {
          "attempts": 5,
          "improvements": 0
        },
        "index_error": {
          "attempts": 1,
          "improvements": 3
        }
      },
      "test_case_improvements": {},
      "error_transitions": {
        "assertion_failure->assertion_failure": 12,
        "assertion_failure->index_error": 1,
        "index_error->unknown": 3
      }
    },
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.5555555555555556,
        "solutions_per_depth": {
          "0": 2,
          "1": 4,
          "2": 12
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 3
        }
      },
      "pass_at_k": {
        "pass@1": 0.21052631578947367,
        "pass@3": 0.5304437564499485,
        "pass@5": 0.7417440660474717,
        "pass@10": 0.9674922600619195
      },
      "solutions_evaluated": 19,
      "passing_solution_depths": {
        "min": 2,
        "max": 2,
        "avg": 2.0
      }
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.16666666666666666,
        "branch_success_rate": 0.16666666666666666,
        "test_success_rate": 0.16666666666666666
      },
      "test_results": {
        "total": 18,
        "passed": 3,
        "failed": 15,
        "timeouts": 0,
        "import_errors": 0,
        "other_errors": 0,
        "unique_import_failures": []
      },
      "error_recovery": {
        "total_attempts": 6,
        "total_improvements": 3,
        "recovery_rate": 0.5
      },
      "top_errors": [
        [
          "assertion_failure",
          5
        ],
        [
          "index_error",
          1
        ]
      ],
      "hardest_test_cases": [
        [
          "word1 = \"banana\",word2 = \"ban\"",
          13
        ],
        [
          "word1 = \"mississippi\",word2 = \"issi\"",
          1
        ],
        [
          "word1 = \"12345678901234567890\",word2 = \"9087654321\"",
          1
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 1,
        "iteration_limit": 1
      }
    }
  },
  "processing_time": 1583.70028591156,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.21052631578947367,
      "pass@3": 0.5304437564499485,
      "pass@5": 0.7417440660474717,
      "pass@10": 0.9674922600619195
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: list index out of range",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 18
          }
        ]
      ]
    },
    "solutions_evaluated": 19,
    "test_cases": 1
  }
}