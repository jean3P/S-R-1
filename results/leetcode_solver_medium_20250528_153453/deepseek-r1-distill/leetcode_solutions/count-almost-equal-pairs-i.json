{
  "problem_id": "count-almost-equal-pairs-i",
  "problem_title": "",
  "difficulty": "Medium",
  "status": "unsolved",
  "best_solution": null,
  "passed_solutions": [],
  "all_solutions": [
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(int(''.join(swapped)))\n            variants.add(n)  # include the original number\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            # Generate all possible single swaps\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Include the original number as a variant\n            variants.add(s)\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            # Count how many of these variants have been seen before\n            current = 0\n            for v in variants:\n                current += count_map.get(v, 0)\n            total += current\n            # Update the count_map with the current number's variants\n            for v in variants:\n                count_map[v] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_swap(x, y):\n            x_str = str(x)\n            y_str = str(y)\n            if len(x_str) != len(y_str):\n                return False\n            diff = []\n            for a, b in zip(x_str, y_str):\n                if a != b:\n                    diff.append((a, b))\n            if len(diff) == 0:\n                return True\n            if len(diff) != 2:\n                return False\n            return diff[0] == (diff[1][1], diff[1][0])\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_swap(nums[i], nums[j]):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            # Generate all possible single swaps\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            # Include the original number as a variant\n            variants.add(s)\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            # Count how many of these variants have been seen before\n            current = 0\n            for v in variants:\n                current += count_map.get(v, 0)\n            total += current\n            # Update the count_map with the current number's variants\n            for v in variants:\n                count_map[v] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = list(str(n))\n            variants = set()\n            # Generate all possible single swaps, including the original\n            for i in range(len(s)):\n                for j in range(i, len(s)):\n                    # Swap i and j\n                    swapped = s.copy()\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            # Count how many of these variants have been seen before\n            current = 0\n            for v in variants:\n                current += count_map.get(v, 0)\n            total += current\n            # Update the count_map with the current number's variants\n            for v in variants:\n                count_map[v] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))  # Store as string to avoid leading zero issues\n            variants.add(s)  # include the original number as string\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            # Check how many existing variants match any of the current variants\n            for v in variants:\n                total += count_map.get(v, 0)\n            # Add the current number's string representation to the count_map\n            count_map[s] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            variants.add(s)\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            variants.add(s)  # include the original\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            # Check how many existing variants match any of the current variants\n            for v in variants:\n                total += count_map.get(v, 0)\n            # Add the current number's string representation to the count_map\n            count_map[s] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))  # Store as string to handle leading zeros\n            variants.add(s)  # include the original number\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            # Count how many of these variants have been seen before\n            for v in variants:\n                total += count_map.get(v, 0)\n            # Update the count map with the current number's variants\n            for v in variants:\n                count_map[v] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            variants.add(s)  # include the original number\n            return variants\n        \n        # Group numbers by their string length\n        length_groups = defaultdict(list)\n        for num in nums:\n            s = str(num)\n            length_groups[len(s)].append(num)\n        \n        total = 0\n        \n        # Process each length group separately\n        for length, group in length_groups.items():\n            count_map = defaultdict(int)\n            for num in group:\n                s = str(num)\n                variants = generate_variants(num)\n                # Count how many of these variants have been seen before in this group\n                for v in variants:\n                    total += count_map.get(v, 0)\n                # Update the count map with the current number's variants\n                for v in variants:\n                    count_map[v] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(''.join(swapped))\n            variants.add(s)  # include the original\n            return variants\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            variants_i = generate_variants(nums[i])\n            for j in range(i+1, n):\n                variants_j = generate_variants(nums[j])\n                if variants_i & variants_j:\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def get_canonical(n):\n            s = list(str(n))\n            s.sort()\n            return ''.join(s)\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            canonical = get_canonical(num)\n            total += count_map[canonical]\n            count_map[canonical] += 1\n        \n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                s1 = str(nums[i])\n                s2 = str(nums[j])\n                if s1 == s2:\n                    count += 1\n                    continue\n                # Check if they can be made equal with one swap\n                if sorted(s1) == sorted(s2):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                # Check if x can be transformed into y by swapping two digits in x\n                if self.can_transform(x, y):\n                    count += 1\n                # Check if y can be transformed into x by swapping two digits in y\n                elif self.can_transform(y, x):\n                    count += 1\n        return count\n\n    def can_transform(self, a: int, b: int) -> bool:\n        s_a = str(a)\n        s_b = str(b)\n        # If the lengths are different, they can't be transformed\n        if len(s_a) != len(s_b):\n            return False\n        # If they are already equal, no swap needed\n        if s_a == s_b:\n            return True\n        # Count the number of differing digits\n        diff = 0\n        for c1, c2 in zip(s_a, s_b):\n            if c1 != c2:\n                diff += 1\n        # If exactly two digits differ, a single swap can make them equal\n        return diff == 2",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = str(nums[i])\n                y = str(nums[j])\n                if self.can_transform(x, y):\n                    count += 1\n        return count\n\n    def can_transform(self, a: str, b: str) -> bool:\n        if len(a) != len(b):\n            return False\n        if a == b:\n            return True\n        # Generate all possible single swaps for a\n        swaps = set()\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                # Swap i and j in a\n                swapped = list(a)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                swaps.add(''.join(swapped))\n        # Check if any swapped version equals b\n        return b in swaps",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                if self.can_transform(x, y):\n                    count += 1\n        return count\n\n    def can_transform(self, a: int, b: int) -> bool:\n        s_a = str(a)\n        s_b = str(b)\n        if len(s_a) != len(s_b):\n            return False\n        return sorted(s_a) == sorted(s_b)",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = str(nums[i])\n                y = str(nums[j])\n                if self.are_almost_equal(x, y):\n                    count += 1\n        return count\n\n    def are_almost_equal(self, a: str, b: str) -> bool:\n        if len(a) != len(b):\n            return False\n        if a == b:\n            return True\n        # Generate all possible single swaps for a\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                # Swap i and j in a\n                swapped = list(a)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                if ''.join(swapped) == b:\n                    return True\n        # Generate all possible single swaps for b\n        for i in range(len(b)):\n            for j in range(i + 1, len(b)):\n                swapped = list(b)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                if ''.join(swapped) == a:\n                    return True\n        return False",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                if x == y:\n                    count += 1\n                    continue\n                # Check if x can be transformed into y with one swap\n                if self.can_swap_once(x, y):\n                    count += 1\n        return count\n\n    def can_swap_once(self, a: int, b: int) -> bool:\n        s = str(a)\n        t = str(b)\n        # If lengths are different, can't be made equal by swapping\n        if len(s) != len(t):\n            return False\n        # If already same, no need to swap\n        if s == t:\n            return True\n        # Find the positions where the digits differ\n        diff = []\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                diff.append(i)\n                if len(diff) > 2:\n                    return False\n        # If exactly two differing positions, check if swapping makes them equal\n        if len(diff) == 2:\n            i, j = diff\n            return s[i] == t[j] and s[j] == t[i]\n        # If more than two differences, can't be fixed with one swap\n        return False",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                if x == y:\n                    count += 1\n                    continue\n                # Check if x can be transformed into y with one swap\n                if self.can_swap_once(x, y):\n                    count += 1\n        return count\n\n    def can_swap_once(self, a: int, b: int) -> bool:\n        s = str(a)\n        t = str(b)\n        # If lengths are different, can't be made equal by swapping\n        if len(s) != len(t):\n            return False\n        # If already same, no need to swap\n        if s == t:\n            return True\n        # Generate all possible single-swap variations of s and check if any equals t\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                # Swap i and j in s\n                swapped = list(s)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                if ''.join(swapped) == t:\n                    return True\n        return False",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                if x == y:\n                    count += 1\n                    continue\n                # Check if x can be transformed into y with one swap\n                if self.can_swap_once(x, y):\n                    count += 1\n        return count\n\n    def can_swap_once(self, a: int, b: int) -> bool:\n        s = str(a)\n        t = str(b)\n        # If lengths are different, can't be made equal by swapping\n        if len(s) != len(t):\n            return False\n        # If already same, no need to swap\n        if s == t:\n            return True\n        # Generate all possible single swaps for s and check if any equals t\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                # Swap i and j in s\n                swapped = list(s)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                if ''.join(swapped) == t:\n                    return True\n        return False",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                if x == y:\n                    count += 1\n                    continue\n                # Check if x can be transformed into y with one swap\n                if self.can_swap_once(x, y):\n                    count += 1\n        return count\n\n    def can_swap_once(self, a: int, b: int) -> bool:\n        s = str(a)\n        t = str(b)\n        # If lengths are different, can't be made equal by swapping\n        if len(s) != len(t):\n            return False\n        # If already same, no need to swap\n        if s == t:\n            return True\n        # Generate all possible single-swap variations of s\n        variations = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                # Swap i and j in s\n                swapped = list(s)\n                swapped[i], swapped[j] = swapped[j], swapped[i]\n                variations.add(''.join(swapped))\n        # Check if any variation equals t\n        return t in variations",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                if x == y:\n                    count += 1\n                    continue\n                s1 = str(x)\n                s2 = str(y)\n                if len(s1) != len(s2):\n                    continue\n                diff = []\n                for a, b in zip(s1, s2):\n                    if a != b:\n                        diff.append((a, b))\n                if len(diff) == 2:\n                    if (diff[0][0] == diff[1][1] and diff[0][1] == diff[1][0]):\n                        count += 1\n                elif len(diff) == 0:\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                s_x = str(x)\n                s_y = str(y)\n                if len(s_x) != len(s_y):\n                    continue\n                if sorted(s_x) == sorted(s_y):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x = nums[i]\n                y = nums[j]\n                s1 = str(x)\n                s2 = str(y)\n                if len(s1) != len(s2):\n                    continue\n                if sorted(s1) == sorted(s2):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            s1 = str(nums[i])\n            for j in range(i + 1, n):\n                s2 = str(nums[j])\n                if len(s1) != len(s2):\n                    continue\n                if sorted(s1) == sorted(s2):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            variants.add(n)\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                    variants.add(int(swapped))\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[num] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def get_key(n):\n            s = str(n)\n            return tuple(sorted(s))\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            key = get_key(num)\n            total += count_map.get(key, 0)\n            count_map[key] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_swap(x, y):\n            x_str = str(x)\n            y_str = str(y)\n            if len(x_str) != len(y_str):\n                return False\n            if x_str == y_str:\n                return True\n            # Generate all possible swaps for x\n            for i in range(len(x_str)):\n                for j in range(i+1, len(x_str)):\n                    swapped = list(x_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    if ''.join(swapped) == y_str:\n                        return True\n            # Generate all possible swaps for y\n            for i in range(len(y_str)):\n                for j in range(i+1, len(y_str)):\n                    swapped = list(y_str)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    if ''.join(swapped) == x_str:\n                        return True\n            return False\n\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if can_swap(nums[i], nums[j]):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def can_swap(x, y):\n            x_str = str(x)\n            y_str = str(y)\n            if len(x_str) != len(y_str):\n                return False\n            diff = []\n            for a, b in zip(x_str, y_str):\n                if a != b:\n                    diff.append((a, b))\n            if len(diff) == 0:\n                return True\n            if len(diff) != 2:\n                return False\n            return diff[0] == (diff[1][1], diff[1][0])\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if can_swap(nums[i], nums[j]):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def are_almost_equal(x, y):\n            x_str = str(x)\n            y_str = str(y)\n            if len(x_str) != len(y_str):\n                return False\n            diff = []\n            for a, b in zip(x_str, y_str):\n                if a != b:\n                    diff.append((a, b))\n            return len(diff) <= 2 and (len(diff) == 0 or (len(diff) == 2 and diff[0] == (diff[1][1], diff[1][0])))\n\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if are_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    swapped = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                    variants.add(swapped)\n            variants.add(s)  # Include the original string\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        from itertools import permutations\n\n        def generate_variants(n):\n            s = str(n)\n            digits = list(s)\n            seen = set()\n            for p in permutations(digits):\n                if p not in seen:\n                    seen.add(p)\n                    yield ''.join(p)\n            # Also include the original number\n            seen.add(tuple(digits))\n            yield s\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            variants = set()\n            for v in generate_variants(num):\n                variants.add(v)\n            # Now, for each variant, check how many times it has been seen before\n            for v in variants:\n                total += count_map.get(v, 0)\n            # Update the count_map with the original string\n            count_map[s] += 1\n\n        return total",
    "from itertools import permutations\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def generate_variants(n):\n            s = str(n)\n            digits = list(s)\n            variants = set()\n            for perm in permutations(digits):\n                variants.add(''.join(perm))\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    # Swap digits at positions i and j\n                    swapped = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                    variants.add(swapped)\n            variants.add(s)  # Include the original string\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i + 1, len(s)):\n                    swapped = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                    variants.add(swapped)\n            variants.add(s)  # include the original string\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1  # store the string representation\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        from itertools import permutations\n\n        def generate_variants(n):\n            s = str(n)\n            seen = set()\n            for p in permutations(s):\n                seen.add(''.join(p))\n            return seen\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n\n        return total",
    "from itertools import permutations\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            digits = list(s)\n            variants = set()\n            for perm in permutations(digits):\n                variants.add(''.join(perm))\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n\n        return total",
    "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        from itertools import permutations\n\n        def generate_variants(n):\n            s = str(n)\n            digits = list(s)\n            seen = set()\n            for p in permutations(digits):\n                variant = ''.join(p)\n                seen.add(variant)\n            return seen\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            s = str(num)\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[s] += 1\n\n        return total"
  ],
  "total_candidates": 39,
  "nodes_explored": 39,
  "tree_depth": 0,
  "solution_tree": [
    {
      "node_id": "0_0",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = list(s)\n                    swapped[i], swapped[j] = swapped[j], swapped[i]\n                    variants.add(int(''.join(swapped)))\n            variants.add(n)  # include the original number\n            return variants\n        \n        count_map = defaultdict(int)\n        total = 0\n        \n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            for v in variants:\n                count_map[v] += 1\n        \n        return total",
      "solution_hash": "1d4380851fa367159d24cd394ecf86d475b47ae35c03ff838a0a2a75c5c9eddd",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmplrcrt3e0.py\", line 237, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242032/tmplrcrt3e0.py\", line 111, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmplrcrt3e0.py` failed. (See above for error)\n",
        "execution_time": 13.848465204238892,
        "failed_tests": [
          {
            "input": "nums = [101, 110, 111, 1001, 1100]",
            "expected": "5",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmplrcrt3e0.py\", line 237, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242032/tmplrcrt3e0.py\", line 111, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmplrcrt3e0.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_1",
        "1_5",
        "1_9"
      ],
      "passed": false
    },
    {
      "node_id": "0_1",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                s1 = str(nums[i])\n                s2 = str(nums[j])\n                if s1 == s2:\n                    count += 1\n                    continue\n                # Check if they can be made equal with one swap\n                if sorted(s1) == sorted(s2):\n                    count += 1\n        return count",
      "solution_hash": "1fd39fb6e9057f2cf183c9be4c475fa87f92884046afca7338e5ae01ab969f4f",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpmway__tc.py\", line 226, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242032/tmpmway__tc.py\", line 100, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpmway__tc.py` failed. (See above for error)\n",
        "execution_time": 13.739022254943848,
        "failed_tests": [
          {
            "input": "nums = [101, 110, 111, 1001, 1100]",
            "expected": "5",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpmway__tc.py\", line 226, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242032/tmpmway__tc.py\", line 100, in check\n    assert candidate(nums = [101, 110, 111, 1001, 1100]) == 5\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpmway__tc.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_14",
        "1_18",
        "1_22"
      ],
      "passed": false
    },
    {
      "node_id": "0_2",
      "solution": "class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        def generate_variants(n):\n            s = str(n)\n            variants = set()\n            variants.add(n)\n            for i in range(len(s)):\n                for j in range(i+1, len(s)):\n                    swapped = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                    variants.add(int(swapped))\n            return variants\n\n        count_map = defaultdict(int)\n        total = 0\n\n        for num in nums:\n            variants = generate_variants(num)\n            for v in variants:\n                total += count_map.get(v, 0)\n            count_map[num] += 1\n\n        return total",
      "solution_hash": "20ab542ff85f30652b38b1d758e51f33d710043c86de29696eac5a707c3f452c",
      "test_result": {
        "status": "fail",
        "stdout": "",
        "stderr": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpdfsf0aw3.py\", line 235, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242032/tmpdfsf0aw3.py\", line 137, in check\n    assert candidate(nums = [1000, 1001, 1010, 1100, 10, 1]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpdfsf0aw3.py` failed. (See above for error)\n",
        "execution_time": 13.837263584136963,
        "failed_tests": [
          {
            "input": "nums = [1000, 1001, 1010, 1100, 10, 1]",
            "expected": "6",
            "actual": "unknown"
          }
        ],
        "error_message": "Traceback (most recent call last):\n  File \"/scratch/local/22242032/tmpdfsf0aw3.py\", line 235, in <module>\n    check(Solution().countPairs)\n  File \"/scratch/local/22242032/tmpdfsf0aw3.py\", line 137, in check\n    assert candidate(nums = [1000, 1001, 1010, 1100, 10, 1]) == 6\nAssertionError\n\nERROR conda.cli.main_run:execute(125): `conda run python /scratch/local/22242032/tmpdfsf0aw3.py` failed. (See above for error)"
      },
      "depth": 0,
      "parent_id": null,
      "children": [
        "1_27",
        "1_31",
        "1_35"
      ],
      "passed": false
    }
  ],
  "stats": {
    "nodes_explored": 39,
    "candidates_generated": 39,
    "tests_passed": 0,
    "tests_failed": 39,
    "test_timeouts": 0,
    "test_errors": 0,
    "import_errors": 0,
    "import_terminated_branches": 0,
    "unique_import_failures": [],
    "execution_times": [
      13.848465204238892,
      13.844310283660889,
      13.818764925003052,
      13.844310283660889,
      13.803816795349121,
      13.792607069015503,
      13.806213140487671,
      13.834782600402832,
      13.77629280090332,
      13.714784145355225,
      13.799441576004028,
      13.837871551513672,
      13.773627996444702,
      13.739022254943848,
      13.813485622406006,
      13.827930212020874,
      13.806896924972534,
      13.758368968963623,
      13.790157794952393,
      13.867550611495972,
      13.867550611495972,
      13.843194723129272,
      13.804678440093994,
      13.831872701644897,
      13.850403070449829,
      13.812535285949707,
      13.837263584136963,
      13.831392288208008,
      13.840548515319824,
      13.818764925003052,
      13.852537870407104,
      13.849348545074463,
      13.812066078186035,
      13.814198970794678,
      13.849348545074463,
      13.849348545074463,
      13.803670406341553,
      13.826202869415283,
      13.845367670059204
    ],
    "tree_depth": 0,
    "termination_reasons": {
      "depth_limit": 0,
      "adaptive_threshold": 0,
      "import_failures": 0,
      "early_stopping": 0,
      "iteration_limit": 1
    },
    "solution_diversity": {
      "unique_solutions": 34,
      "unique_ratio": 0.8717948717948718,
      "similarity_score": 0.8378070910117706,
      "solution_lengths": {
        "min": 399,
        "max": 1356,
        "avg": 843.5128205128206
      },
      "algorithm_approaches": {
        "backtracking": 5,
        "hash_table": 19,
        "other": 15
      },
      "feature_diversity": 0.9487179487179487,
      "features_analysis": {
        "boolean_features": {
          "has_recursion": {
            "true_ratio": 1.0,
            "count": 39
          },
          "uses_list": {
            "true_ratio": 0.6923076923076923,
            "count": 27
          },
          "uses_dict": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_set": {
            "true_ratio": 0.5641025641025641,
            "count": 22
          },
          "uses_heap": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_queue": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_stack": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dp": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_bfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_dfs": {
            "true_ratio": 0.0,
            "count": 0
          },
          "uses_binary_search": {
            "true_ratio": 0.0,
            "count": 0
          },
          "nested_loops": {
            "true_ratio": 0.9487179487179487,
            "count": 37
          }
        },
        "numeric_features": {
          "loop_count": {
            "min": 1,
            "max": 7,
            "avg": 3.641025641025641,
            "variance": 1.6660092044707426
          },
          "if_count": {
            "min": 0,
            "max": 7,
            "avg": 1.7435897435897436,
            "variance": 4.549638395792242
          },
          "else_count": {
            "min": 0,
            "max": 0,
            "avg": 0.0,
            "variance": 0.0
          },
          "return_count": {
            "min": 1,
            "max": 6,
            "avg": 2.641025641025641,
            "variance": 2.281393819855359
          },
          "assignment_count": {
            "min": 6,
            "max": 17,
            "avg": 10.461538461538462,
            "variance": 6.812623274161734
          },
          "class_method_count": {
            "min": 1,
            "max": 2,
            "avg": 1.8461538461538463,
            "variance": 0.13017751479289943
          },
          "line_count": {
            "min": 13,
            "max": 38,
            "avg": 25.923076923076923,
            "variance": 42.429980276134124
          },
          "char_count": {
            "min": 399,
            "max": 1356,
            "avg": 843.5128205128206,
            "variance": 72235.48060486522
          },
          "max_indent": {
            "min": 12,
            "max": 24,
            "avg": 19.384615384615383,
            "variance": 5.36489151873767
          }
        }
      },
      "complexity_diversity": {
        "complexity_distribution": {
          "exponential": 39
        },
        "avg_complexity_metrics": {
          "avg_line_count": 25.923076923076923,
          "avg_loop_count": 3.641025641025641,
          "avg_condition_count": 1.794871794871795,
          "avg_method_count": 1.8461538461538463,
          "avg_assignment_count": 10.461538461538462,
          "avg_max_loop_nesting": 1.0
        },
        "complexity_diversity_ratio": 0.16666666666666666
      }
    },
    "test_case_analysis": {
      "hardest_cases": {
        "nums = [101, 110, 111, 1001, 1100]": 38,
        "nums = [1000, 1001, 1010, 1100, 10, 1]": 1
      },
      "first_failing_tests": {
        "nums = [101, 110, 111, 1001, 1100]": 38,
        "nums = [1000, 1001, 1010, 1100, 10, 1]": 1
      }
    },
    "feedback_impact": {
      "depths": {
        "1": {
          "attempts": 9,
          "improvements": 0,
          "solved": 0
        },
        "2": {
          "attempts": 27,
          "improvements": 0,
          "solved": 0
        }
      },
      "error_types": {
        "assertion_failure": {
          "attempts": 12,
          "improvements": 0
        }
      },
      "test_case_improvements": {},
      "error_transitions": {
        "assertion_failure->assertion_failure": 36
      }
    },
    "code_eval_metrics": {
      "depth_statistics": {
        "min_depth": 0,
        "max_depth": 2,
        "avg_depth": 1.6153846153846154,
        "solutions_per_depth": {
          "0": 3,
          "1": 9,
          "2": 27
        },
        "passing_solutions_per_depth": {
          "0": 0,
          "1": 0,
          "2": 0
        }
      },
      "pass_at_k": {
        "pass@1": 0.025000000000000022,
        "pass@3": 0.07499999999999996,
        "pass@5": 0.125,
        "pass@10": 0.25
      },
      "solutions_evaluated": 40
    },
    "summary": {
      "efficiency": {
        "solving_rate": 0.0,
        "branch_success_rate": 0.0,
        "test_success_rate": 0.0
      },
      "test_results": {
        "total": 39,
        "passed": 0,
        "failed": 39,
        "timeouts": 0,
        "import_errors": 0,
        "other_errors": 0,
        "unique_import_failures": []
      },
      "error_recovery": {
        "total_attempts": 12,
        "total_improvements": 0,
        "recovery_rate": 0.0
      },
      "top_errors": [
        [
          "assertion_failure",
          12
        ]
      ],
      "hardest_test_cases": [
        [
          "nums = [101, 110, 111, 1001, 1100]",
          38
        ],
        [
          "nums = [1000, 1001, 1010, 1100, 10, 1]",
          1
        ]
      ],
      "termination_reasons": {
        "depth_limit": 0,
        "adaptive_threshold": 0,
        "import_failures": 0,
        "early_stopping": 0,
        "iteration_limit": 1
      }
    }
  },
  "processing_time": 2422.9573981761932,
  "code_eval_results": {
    "pass_at_k": {
      "pass@1": 0.025000000000000022,
      "pass@3": 0.07499999999999996,
      "pass@5": 0.125,
      "pass@10": 0.25
    },
    "detailed_results": {
      "0": [
        [
          0,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 0
          }
        ],
        [
          1,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 1
          }
        ],
        [
          2,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 2
          }
        ],
        [
          3,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 3
          }
        ],
        [
          4,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 4
          }
        ],
        [
          5,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 5
          }
        ],
        [
          6,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 6
          }
        ],
        [
          7,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 7
          }
        ],
        [
          8,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 8
          }
        ],
        [
          9,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 9
          }
        ],
        [
          10,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 10
          }
        ],
        [
          11,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 11
          }
        ],
        [
          12,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 12
          }
        ],
        [
          13,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 13
          }
        ],
        [
          14,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 14
          }
        ],
        [
          15,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 15
          }
        ],
        [
          16,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 16
          }
        ],
        [
          17,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 17
          }
        ],
        [
          18,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 18
          }
        ],
        [
          19,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 19
          }
        ],
        [
          20,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 20
          }
        ],
        [
          21,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 21
          }
        ],
        [
          22,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 22
          }
        ],
        [
          23,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 23
          }
        ],
        [
          24,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 24
          }
        ],
        [
          25,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 25
          }
        ],
        [
          26,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 26
          }
        ],
        [
          27,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 27
          }
        ],
        [
          28,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 28
          }
        ],
        [
          29,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 29
          }
        ],
        [
          30,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 30
          }
        ],
        [
          31,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 31
          }
        ],
        [
          32,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 32
          }
        ],
        [
          33,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 33
          }
        ],
        [
          34,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 34
          }
        ],
        [
          35,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 35
          }
        ],
        [
          36,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 36
          }
        ],
        [
          37,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 37
          }
        ],
        [
          38,
          {
            "task_id": 0,
            "passed": false,
            "result": "failed: ",
            "completion_id": 38
          }
        ],
        [
          39,
          {
            "task_id": 0,
            "passed": true,
            "result": "passed",
            "completion_id": 39
          }
        ]
      ]
    },
    "solutions_evaluated": 40,
    "test_cases": 1
  }
}