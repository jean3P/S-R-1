[
  {
    "file": "/storage/homefs/jp22b083/SSI/S-R-1/data/repositories/astropy/astropy/astropy/wcs/wcsapi/high_level_api.py",
    "function": "values_to_high_level_objects",
    "bug_lines": [
      24
    ],
    "line_start": 271,
    "line_end": 336,
    "code_content": "def values_to_high_level_objects(*world_values, low_level_wcs):\n    \"\"\"\n    Convert low level values into high level objects.\n\n    This function uses the information in ``wcs.world_axis_object_classes`` and\n    ``wcs.world_axis_object_components`` to convert low level \"values\"\n    `~.Quantity` objects, to high level objects (such as `~.SkyCoord`).\n\n    This is used in `.HighLevelWCSMixin.pixel_to_world`, but provided as a\n    separate function for use in other places where needed.\n\n    Parameters\n    ----------\n    *world_values: object\n        Low level, \"values\" representations of the world coordinates.\n\n    low_level_wcs: `.BaseLowLevelWCS`\n        The WCS object to use to interpret the coordinates.\n    \"\"\"\n    # Check the type of the input values - should be scalars or plain Numpy\n    # arrays, not e.g. Quantity. Note that we deliberately use type(w) because\n    # we don't want to match Numpy subclasses.\n    for w in world_values:\n        if not isinstance(w, numbers.Number) or not type(w) == np.ndarray:\n            raise TypeError(\n                f\"Expected world coordinates as scalars or plain Numpy \"\n                f\"arrays (got {type(w)})\"\n            )\n\n    # Cache the classes and components since this may be expensive\n    components = low_level_wcs.world_axis_object_components\n    classes = low_level_wcs.world_axis_object_classes\n\n    # Deserialize classes\n    if low_level_wcs.serialized_classes:\n        classes_new = {}\n        for key, value in classes.items():\n            classes_new[key] = deserialize_class(value, construct=False)\n        classes = classes_new\n\n    args = defaultdict(list)\n    kwargs = defaultdict(dict)\n\n    for i, (key, attr, _) in enumerate(components):\n        if isinstance(attr, str):\n            kwargs[key][attr] = world_values[i]\n        else:\n            while attr > len(args[key]) - 1:\n                args[key].append(None)\n            args[key][attr] = world_values[i]\n\n    result = []\n\n    for key in default_order(components):\n        klass, ar, kw, *rest = classes[key]\n        if len(rest) == 0:\n            klass_gen = klass\n        elif len(rest) == 1:\n            klass_gen = rest[0]\n        else:\n            raise ValueError(\n                \"Tuples in world_axis_object_classes should have length 3 or 4\"\n            )\n        result.append(klass_gen(*args[key], *ar, **kwargs[key], **kw))\n\n    return result",
    "confidence": 0.95,
    "issue_id": "bug-values_to_high_level_objects-20250504210705-aca4210f",
    "bug_type": "logic_error",
    "bug_description": "Missing parentheses in logical expression",
    "involves_multiple_methods": false,
    "alternative_locations": [],
    "patch": "```diff\n--- a/wcs/wcsapi/high_level_api.py\n+++ b/wcs/wcsapi/high_level_api.py\n@@ -24 +24 @@\n-        if not isinstance(w, numbers.Number) and not type(w) == np.ndarray:\n+        if not isinstance(w, numbers.Number) or not type(w) == np.ndarray:\n```",
    "test_file": "/storage/homefs/jp22b083/SSI/S-R-1/data/repositories/astropy/astropy/astropy/wcs/wcsapi/tests/test_high_level_api.py",
    "test_function": "test_objects_to_values",
    "processing_time": 28.092134475708008
  }
]